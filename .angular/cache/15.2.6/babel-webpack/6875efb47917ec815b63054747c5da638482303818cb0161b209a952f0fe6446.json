{"ast":null,"code":"import { Injectable, EventEmitter, NgZone, Optional, Inject, PLATFORM_ID, NgModule } from '@angular/core';\nimport { isPlatformServer } from '@angular/common';\nimport { Subscription, fromEvent, merge } from 'rxjs';\nimport { filter, throttleTime } from 'rxjs/operators';\n\n/*\n * Represents a base class for types that provide expiry detection for the Idle service.\n */\nimport * as ɵngcc0 from '@angular/core';\nclass IdleExpiry {\n  constructor() {\n    this.idValue = new Date();\n    this.idlingValue = false;\n  }\n  /*\n   * Gets or sets a unique ID for the window\n   * @param id - The id.\n   * @return The current id.\n   */\n  id(value) {\n    if (value !== void 0) {\n      if (!value) {\n        throw new Error('A value must be specified for the ID.');\n      }\n      this.idValue = value;\n    }\n    return this.idValue;\n  }\n  /*\n   * Gets or sets the idling value.\n   * @param value - The value to set.\n   * @return The idling value.\n   */\n  idling(value) {\n    if (value !== void 0) {\n      this.idlingValue = value;\n    }\n    return this.idlingValue;\n  }\n  /*\n   * Returns the current Date.\n   * @return The current Date.\n   */\n  now() {\n    /* istanbul ignore next */\n    return new Date();\n  }\n  /*\n   * Returns whether or not it is expired.\n   * @return True if expired; otherwise, false.\n   */\n  isExpired() {\n    const expiry = this.last();\n    return expiry != null && expiry <= this.now();\n  }\n}\n\n/*\n * A class for managing an interrupt from an interrupt source.\n */\nclass Interrupt {\n  constructor(source, options) {\n    this.source = source;\n    if (source.initialize) {\n      source.initialize(options);\n    }\n  }\n  /*\n   * Subscribes to the interrupt using the specified function.\n   * @param fn - The subscription function.\n   */\n  subscribe(fn) {\n    this.sub = this.source.onInterrupt.subscribe(fn);\n  }\n  /*\n   * Unsubscribes the interrupt.\n   */\n  unsubscribe() {\n    this.sub.unsubscribe();\n    this.sub = null;\n  }\n  /*\n   * Keeps the subscription but resumes interrupt events.\n   */\n  resume() {\n    this.source.attach();\n  }\n  /*\n   * Keeps the subscription but pauses interrupt events.\n   */\n  pause() {\n    this.source.detach();\n  }\n}\nclass KeepaliveSvc {}\n\n/*\n * Represents an alternative storage for browser that doesn't support localstorage. (i.e. Safari in\n * private mode)\n * @implements Storage\n */\nclass AlternativeStorage {\n  constructor() {\n    this.storageMap = {};\n  }\n  /*\n   * Returns an integer representing the number of data items stored in the storageMap object.\n   */\n  get length() {\n    return Object.keys(this.storageMap).length;\n  }\n  /*\n   * Remove all keys out of the storage.\n   */\n  clear() {\n    this.storageMap = {};\n  }\n  /*\n   * Return the key's value\n   *\n   * @param key - name of the key to retrieve the value of.\n   * @return The key's value\n   */\n  getItem(key) {\n    if (typeof this.storageMap[key] !== 'undefined') {\n      return this.storageMap[key];\n    }\n    return null;\n  }\n  /*\n   * Return the nth key in the storage\n   *\n   * @param index - the number of the key you want to get the name of.\n   * @return The name of the key.\n   */\n  key(index) {\n    return Object.keys(this.storageMap)[index] || null;\n  }\n  /*\n   * Remove a key from the storage.\n   *\n   * @param key - the name of the key you want to remove.\n   */\n  removeItem(key) {\n    this.storageMap[key] = undefined;\n  }\n  /*\n   * Add a key to the storage, or update a key's value if it already exists.\n   *\n   * @param key - the name of the key.\n   * @param value - the value you want to give to the key.\n   */\n  setItem(key, value) {\n    this.storageMap[key] = value;\n  }\n}\n\n/*\n * Represents a localStorage store.\n */\nclass LocalStorage {\n  constructor() {\n    this.storage = this.getStorage();\n  }\n  /*\n   * Safari, in Private Browsing Mode, looks like it supports localStorage but all calls to setItem\n   * throw QuotaExceededError. We're going to detect this and just silently drop any calls to\n   * setItem\n   * to avoid the entire page breaking, without having to do a check at each usage of Storage.\n   */\n  getStorage() {\n    try {\n      const storage = localStorage;\n      storage.setItem('ng2IdleStorage', '');\n      storage.removeItem('ng2IdleStorage');\n      return storage;\n    } catch (err) {\n      return new AlternativeStorage();\n    }\n  }\n  /*\n   * Gets an item in the storage.\n   *\n   * @param value - The value to get.\n   * @return The current value.\n   */\n  getItem(key) {\n    return this.storage.getItem('ng2Idle.' + key);\n  }\n  /*\n   * Removes an item in the storage.\n   *\n   * @param value - The value to remove.\n   */\n  removeItem(key) {\n    this.storage.removeItem('ng2Idle.' + key);\n  }\n  /*\n   * Sets an item in the storage.\n   *\n   * @param key - The key to set the value.\n   * @param value - The value to set to the key.\n   */\n  setItem(key, data) {\n    this.storage.setItem('ng2Idle.' + key, data);\n  }\n  /*\n   * Represents the storage, commonly use for testing purposes.\n   *\n   * @param key - The key to set the value.\n   * @param value - The value to set to the key.\n   */\n  _wrapped() {\n    return this.storage;\n  }\n}\nLocalStorage.ɵfac = function LocalStorage_Factory(t) {\n  return new (t || LocalStorage)();\n};\nLocalStorage.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n  token: LocalStorage,\n  factory: LocalStorage.ɵfac\n});\nLocalStorage.ctorParameters = () => [];\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(LocalStorage, [{\n    type: Injectable\n  }], function () {\n    return [];\n  }, null);\n})();\n\n/*\n * Represents a localStorage store of expiry values.\n * @extends IdleExpiry\n */\nclass LocalStorageExpiry extends IdleExpiry {\n  constructor(localStorage) {\n    super();\n    this.localStorage = localStorage;\n    this.idleName = 'main';\n  }\n  /*\n   * Gets or sets the last expiry date in localStorage.\n   * If localStorage doesn't work correctly (i.e. Safari in private mode), we store the expiry value in memory.\n   * @param value - The expiry value to set; omit to only return the value.\n   * @return The current expiry value.\n   */\n  last(value) {\n    if (value !== void 0) {\n      this.setExpiry(value);\n    }\n    return this.getExpiry();\n  }\n  idling(value) {\n    if (value !== void 0) {\n      this.setIdling(value);\n    }\n    return this.getIdling();\n  }\n  /*\n   * Gets the idle name.\n   * @return The name of the idle.\n   */\n  getIdleName() {\n    return this.idleName;\n  }\n  /*\n   * Sets the idle name.\n   * @param The name of the idle.\n   */\n  setIdleName(key) {\n    if (key) {\n      this.idleName = key;\n    }\n  }\n  getExpiry() {\n    const expiry = this.localStorage.getItem(this.idleName + '.expiry');\n    if (expiry) {\n      return new Date(parseInt(expiry, 10));\n    } else {\n      return null;\n    }\n  }\n  setExpiry(value) {\n    if (value) {\n      this.localStorage.setItem(this.idleName + '.expiry', value.getTime().toString());\n    } else {\n      this.localStorage.removeItem(this.idleName + '.expiry');\n    }\n  }\n  getIdling() {\n    const idling = this.localStorage.getItem(this.idleName + '.idling');\n    if (idling) {\n      return idling === 'true';\n    } else {\n      return false;\n    }\n  }\n  setIdling(value) {\n    if (value) {\n      this.localStorage.setItem(this.idleName + '.idling', value.toString());\n    } else {\n      this.localStorage.setItem(this.idleName + '.idling', 'false');\n    }\n  }\n}\nLocalStorageExpiry.ɵfac = function LocalStorageExpiry_Factory(t) {\n  return new (t || LocalStorageExpiry)(ɵngcc0.ɵɵinject(LocalStorage));\n};\nLocalStorageExpiry.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n  token: LocalStorageExpiry,\n  factory: LocalStorageExpiry.ɵfac\n});\nLocalStorageExpiry.ctorParameters = () => [{\n  type: LocalStorage\n}];\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(LocalStorageExpiry, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: LocalStorage\n    }];\n  }, null);\n})();\n\n/*\n * Indicates the desired auto resume behavior.\n */\nvar AutoResume;\n(function (AutoResume) {\n  /*\n   * Auto resume functionality will be disabled.\n   */\n  AutoResume[AutoResume[\"disabled\"] = 0] = \"disabled\";\n  /*\n   * Can resume automatically even if they are idle.\n   */\n  AutoResume[AutoResume[\"idle\"] = 1] = \"idle\";\n  /*\n   * Can only resume automatically if they are not yet idle.\n   */\n  AutoResume[AutoResume[\"notIdle\"] = 2] = \"notIdle\";\n})(AutoResume || (AutoResume = {}));\n/**\n * A service for detecting and responding to user idleness.\n */\nclass Idle {\n  constructor(expiry, zone, keepaliveSvc,\n  // tslint:disable-next-line: ban-types platform id injection will fail with any other type\n  platformId) {\n    this.expiry = expiry;\n    this.zone = zone;\n    this.platformId = platformId;\n    this.idle = 20 * 60; // in seconds\n    this.timeoutVal = 30; // in seconds\n    this.autoResume = AutoResume.idle;\n    this.interrupts = new Array();\n    this.running = false;\n    this.keepaliveEnabled = false;\n    this.onIdleStart = new EventEmitter();\n    this.onIdleEnd = new EventEmitter();\n    this.onTimeoutWarning = new EventEmitter();\n    this.onTimeout = new EventEmitter();\n    this.onInterrupt = new EventEmitter();\n    if (keepaliveSvc) {\n      this.keepaliveSvc = keepaliveSvc;\n      this.keepaliveEnabled = true;\n    }\n    this.setIdling(false);\n  }\n  /*\n   * Sets the idle name for localStorage.\n   * Important to set if multiple instances of Idle with LocalStorageExpiry\n   * @param The name of the idle.\n   */\n  setIdleName(key) {\n    if (this.expiry instanceof LocalStorageExpiry) {\n      this.expiry.setIdleName(key);\n    } else {\n      throw new Error('Cannot set expiry key name because no LocalStorageExpiry has been provided.');\n    }\n  }\n  /*\n   * Returns whether or not keepalive integration is enabled.\n   * @return True if integration is enabled; otherwise, false.\n   */\n  getKeepaliveEnabled() {\n    return this.keepaliveEnabled;\n  }\n  /*\n   * Sets and returns whether or not keepalive integration is enabled.\n   * @param True if the integration is enabled; otherwise, false.\n   * @return The current value.\n   */\n  setKeepaliveEnabled(value) {\n    if (!this.keepaliveSvc) {\n      throw new Error('Cannot enable keepalive integration because no KeepaliveSvc has been provided.');\n    }\n    return this.keepaliveEnabled = value;\n  }\n  /*\n   * Returns the current timeout value.\n   * @return The timeout value in seconds.\n   */\n  getTimeout() {\n    return this.timeoutVal;\n  }\n  /*\n   * Sets the timeout value.\n   * @param seconds - The timeout value in seconds. 0 or false to disable timeout feature.\n   * @return The current value. If disabled, the value will be 0.\n   */\n  setTimeout(seconds) {\n    if (seconds === false) {\n      this.timeoutVal = 0;\n    } else if (typeof seconds === 'number' && seconds >= 0) {\n      this.timeoutVal = seconds;\n    } else {\n      throw new Error(\"'seconds' can only be 'false' or a positive number.\");\n    }\n    return this.timeoutVal;\n  }\n  /*\n   * Returns the current idle value.\n   * @return The idle value in seconds.\n   */\n  getIdle() {\n    return this.idle;\n  }\n  /*\n   * Sets the idle value.\n   * @param seconds - The idle value in seconds.\n   * @return The idle value in seconds.\n   */\n  setIdle(seconds) {\n    if (seconds <= 0) {\n      throw new Error(\"'seconds' must be greater zero\");\n    }\n    return this.idle = seconds;\n  }\n  /*\n   * Returns the current autoresume value.\n   * @return The current value.\n   */\n  getAutoResume() {\n    return this.autoResume;\n  }\n  setAutoResume(value) {\n    return this.autoResume = value;\n  }\n  /*\n   * Sets interrupts from the specified sources.\n   * @param sources - Interrupt sources.\n   * @return The resulting interrupts.\n   */\n  setInterrupts(sources) {\n    this.clearInterrupts();\n    const self = this;\n    for (const source of sources) {\n      const options = {\n        platformId: this.platformId\n      };\n      const sub = new Interrupt(source, options);\n      sub.subscribe(args => {\n        self.interrupt(args.force, args.innerArgs);\n      });\n      this.interrupts.push(sub);\n    }\n    return this.interrupts;\n  }\n  /*\n   * Returns the current interrupts.\n   * @return The current interrupts.\n   */\n  getInterrupts() {\n    return this.interrupts;\n  }\n  /*\n   * Pauses, unsubscribes, and clears the current interrupt subscriptions.\n   */\n  clearInterrupts() {\n    for (const sub of this.interrupts) {\n      sub.pause();\n      sub.unsubscribe();\n    }\n    this.interrupts.length = 0;\n  }\n  /*\n   * Returns whether or not the service is running i.e. watching for idleness.\n   * @return True if service is watching; otherwise, false.\n   */\n  isRunning() {\n    return this.running;\n  }\n  /*\n   * Returns whether or not the user is considered idle.\n   * @return True if the user is in the idle state; otherwise, false.\n   */\n  isIdling() {\n    return this.idling;\n  }\n  /*\n   * Starts watching for inactivity.\n   */\n  watch(skipExpiry) {\n    this.safeClearInterval('idleHandle');\n    this.safeClearInterval('timeoutHandle');\n    const timeout = !this.timeoutVal ? 0 : this.timeoutVal;\n    if (!skipExpiry) {\n      const value = new Date(this.expiry.now().getTime() + (this.idle + timeout) * 1000);\n      this.expiry.last(value);\n    }\n    if (this.idling) {\n      this.toggleState();\n    }\n    if (!this.running) {\n      this.startKeepalive();\n      this.toggleInterrupts(true);\n    }\n    this.running = true;\n    const watchFn = () => {\n      this.zone.run(() => {\n        const diff = this.getExpiryDiff(timeout);\n        if (diff > 0) {\n          this.safeClearInterval('idleHandle');\n          this.setIdleIntervalOutsideOfZone(watchFn, diff);\n        } else {\n          this.toggleState();\n        }\n      });\n    };\n    this.setIdleIntervalOutsideOfZone(watchFn, this.idle * 1000);\n  }\n  /*\n   * Allows protractor tests to call waitForAngular without hanging\n   */\n  setIdleIntervalOutsideOfZone(watchFn, frequency) {\n    this.zone.runOutsideAngular(() => {\n      this.idleHandle = setInterval(watchFn, frequency);\n    });\n  }\n  /*\n   * Stops watching for inactivity.\n   */\n  stop() {\n    this.stopKeepalive();\n    this.toggleInterrupts(false);\n    this.safeClearInterval('idleHandle');\n    this.safeClearInterval('timeoutHandle');\n    this.setIdling(false);\n    this.running = false;\n    this.expiry.last(null);\n  }\n  /*\n   * Forces a timeout event and state.\n   */\n  timeout() {\n    this.stopKeepalive();\n    this.toggleInterrupts(false);\n    this.safeClearInterval('idleHandle');\n    this.safeClearInterval('timeoutHandle');\n    this.setIdling(true);\n    this.running = false;\n    this.countdown = 0;\n    this.onTimeout.emit(null);\n  }\n  /*\n   * Signals that user activity has occurred.\n   * @param force - Forces watch to be called, unless they are timed out.\n   * @param eventArgs - Optional source event arguments.\n   */\n  interrupt(force, eventArgs) {\n    if (!this.running) {\n      return;\n    }\n    if (this.timeoutVal && this.expiry.isExpired()) {\n      this.timeout();\n      return;\n    }\n    this.onInterrupt.emit(eventArgs);\n    if (force === true || this.autoResume === AutoResume.idle || this.autoResume === AutoResume.notIdle && !this.expiry.idling()) {\n      this.watch(force);\n    }\n  }\n  setIdling(value) {\n    this.idling = value;\n    this.expiry.idling(value);\n  }\n  toggleState() {\n    this.setIdling(!this.idling);\n    if (this.idling) {\n      this.onIdleStart.emit(null);\n      this.stopKeepalive();\n      if (this.timeoutVal > 0) {\n        this.countdown = this.timeoutVal;\n        this.doCountdown();\n        this.setTimoutIntervalOutsideZone(() => {\n          this.doCountdownInZone();\n        }, 1000);\n      }\n    } else {\n      this.toggleInterrupts(true);\n      this.onIdleEnd.emit(null);\n      this.startKeepalive();\n    }\n    this.safeClearInterval('idleHandle');\n  }\n  setTimoutIntervalOutsideZone(intervalFn, frequency) {\n    this.zone.runOutsideAngular(() => {\n      this.timeoutHandle = setInterval(() => {\n        intervalFn();\n      }, frequency);\n    });\n  }\n  toggleInterrupts(resume) {\n    for (const interrupt of this.interrupts) {\n      if (resume) {\n        interrupt.resume();\n      } else {\n        interrupt.pause();\n      }\n    }\n  }\n  getExpiryDiff(timeout) {\n    const now = this.expiry.now();\n    const last = this.expiry.last() || now;\n    return last.getTime() - now.getTime() - timeout * 1000;\n  }\n  doCountdownInZone() {\n    this.zone.run(() => {\n      this.doCountdown();\n    });\n  }\n  doCountdown() {\n    const diff = this.getExpiryDiff(this.timeoutVal);\n    if (diff > 0) {\n      this.safeClearInterval('timeoutHandle');\n      this.interrupt(true);\n      return;\n    }\n    if (!this.idling) {\n      return;\n    }\n    if (this.countdown <= 0) {\n      this.timeout();\n      return;\n    }\n    this.onTimeoutWarning.emit(this.countdown);\n    this.countdown--;\n  }\n  safeClearInterval(handleName) {\n    const handle = this[handleName];\n    if (handle !== null && typeof handle !== 'undefined') {\n      clearInterval(this[handleName]);\n      this[handleName] = null;\n    }\n  }\n  startKeepalive() {\n    if (!this.keepaliveSvc || !this.keepaliveEnabled) {\n      return;\n    }\n    if (this.running) {\n      this.keepaliveSvc.ping();\n    }\n    this.keepaliveSvc.start();\n  }\n  stopKeepalive() {\n    if (!this.keepaliveSvc || !this.keepaliveEnabled) {\n      return;\n    }\n    this.keepaliveSvc.stop();\n  }\n  /*\n   * Called by Angular when destroying the instance.\n   */\n  ngOnDestroy() {\n    this.stop();\n    this.clearInterrupts();\n  }\n}\nIdle.ɵfac = function Idle_Factory(t) {\n  return new (t || Idle)(ɵngcc0.ɵɵinject(IdleExpiry), ɵngcc0.ɵɵinject(ɵngcc0.NgZone), ɵngcc0.ɵɵinject(KeepaliveSvc, 8), ɵngcc0.ɵɵinject(PLATFORM_ID, 8));\n};\nIdle.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n  token: Idle,\n  factory: Idle.ɵfac\n});\nIdle.ctorParameters = () => [{\n  type: IdleExpiry\n}, {\n  type: NgZone\n}, {\n  type: KeepaliveSvc,\n  decorators: [{\n    type: Optional\n  }]\n}, {\n  type: Object,\n  decorators: [{\n    type: Optional\n  }, {\n    type: Inject,\n    args: [PLATFORM_ID]\n  }]\n}];\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(Idle, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: IdleExpiry\n    }, {\n      type: ɵngcc0.NgZone\n    }, {\n      type: KeepaliveSvc,\n      decorators: [{\n        type: Optional\n      }]\n    }, {\n      type: Object,\n      decorators: [{\n        type: Optional\n      }, {\n        type: Inject,\n        args: [PLATFORM_ID]\n      }]\n    }];\n  }, null);\n})();\n\n/*\n * A class for expressing arguments to interrupt events.\n */\nclass InterruptArgs {\n  constructor(source, innerArgs, force = false) {\n    this.source = source;\n    this.innerArgs = innerArgs;\n    this.force = force;\n  }\n}\n\n/*\n * A base for classes that act as a source for interrupts.\n */\nclass InterruptSource {\n  constructor(attachFn, detachFn) {\n    this.attachFn = attachFn;\n    this.detachFn = detachFn;\n    this.isAttached = false;\n    this.onInterrupt = new EventEmitter();\n  }\n  /*\n   * Attaches to the specified events on the specified source.\n   */\n  attach() {\n    // If the current zone is the 'angular' zone (a.k.a. NgZone) then re-enter this method in its parent zone\n    // The parent zone is usually the '<root>' zone but it can also be 'long-stack-trace-zone' in debug mode\n    // In tests, the current zone is typically a 'ProxyZone' created by async/fakeAsync (from @angular/core/testing)\n    if (Zone.current.get('isAngularZone') === true) {\n      Zone.current.parent.run(() => this.attach());\n      return;\n    }\n    if (!this.isAttached && this.attachFn) {\n      this.attachFn(this);\n    }\n    this.isAttached = true;\n  }\n  /*\n   * Detaches from the specified events on the specified source.\n   */\n  detach() {\n    if (this.isAttached && this.detachFn) {\n      this.detachFn(this);\n    }\n    this.isAttached = false;\n  }\n}\nconst defaultThrottleDelay = 500;\n/*\n * An interrupt source on an EventTarget object, such as a Window or HTMLElement.\n */\nclass EventTargetInterruptSource extends InterruptSource {\n  constructor(target, events, opts) {\n    super(null, null);\n    this.target = target;\n    this.events = events;\n    this.opts = opts;\n    this.eventSubscription = new Subscription();\n    if (typeof this.opts === 'number') {\n      this.opts = {\n        throttleDelay: this.opts,\n        passive: false\n      };\n    }\n    this.opts = this.opts || {\n      passive: false,\n      throttleDelay: defaultThrottleDelay\n    };\n    if (this.opts.throttleDelay === undefined || this.opts.throttleDelay === null) {\n      this.opts.throttleDelay = defaultThrottleDelay;\n    }\n    this.throttleDelay = this.opts.throttleDelay;\n    this.passive = !!this.opts.passive;\n  }\n  initialize(options) {\n    if ((options === null || options === void 0 ? void 0 : options.platformId) && isPlatformServer(options.platformId)) {\n      return;\n    }\n    const eventTarget = typeof this.target === 'function' ? this.target() : this.target;\n    const opts = this.passive ? {\n      passive: true\n    } : null;\n    const fromEvents = this.events.split(' ').map(eventName => fromEvent(eventTarget, eventName, opts));\n    this.eventSrc = merge(...fromEvents);\n    this.eventSrc = this.eventSrc.pipe(filter(innerArgs => !this.filterEvent(innerArgs)));\n    if (this.throttleDelay > 0) {\n      this.eventSrc = this.eventSrc.pipe(throttleTime(this.throttleDelay));\n    }\n    const handler = innerArgs => this.onInterrupt.emit(new InterruptArgs(this, innerArgs));\n    this.attachFn = () => this.eventSubscription = this.eventSrc.subscribe(handler);\n    this.detachFn = () => this.eventSubscription.unsubscribe();\n  }\n  /*\n   * Checks to see if the event should be filtered. Always returns false unless overriden.\n   * @param event - The original event object.\n   * @return True if the event should be filtered (don't cause an interrupt); otherwise, false.\n   */\n  filterEvent(event) {\n    return false;\n  }\n  /**\n   * Returns the current options being used.\n   * @return The current option values.\n   */\n  get options() {\n    return {\n      passive: this.passive,\n      throttleDelay: this.throttleDelay\n    };\n  }\n}\n\n/*\n * An interrupt source that uses events on the document element (html tag).\n */\nclass DocumentInterruptSource extends EventTargetInterruptSource {\n  constructor(events, options) {\n    super(() => document.documentElement, events, options);\n  }\n  /*\n   * Checks to see if the event should be filtered.\n   * @param event - The original event object.\n   * @return True if the event should be filtered (don't cause an interrupt); otherwise, false.\n   */\n  filterEvent(event) {\n    // some browser bad input hacks\n    if (event.type === 'mousemove' && (\n    // fix for Chrome destop notifications\n    event.originalEvent && event.originalEvent.movementX === 0 && event.originalEvent.movementY === 0 ||\n    // fix for webkit fake mousemove\n    event.movementX !== void 0 && !event.movementX || !event.movementY)) {\n      return true;\n    }\n    return false;\n  }\n}\n\n/*\n * An interrupt source on the Window object.\n */\nclass WindowInterruptSource extends EventTargetInterruptSource {\n  constructor(events, options) {\n    super(() => window, events, options);\n  }\n}\n\n/*\n * An interrupt source on the storage event of Window.\n */\nclass StorageInterruptSource extends WindowInterruptSource {\n  constructor(options = 500) {\n    super('storage', options);\n  }\n  /*\n   * Checks to see if the event should be filtered.\n   * @param event - The original event object.\n   * @return True if the event should be filtered (don't cause an interrupt); otherwise, false.\n   */\n  filterEvent(event) {\n    if (event.key && event.key.indexOf('ng2Idle.') >= 0 && event.key.indexOf('.expiry') >= 0) {\n      return false;\n    }\n    return true;\n  }\n}\n\n/*\n * Represents a simple in-memory store of expiry values.\n * @extends IdleExpiry\n */\nclass SimpleExpiry extends IdleExpiry {\n  constructor() {\n    super();\n    this.lastValue = null;\n  }\n  /*\n   * Gets or sets the last expiry date.\n   * @param value - The expiry value to set; omit to only return the value.\n   * @return The current expiry value.\n   */\n  last(value) {\n    if (value !== void 0) {\n      this.lastValue = value;\n    }\n    return this.lastValue;\n  }\n}\nclass NgIdleModule {\n  static forRoot() {\n    return {\n      ngModule: NgIdleModule,\n      providers: [LocalStorageExpiry, {\n        provide: IdleExpiry,\n        useExisting: LocalStorageExpiry\n      }, Idle]\n    };\n  }\n}\nNgIdleModule.ɵfac = function NgIdleModule_Factory(t) {\n  return new (t || NgIdleModule)();\n};\nNgIdleModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n  type: NgIdleModule\n});\nNgIdleModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n  providers: [LocalStorage]\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NgIdleModule, [{\n    type: NgModule,\n    args: [{\n      providers: [LocalStorage]\n    }]\n  }], null, null);\n})();\nfunction createDefaultInterruptSources(options) {\n  return [new DocumentInterruptSource('mousemove keydown DOMMouseScroll mousewheel mousedown touchstart touchmove scroll', options), new StorageInterruptSource(options)];\n}\nconst DEFAULT_INTERRUPTSOURCES = createDefaultInterruptSources();\n\n/*\n * Public API Surface of core\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { AutoResume, DEFAULT_INTERRUPTSOURCES, DocumentInterruptSource, EventTargetInterruptSource, Idle, IdleExpiry, InterruptArgs, InterruptSource, KeepaliveSvc, LocalStorage, LocalStorageExpiry, NgIdleModule, SimpleExpiry, StorageInterruptSource, WindowInterruptSource, createDefaultInterruptSources };","map":{"version":3,"names":["Injectable","EventEmitter","NgZone","Optional","Inject","PLATFORM_ID","NgModule","isPlatformServer","Subscription","fromEvent","merge","filter","throttleTime","ɵngcc0","IdleExpiry","constructor","idValue","Date","idlingValue","id","value","Error","idling","now","isExpired","expiry","last","Interrupt","source","options","initialize","subscribe","fn","sub","onInterrupt","unsubscribe","resume","attach","pause","detach","KeepaliveSvc","AlternativeStorage","storageMap","length","Object","keys","clear","getItem","key","index","removeItem","undefined","setItem","LocalStorage","storage","getStorage","localStorage","err","data","_wrapped","ɵfac","LocalStorage_Factory","t","ɵprov","ɵɵdefineInjectable","token","factory","ctorParameters","ngDevMode","ɵsetClassMetadata","type","LocalStorageExpiry","idleName","setExpiry","getExpiry","setIdling","getIdling","getIdleName","setIdleName","parseInt","getTime","toString","LocalStorageExpiry_Factory","ɵɵinject","AutoResume","Idle","zone","keepaliveSvc","platformId","idle","timeoutVal","autoResume","interrupts","Array","running","keepaliveEnabled","onIdleStart","onIdleEnd","onTimeoutWarning","onTimeout","getKeepaliveEnabled","setKeepaliveEnabled","getTimeout","setTimeout","seconds","getIdle","setIdle","getAutoResume","setAutoResume","setInterrupts","sources","clearInterrupts","self","args","interrupt","force","innerArgs","push","getInterrupts","isRunning","isIdling","watch","skipExpiry","safeClearInterval","timeout","toggleState","startKeepalive","toggleInterrupts","watchFn","run","diff","getExpiryDiff","setIdleIntervalOutsideOfZone","frequency","runOutsideAngular","idleHandle","setInterval","stop","stopKeepalive","countdown","emit","eventArgs","notIdle","doCountdown","setTimoutIntervalOutsideZone","doCountdownInZone","intervalFn","timeoutHandle","handleName","handle","clearInterval","ping","start","ngOnDestroy","Idle_Factory","decorators","InterruptArgs","InterruptSource","attachFn","detachFn","isAttached","Zone","current","get","parent","defaultThrottleDelay","EventTargetInterruptSource","target","events","opts","eventSubscription","throttleDelay","passive","eventTarget","fromEvents","split","map","eventName","eventSrc","pipe","filterEvent","handler","event","DocumentInterruptSource","document","documentElement","originalEvent","movementX","movementY","WindowInterruptSource","window","StorageInterruptSource","indexOf","SimpleExpiry","lastValue","NgIdleModule","forRoot","ngModule","providers","provide","useExisting","NgIdleModule_Factory","ɵmod","ɵɵdefineNgModule","ɵinj","ɵɵdefineInjector","createDefaultInterruptSources","DEFAULT_INTERRUPTSOURCES"],"sources":["/home/ceo/mmmm/createyourevent/node_modules/@ng-idle/core/__ivy_ngcc__/fesm2015/ng-idle-core.js"],"sourcesContent":["import { Injectable, EventEmitter, NgZone, Optional, Inject, PLATFORM_ID, NgModule } from '@angular/core';\nimport { isPlatformServer } from '@angular/common';\nimport { Subscription, fromEvent, merge } from 'rxjs';\nimport { filter, throttleTime } from 'rxjs/operators';\n\n/*\n * Represents a base class for types that provide expiry detection for the Idle service.\n */\nimport * as ɵngcc0 from '@angular/core';\nclass IdleExpiry {\n    constructor() {\n        this.idValue = new Date();\n        this.idlingValue = false;\n    }\n    /*\n     * Gets or sets a unique ID for the window\n     * @param id - The id.\n     * @return The current id.\n     */\n    id(value) {\n        if (value !== void 0) {\n            if (!value) {\n                throw new Error('A value must be specified for the ID.');\n            }\n            this.idValue = value;\n        }\n        return this.idValue;\n    }\n    /*\n     * Gets or sets the idling value.\n     * @param value - The value to set.\n     * @return The idling value.\n     */\n    idling(value) {\n        if (value !== void 0) {\n            this.idlingValue = value;\n        }\n        return this.idlingValue;\n    }\n    /*\n     * Returns the current Date.\n     * @return The current Date.\n     */\n    now() {\n        /* istanbul ignore next */\n        return new Date();\n    }\n    /*\n     * Returns whether or not it is expired.\n     * @return True if expired; otherwise, false.\n     */\n    isExpired() {\n        const expiry = this.last();\n        return expiry != null && expiry <= this.now();\n    }\n}\n\n/*\n * A class for managing an interrupt from an interrupt source.\n */\nclass Interrupt {\n    constructor(source, options) {\n        this.source = source;\n        if (source.initialize) {\n            source.initialize(options);\n        }\n    }\n    /*\n     * Subscribes to the interrupt using the specified function.\n     * @param fn - The subscription function.\n     */\n    subscribe(fn) {\n        this.sub = this.source.onInterrupt.subscribe(fn);\n    }\n    /*\n     * Unsubscribes the interrupt.\n     */\n    unsubscribe() {\n        this.sub.unsubscribe();\n        this.sub = null;\n    }\n    /*\n     * Keeps the subscription but resumes interrupt events.\n     */\n    resume() {\n        this.source.attach();\n    }\n    /*\n     * Keeps the subscription but pauses interrupt events.\n     */\n    pause() {\n        this.source.detach();\n    }\n}\n\nclass KeepaliveSvc {\n}\n\n/*\n * Represents an alternative storage for browser that doesn't support localstorage. (i.e. Safari in\n * private mode)\n * @implements Storage\n */\nclass AlternativeStorage {\n    constructor() {\n        this.storageMap = {};\n    }\n    /*\n     * Returns an integer representing the number of data items stored in the storageMap object.\n     */\n    get length() {\n        return Object.keys(this.storageMap).length;\n    }\n    /*\n     * Remove all keys out of the storage.\n     */\n    clear() {\n        this.storageMap = {};\n    }\n    /*\n     * Return the key's value\n     *\n     * @param key - name of the key to retrieve the value of.\n     * @return The key's value\n     */\n    getItem(key) {\n        if (typeof this.storageMap[key] !== 'undefined') {\n            return this.storageMap[key];\n        }\n        return null;\n    }\n    /*\n     * Return the nth key in the storage\n     *\n     * @param index - the number of the key you want to get the name of.\n     * @return The name of the key.\n     */\n    key(index) {\n        return Object.keys(this.storageMap)[index] || null;\n    }\n    /*\n     * Remove a key from the storage.\n     *\n     * @param key - the name of the key you want to remove.\n     */\n    removeItem(key) {\n        this.storageMap[key] = undefined;\n    }\n    /*\n     * Add a key to the storage, or update a key's value if it already exists.\n     *\n     * @param key - the name of the key.\n     * @param value - the value you want to give to the key.\n     */\n    setItem(key, value) {\n        this.storageMap[key] = value;\n    }\n}\n\n/*\n * Represents a localStorage store.\n */\nclass LocalStorage {\n    constructor() {\n        this.storage = this.getStorage();\n    }\n    /*\n     * Safari, in Private Browsing Mode, looks like it supports localStorage but all calls to setItem\n     * throw QuotaExceededError. We're going to detect this and just silently drop any calls to\n     * setItem\n     * to avoid the entire page breaking, without having to do a check at each usage of Storage.\n     */\n    getStorage() {\n        try {\n            const storage = localStorage;\n            storage.setItem('ng2IdleStorage', '');\n            storage.removeItem('ng2IdleStorage');\n            return storage;\n        }\n        catch (err) {\n            return new AlternativeStorage();\n        }\n    }\n    /*\n     * Gets an item in the storage.\n     *\n     * @param value - The value to get.\n     * @return The current value.\n     */\n    getItem(key) {\n        return this.storage.getItem('ng2Idle.' + key);\n    }\n    /*\n     * Removes an item in the storage.\n     *\n     * @param value - The value to remove.\n     */\n    removeItem(key) {\n        this.storage.removeItem('ng2Idle.' + key);\n    }\n    /*\n     * Sets an item in the storage.\n     *\n     * @param key - The key to set the value.\n     * @param value - The value to set to the key.\n     */\n    setItem(key, data) {\n        this.storage.setItem('ng2Idle.' + key, data);\n    }\n    /*\n     * Represents the storage, commonly use for testing purposes.\n     *\n     * @param key - The key to set the value.\n     * @param value - The value to set to the key.\n     */\n    _wrapped() {\n        return this.storage;\n    }\n}\nLocalStorage.ɵfac = function LocalStorage_Factory(t) { return new (t || LocalStorage)(); };\nLocalStorage.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: LocalStorage, factory: LocalStorage.ɵfac });\nLocalStorage.ctorParameters = () => [];\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(LocalStorage, [{\n        type: Injectable\n    }], function () { return []; }, null); })();\n\n/*\n * Represents a localStorage store of expiry values.\n * @extends IdleExpiry\n */\nclass LocalStorageExpiry extends IdleExpiry {\n    constructor(localStorage) {\n        super();\n        this.localStorage = localStorage;\n        this.idleName = 'main';\n    }\n    /*\n     * Gets or sets the last expiry date in localStorage.\n     * If localStorage doesn't work correctly (i.e. Safari in private mode), we store the expiry value in memory.\n     * @param value - The expiry value to set; omit to only return the value.\n     * @return The current expiry value.\n     */\n    last(value) {\n        if (value !== void 0) {\n            this.setExpiry(value);\n        }\n        return this.getExpiry();\n    }\n    idling(value) {\n        if (value !== void 0) {\n            this.setIdling(value);\n        }\n        return this.getIdling();\n    }\n    /*\n     * Gets the idle name.\n     * @return The name of the idle.\n     */\n    getIdleName() {\n        return this.idleName;\n    }\n    /*\n     * Sets the idle name.\n     * @param The name of the idle.\n     */\n    setIdleName(key) {\n        if (key) {\n            this.idleName = key;\n        }\n    }\n    getExpiry() {\n        const expiry = this.localStorage.getItem(this.idleName + '.expiry');\n        if (expiry) {\n            return new Date(parseInt(expiry, 10));\n        }\n        else {\n            return null;\n        }\n    }\n    setExpiry(value) {\n        if (value) {\n            this.localStorage.setItem(this.idleName + '.expiry', value.getTime().toString());\n        }\n        else {\n            this.localStorage.removeItem(this.idleName + '.expiry');\n        }\n    }\n    getIdling() {\n        const idling = this.localStorage.getItem(this.idleName + '.idling');\n        if (idling) {\n            return idling === 'true';\n        }\n        else {\n            return false;\n        }\n    }\n    setIdling(value) {\n        if (value) {\n            this.localStorage.setItem(this.idleName + '.idling', value.toString());\n        }\n        else {\n            this.localStorage.setItem(this.idleName + '.idling', 'false');\n        }\n    }\n}\nLocalStorageExpiry.ɵfac = function LocalStorageExpiry_Factory(t) { return new (t || LocalStorageExpiry)(ɵngcc0.ɵɵinject(LocalStorage)); };\nLocalStorageExpiry.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: LocalStorageExpiry, factory: LocalStorageExpiry.ɵfac });\nLocalStorageExpiry.ctorParameters = () => [\n    { type: LocalStorage }\n];\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(LocalStorageExpiry, [{\n        type: Injectable\n    }], function () { return [{ type: LocalStorage }]; }, null); })();\n\n/*\n * Indicates the desired auto resume behavior.\n */\nvar AutoResume;\n(function (AutoResume) {\n    /*\n     * Auto resume functionality will be disabled.\n     */\n    AutoResume[AutoResume[\"disabled\"] = 0] = \"disabled\";\n    /*\n     * Can resume automatically even if they are idle.\n     */\n    AutoResume[AutoResume[\"idle\"] = 1] = \"idle\";\n    /*\n     * Can only resume automatically if they are not yet idle.\n     */\n    AutoResume[AutoResume[\"notIdle\"] = 2] = \"notIdle\";\n})(AutoResume || (AutoResume = {}));\n/**\n * A service for detecting and responding to user idleness.\n */\nclass Idle {\n    constructor(expiry, zone, keepaliveSvc, \n    // tslint:disable-next-line: ban-types platform id injection will fail with any other type\n    platformId) {\n        this.expiry = expiry;\n        this.zone = zone;\n        this.platformId = platformId;\n        this.idle = 20 * 60; // in seconds\n        this.timeoutVal = 30; // in seconds\n        this.autoResume = AutoResume.idle;\n        this.interrupts = new Array();\n        this.running = false;\n        this.keepaliveEnabled = false;\n        this.onIdleStart = new EventEmitter();\n        this.onIdleEnd = new EventEmitter();\n        this.onTimeoutWarning = new EventEmitter();\n        this.onTimeout = new EventEmitter();\n        this.onInterrupt = new EventEmitter();\n        if (keepaliveSvc) {\n            this.keepaliveSvc = keepaliveSvc;\n            this.keepaliveEnabled = true;\n        }\n        this.setIdling(false);\n    }\n    /*\n     * Sets the idle name for localStorage.\n     * Important to set if multiple instances of Idle with LocalStorageExpiry\n     * @param The name of the idle.\n     */\n    setIdleName(key) {\n        if (this.expiry instanceof LocalStorageExpiry) {\n            this.expiry.setIdleName(key);\n        }\n        else {\n            throw new Error('Cannot set expiry key name because no LocalStorageExpiry has been provided.');\n        }\n    }\n    /*\n     * Returns whether or not keepalive integration is enabled.\n     * @return True if integration is enabled; otherwise, false.\n     */\n    getKeepaliveEnabled() {\n        return this.keepaliveEnabled;\n    }\n    /*\n     * Sets and returns whether or not keepalive integration is enabled.\n     * @param True if the integration is enabled; otherwise, false.\n     * @return The current value.\n     */\n    setKeepaliveEnabled(value) {\n        if (!this.keepaliveSvc) {\n            throw new Error('Cannot enable keepalive integration because no KeepaliveSvc has been provided.');\n        }\n        return (this.keepaliveEnabled = value);\n    }\n    /*\n     * Returns the current timeout value.\n     * @return The timeout value in seconds.\n     */\n    getTimeout() {\n        return this.timeoutVal;\n    }\n    /*\n     * Sets the timeout value.\n     * @param seconds - The timeout value in seconds. 0 or false to disable timeout feature.\n     * @return The current value. If disabled, the value will be 0.\n     */\n    setTimeout(seconds) {\n        if (seconds === false) {\n            this.timeoutVal = 0;\n        }\n        else if (typeof seconds === 'number' && seconds >= 0) {\n            this.timeoutVal = seconds;\n        }\n        else {\n            throw new Error(\"'seconds' can only be 'false' or a positive number.\");\n        }\n        return this.timeoutVal;\n    }\n    /*\n     * Returns the current idle value.\n     * @return The idle value in seconds.\n     */\n    getIdle() {\n        return this.idle;\n    }\n    /*\n     * Sets the idle value.\n     * @param seconds - The idle value in seconds.\n     * @return The idle value in seconds.\n     */\n    setIdle(seconds) {\n        if (seconds <= 0) {\n            throw new Error(\"'seconds' must be greater zero\");\n        }\n        return (this.idle = seconds);\n    }\n    /*\n     * Returns the current autoresume value.\n     * @return The current value.\n     */\n    getAutoResume() {\n        return this.autoResume;\n    }\n    setAutoResume(value) {\n        return (this.autoResume = value);\n    }\n    /*\n     * Sets interrupts from the specified sources.\n     * @param sources - Interrupt sources.\n     * @return The resulting interrupts.\n     */\n    setInterrupts(sources) {\n        this.clearInterrupts();\n        const self = this;\n        for (const source of sources) {\n            const options = { platformId: this.platformId };\n            const sub = new Interrupt(source, options);\n            sub.subscribe((args) => {\n                self.interrupt(args.force, args.innerArgs);\n            });\n            this.interrupts.push(sub);\n        }\n        return this.interrupts;\n    }\n    /*\n     * Returns the current interrupts.\n     * @return The current interrupts.\n     */\n    getInterrupts() {\n        return this.interrupts;\n    }\n    /*\n     * Pauses, unsubscribes, and clears the current interrupt subscriptions.\n     */\n    clearInterrupts() {\n        for (const sub of this.interrupts) {\n            sub.pause();\n            sub.unsubscribe();\n        }\n        this.interrupts.length = 0;\n    }\n    /*\n     * Returns whether or not the service is running i.e. watching for idleness.\n     * @return True if service is watching; otherwise, false.\n     */\n    isRunning() {\n        return this.running;\n    }\n    /*\n     * Returns whether or not the user is considered idle.\n     * @return True if the user is in the idle state; otherwise, false.\n     */\n    isIdling() {\n        return this.idling;\n    }\n    /*\n     * Starts watching for inactivity.\n     */\n    watch(skipExpiry) {\n        this.safeClearInterval('idleHandle');\n        this.safeClearInterval('timeoutHandle');\n        const timeout = !this.timeoutVal ? 0 : this.timeoutVal;\n        if (!skipExpiry) {\n            const value = new Date(this.expiry.now().getTime() + (this.idle + timeout) * 1000);\n            this.expiry.last(value);\n        }\n        if (this.idling) {\n            this.toggleState();\n        }\n        if (!this.running) {\n            this.startKeepalive();\n            this.toggleInterrupts(true);\n        }\n        this.running = true;\n        const watchFn = () => {\n            this.zone.run(() => {\n                const diff = this.getExpiryDiff(timeout);\n                if (diff > 0) {\n                    this.safeClearInterval('idleHandle');\n                    this.setIdleIntervalOutsideOfZone(watchFn, diff);\n                }\n                else {\n                    this.toggleState();\n                }\n            });\n        };\n        this.setIdleIntervalOutsideOfZone(watchFn, this.idle * 1000);\n    }\n    /*\n     * Allows protractor tests to call waitForAngular without hanging\n     */\n    setIdleIntervalOutsideOfZone(watchFn, frequency) {\n        this.zone.runOutsideAngular(() => {\n            this.idleHandle = setInterval(watchFn, frequency);\n        });\n    }\n    /*\n     * Stops watching for inactivity.\n     */\n    stop() {\n        this.stopKeepalive();\n        this.toggleInterrupts(false);\n        this.safeClearInterval('idleHandle');\n        this.safeClearInterval('timeoutHandle');\n        this.setIdling(false);\n        this.running = false;\n        this.expiry.last(null);\n    }\n    /*\n     * Forces a timeout event and state.\n     */\n    timeout() {\n        this.stopKeepalive();\n        this.toggleInterrupts(false);\n        this.safeClearInterval('idleHandle');\n        this.safeClearInterval('timeoutHandle');\n        this.setIdling(true);\n        this.running = false;\n        this.countdown = 0;\n        this.onTimeout.emit(null);\n    }\n    /*\n     * Signals that user activity has occurred.\n     * @param force - Forces watch to be called, unless they are timed out.\n     * @param eventArgs - Optional source event arguments.\n     */\n    interrupt(force, eventArgs) {\n        if (!this.running) {\n            return;\n        }\n        if (this.timeoutVal && this.expiry.isExpired()) {\n            this.timeout();\n            return;\n        }\n        this.onInterrupt.emit(eventArgs);\n        if (force === true ||\n            this.autoResume === AutoResume.idle ||\n            (this.autoResume === AutoResume.notIdle && !this.expiry.idling())) {\n            this.watch(force);\n        }\n    }\n    setIdling(value) {\n        this.idling = value;\n        this.expiry.idling(value);\n    }\n    toggleState() {\n        this.setIdling(!this.idling);\n        if (this.idling) {\n            this.onIdleStart.emit(null);\n            this.stopKeepalive();\n            if (this.timeoutVal > 0) {\n                this.countdown = this.timeoutVal;\n                this.doCountdown();\n                this.setTimoutIntervalOutsideZone(() => {\n                    this.doCountdownInZone();\n                }, 1000);\n            }\n        }\n        else {\n            this.toggleInterrupts(true);\n            this.onIdleEnd.emit(null);\n            this.startKeepalive();\n        }\n        this.safeClearInterval('idleHandle');\n    }\n    setTimoutIntervalOutsideZone(intervalFn, frequency) {\n        this.zone.runOutsideAngular(() => {\n            this.timeoutHandle = setInterval(() => {\n                intervalFn();\n            }, frequency);\n        });\n    }\n    toggleInterrupts(resume) {\n        for (const interrupt of this.interrupts) {\n            if (resume) {\n                interrupt.resume();\n            }\n            else {\n                interrupt.pause();\n            }\n        }\n    }\n    getExpiryDiff(timeout) {\n        const now = this.expiry.now();\n        const last = this.expiry.last() || now;\n        return last.getTime() - now.getTime() - timeout * 1000;\n    }\n    doCountdownInZone() {\n        this.zone.run(() => {\n            this.doCountdown();\n        });\n    }\n    doCountdown() {\n        const diff = this.getExpiryDiff(this.timeoutVal);\n        if (diff > 0) {\n            this.safeClearInterval('timeoutHandle');\n            this.interrupt(true);\n            return;\n        }\n        if (!this.idling) {\n            return;\n        }\n        if (this.countdown <= 0) {\n            this.timeout();\n            return;\n        }\n        this.onTimeoutWarning.emit(this.countdown);\n        this.countdown--;\n    }\n    safeClearInterval(handleName) {\n        const handle = this[handleName];\n        if (handle !== null && typeof handle !== 'undefined') {\n            clearInterval(this[handleName]);\n            this[handleName] = null;\n        }\n    }\n    startKeepalive() {\n        if (!this.keepaliveSvc || !this.keepaliveEnabled) {\n            return;\n        }\n        if (this.running) {\n            this.keepaliveSvc.ping();\n        }\n        this.keepaliveSvc.start();\n    }\n    stopKeepalive() {\n        if (!this.keepaliveSvc || !this.keepaliveEnabled) {\n            return;\n        }\n        this.keepaliveSvc.stop();\n    }\n    /*\n     * Called by Angular when destroying the instance.\n     */\n    ngOnDestroy() {\n        this.stop();\n        this.clearInterrupts();\n    }\n}\nIdle.ɵfac = function Idle_Factory(t) { return new (t || Idle)(ɵngcc0.ɵɵinject(IdleExpiry), ɵngcc0.ɵɵinject(ɵngcc0.NgZone), ɵngcc0.ɵɵinject(KeepaliveSvc, 8), ɵngcc0.ɵɵinject(PLATFORM_ID, 8)); };\nIdle.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: Idle, factory: Idle.ɵfac });\nIdle.ctorParameters = () => [\n    { type: IdleExpiry },\n    { type: NgZone },\n    { type: KeepaliveSvc, decorators: [{ type: Optional }] },\n    { type: Object, decorators: [{ type: Optional }, { type: Inject, args: [PLATFORM_ID,] }] }\n];\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(Idle, [{\n        type: Injectable\n    }], function () { return [{ type: IdleExpiry }, { type: ɵngcc0.NgZone }, { type: KeepaliveSvc, decorators: [{\n                type: Optional\n            }] }, { type: Object, decorators: [{\n                type: Optional\n            }, {\n                type: Inject,\n                args: [PLATFORM_ID]\n            }] }]; }, null); })();\n\n/*\n * A class for expressing arguments to interrupt events.\n */\nclass InterruptArgs {\n    constructor(source, innerArgs, force = false) {\n        this.source = source;\n        this.innerArgs = innerArgs;\n        this.force = force;\n    }\n}\n\n/*\n * A base for classes that act as a source for interrupts.\n */\nclass InterruptSource {\n    constructor(attachFn, detachFn) {\n        this.attachFn = attachFn;\n        this.detachFn = detachFn;\n        this.isAttached = false;\n        this.onInterrupt = new EventEmitter();\n    }\n    /*\n     * Attaches to the specified events on the specified source.\n     */\n    attach() {\n        // If the current zone is the 'angular' zone (a.k.a. NgZone) then re-enter this method in its parent zone\n        // The parent zone is usually the '<root>' zone but it can also be 'long-stack-trace-zone' in debug mode\n        // In tests, the current zone is typically a 'ProxyZone' created by async/fakeAsync (from @angular/core/testing)\n        if (Zone.current.get('isAngularZone') === true) {\n            Zone.current.parent.run(() => this.attach());\n            return;\n        }\n        if (!this.isAttached && this.attachFn) {\n            this.attachFn(this);\n        }\n        this.isAttached = true;\n    }\n    /*\n     * Detaches from the specified events on the specified source.\n     */\n    detach() {\n        if (this.isAttached && this.detachFn) {\n            this.detachFn(this);\n        }\n        this.isAttached = false;\n    }\n}\n\nconst defaultThrottleDelay = 500;\n/*\n * An interrupt source on an EventTarget object, such as a Window or HTMLElement.\n */\nclass EventTargetInterruptSource extends InterruptSource {\n    constructor(target, events, opts) {\n        super(null, null);\n        this.target = target;\n        this.events = events;\n        this.opts = opts;\n        this.eventSubscription = new Subscription();\n        if (typeof this.opts === 'number') {\n            this.opts = { throttleDelay: this.opts, passive: false };\n        }\n        this.opts = this.opts || {\n            passive: false,\n            throttleDelay: defaultThrottleDelay\n        };\n        if (this.opts.throttleDelay === undefined || this.opts.throttleDelay === null) {\n            this.opts.throttleDelay = defaultThrottleDelay;\n        }\n        this.throttleDelay = this.opts.throttleDelay;\n        this.passive = !!this.opts.passive;\n    }\n    initialize(options) {\n        if ((options === null || options === void 0 ? void 0 : options.platformId) && isPlatformServer(options.platformId)) {\n            return;\n        }\n        const eventTarget = typeof this.target === 'function' ? this.target() : this.target;\n        const opts = this.passive ? { passive: true } : null;\n        const fromEvents = this.events\n            .split(' ')\n            .map(eventName => fromEvent(eventTarget, eventName, opts));\n        this.eventSrc = merge(...fromEvents);\n        this.eventSrc = this.eventSrc.pipe(filter(innerArgs => !this.filterEvent(innerArgs)));\n        if (this.throttleDelay > 0) {\n            this.eventSrc = this.eventSrc.pipe(throttleTime(this.throttleDelay));\n        }\n        const handler = (innerArgs) => this.onInterrupt.emit(new InterruptArgs(this, innerArgs));\n        this.attachFn = () => (this.eventSubscription = this.eventSrc.subscribe(handler));\n        this.detachFn = () => this.eventSubscription.unsubscribe();\n    }\n    /*\n     * Checks to see if the event should be filtered. Always returns false unless overriden.\n     * @param event - The original event object.\n     * @return True if the event should be filtered (don't cause an interrupt); otherwise, false.\n     */\n    filterEvent(event) {\n        return false;\n    }\n    /**\n     * Returns the current options being used.\n     * @return The current option values.\n     */\n    get options() {\n        return {\n            passive: this.passive,\n            throttleDelay: this.throttleDelay\n        };\n    }\n}\n\n/*\n * An interrupt source that uses events on the document element (html tag).\n */\nclass DocumentInterruptSource extends EventTargetInterruptSource {\n    constructor(events, options) {\n        super(() => document.documentElement, events, options);\n    }\n    /*\n     * Checks to see if the event should be filtered.\n     * @param event - The original event object.\n     * @return True if the event should be filtered (don't cause an interrupt); otherwise, false.\n     */\n    filterEvent(event) {\n        // some browser bad input hacks\n        if (event.type === 'mousemove' &&\n            // fix for Chrome destop notifications\n            ((event.originalEvent &&\n                event.originalEvent.movementX === 0 &&\n                event.originalEvent.movementY === 0) ||\n                // fix for webkit fake mousemove\n                ((event.movementX !== void 0 && !event.movementX) || !event.movementY))) {\n            return true;\n        }\n        return false;\n    }\n}\n\n/*\n * An interrupt source on the Window object.\n */\nclass WindowInterruptSource extends EventTargetInterruptSource {\n    constructor(events, options) {\n        super(() => window, events, options);\n    }\n}\n\n/*\n * An interrupt source on the storage event of Window.\n */\nclass StorageInterruptSource extends WindowInterruptSource {\n    constructor(options = 500) {\n        super('storage', options);\n    }\n    /*\n     * Checks to see if the event should be filtered.\n     * @param event - The original event object.\n     * @return True if the event should be filtered (don't cause an interrupt); otherwise, false.\n     */\n    filterEvent(event) {\n        if (event.key &&\n            event.key.indexOf('ng2Idle.') >= 0 &&\n            event.key.indexOf('.expiry') >= 0) {\n            return false;\n        }\n        return true;\n    }\n}\n\n/*\n * Represents a simple in-memory store of expiry values.\n * @extends IdleExpiry\n */\nclass SimpleExpiry extends IdleExpiry {\n    constructor() {\n        super();\n        this.lastValue = null;\n    }\n    /*\n     * Gets or sets the last expiry date.\n     * @param value - The expiry value to set; omit to only return the value.\n     * @return The current expiry value.\n     */\n    last(value) {\n        if (value !== void 0) {\n            this.lastValue = value;\n        }\n        return this.lastValue;\n    }\n}\n\nclass NgIdleModule {\n    static forRoot() {\n        return {\n            ngModule: NgIdleModule,\n            providers: [\n                LocalStorageExpiry,\n                { provide: IdleExpiry, useExisting: LocalStorageExpiry },\n                Idle\n            ]\n        };\n    }\n}\nNgIdleModule.ɵfac = function NgIdleModule_Factory(t) { return new (t || NgIdleModule)(); };\nNgIdleModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: NgIdleModule });\nNgIdleModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ providers: [LocalStorage] });\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NgIdleModule, [{\n        type: NgModule,\n        args: [{\n                providers: [LocalStorage]\n            }]\n    }], null, null); })();\n\nfunction createDefaultInterruptSources(options) {\n    return [\n        new DocumentInterruptSource('mousemove keydown DOMMouseScroll mousewheel mousedown touchstart touchmove scroll', options),\n        new StorageInterruptSource(options)\n    ];\n}\nconst DEFAULT_INTERRUPTSOURCES = createDefaultInterruptSources();\n\n/*\n * Public API Surface of core\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { AutoResume, DEFAULT_INTERRUPTSOURCES, DocumentInterruptSource, EventTargetInterruptSource, Idle, IdleExpiry, InterruptArgs, InterruptSource, KeepaliveSvc, LocalStorage, LocalStorageExpiry, NgIdleModule, SimpleExpiry, StorageInterruptSource, WindowInterruptSource, createDefaultInterruptSources };\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}