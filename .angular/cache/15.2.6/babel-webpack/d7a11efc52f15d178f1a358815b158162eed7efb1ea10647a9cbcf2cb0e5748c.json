{"ast":null,"code":"import { Directive, ElementRef, EventEmitter, Input, NgModule, NgZone, Output } from '@angular/core';\nimport { fromEvent, of } from 'rxjs';\nimport { filter, map, mergeMap, tap, throttleTime } from 'rxjs/operators';\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/services/ngx-ins-utils.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} selector\n * @param {?} scrollWindow\n * @param {?} defaultElement\n * @param {?} fromRoot\n * @return {?}\n */\nimport * as ɵngcc0 from '@angular/core';\nfunction resolveContainerElement(selector, scrollWindow, defaultElement, fromRoot) {\n  /** @type {?} */\n  const hasWindow = window && !!window.document && window.document.documentElement;\n  /** @type {?} */\n  let container = hasWindow && scrollWindow ? window : defaultElement;\n  if (selector) {\n    /** @type {?} */\n    const containerIsString = selector && hasWindow && typeof selector === 'string';\n    container = containerIsString ? findElement(selector, defaultElement.nativeElement, fromRoot) : selector;\n    if (!container) {\n      throw new Error('ngx-infinite-scroll {resolveContainerElement()}: selector for');\n    }\n  }\n  return container;\n}\n/**\n * @param {?} selector\n * @param {?} customRoot\n * @param {?} fromRoot\n * @return {?}\n */\nfunction findElement(selector, customRoot, fromRoot) {\n  /** @type {?} */\n  const rootEl = fromRoot ? window.document : customRoot;\n  return rootEl.querySelector(selector);\n}\n/**\n * @param {?} prop\n * @return {?}\n */\nfunction inputPropChanged(prop) {\n  return prop && !prop.firstChange;\n}\n/**\n * @return {?}\n */\nfunction hasWindowDefined() {\n  return typeof window !== 'undefined';\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/services/axis-resolver.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @type {?} */\nconst VerticalProps = {\n  clientHeight: \"clientHeight\",\n  offsetHeight: \"offsetHeight\",\n  scrollHeight: \"scrollHeight\",\n  pageYOffset: \"pageYOffset\",\n  offsetTop: \"offsetTop\",\n  scrollTop: \"scrollTop\",\n  top: \"top\"\n};\n/** @type {?} */\nconst HorizontalProps = {\n  clientHeight: \"clientWidth\",\n  offsetHeight: \"offsetWidth\",\n  scrollHeight: \"scrollWidth\",\n  pageYOffset: \"pageXOffset\",\n  offsetTop: \"offsetLeft\",\n  scrollTop: \"scrollLeft\",\n  top: \"left\"\n};\nclass AxisResolver {\n  /**\n   * @param {?=} vertical\n   */\n  constructor(vertical = true) {\n    this.vertical = vertical;\n    this.propsMap = vertical ? VerticalProps : HorizontalProps;\n  }\n  /**\n   * @return {?}\n   */\n  clientHeightKey() {\n    return this.propsMap.clientHeight;\n  }\n  /**\n   * @return {?}\n   */\n  offsetHeightKey() {\n    return this.propsMap.offsetHeight;\n  }\n  /**\n   * @return {?}\n   */\n  scrollHeightKey() {\n    return this.propsMap.scrollHeight;\n  }\n  /**\n   * @return {?}\n   */\n  pageYOffsetKey() {\n    return this.propsMap.pageYOffset;\n  }\n  /**\n   * @return {?}\n   */\n  offsetTopKey() {\n    return this.propsMap.offsetTop;\n  }\n  /**\n   * @return {?}\n   */\n  scrollTopKey() {\n    return this.propsMap.scrollTop;\n  }\n  /**\n   * @return {?}\n   */\n  topKey() {\n    return this.propsMap.top;\n  }\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/services/event-trigger.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @record\n */\n\n/**\n * @record\n */\n\n/**\n * @record\n */\n\n/**\n * @record\n */\n\n/**\n * @param {?} alwaysCallback\n * @param {?} shouldFireScrollEvent\n * @param {?} isTriggeredCurrentTotal\n * @return {?}\n */\nfunction shouldTriggerEvents(alwaysCallback, shouldFireScrollEvent, isTriggeredCurrentTotal) {\n  if (alwaysCallback && shouldFireScrollEvent) {\n    return true;\n  }\n  if (!isTriggeredCurrentTotal && shouldFireScrollEvent) {\n    return true;\n  }\n  return false;\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/services/position-resolver.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} __0\n * @return {?}\n */\nfunction createResolver({\n  windowElement,\n  axis\n}) {\n  return createResolverWithContainer({\n    axis,\n    isWindow: isElementWindow(windowElement)\n  }, windowElement);\n}\n/**\n * @param {?} resolver\n * @param {?} windowElement\n * @return {?}\n */\nfunction createResolverWithContainer(resolver, windowElement) {\n  /** @type {?} */\n  const container = resolver.isWindow || windowElement && !windowElement.nativeElement ? windowElement : windowElement.nativeElement;\n  return Object.assign(Object.assign({}, resolver), {\n    container\n  });\n}\n/**\n * @param {?} windowElement\n * @return {?}\n */\nfunction isElementWindow(windowElement) {\n  /** @type {?} */\n  const isWindow = ['Window', 'global'].some(\n  /**\n  * @param {?} obj\n  * @return {?}\n  */\n  obj => Object.prototype.toString.call(windowElement).includes(obj));\n  return isWindow;\n}\n/**\n * @param {?} isContainerWindow\n * @param {?} windowElement\n * @return {?}\n */\nfunction getDocumentElement(isContainerWindow, windowElement) {\n  return isContainerWindow ? windowElement.document.documentElement : null;\n}\n/**\n * @param {?} element\n * @param {?} resolver\n * @return {?}\n */\nfunction calculatePoints(element, resolver) {\n  /** @type {?} */\n  const height = extractHeightForElement(resolver);\n  return resolver.isWindow ? calculatePointsForWindow(height, element, resolver) : calculatePointsForElement(height, element, resolver);\n}\n/**\n * @param {?} height\n * @param {?} element\n * @param {?} resolver\n * @return {?}\n */\nfunction calculatePointsForWindow(height, element, resolver) {\n  const {\n    axis,\n    container,\n    isWindow\n  } = resolver;\n  const {\n    offsetHeightKey,\n    clientHeightKey\n  } = extractHeightPropKeys(axis);\n  // scrolled until now / current y point\n  /** @type {?} */\n  const scrolled = height + getElementPageYOffset(getDocumentElement(isWindow, container), axis, isWindow);\n  // total height / most bottom y point\n  /** @type {?} */\n  const nativeElementHeight = getElementHeight(element.nativeElement, isWindow, offsetHeightKey, clientHeightKey);\n  /** @type {?} */\n  const totalToScroll = getElementOffsetTop(element.nativeElement, axis, isWindow) + nativeElementHeight;\n  return {\n    height,\n    scrolled,\n    totalToScroll,\n    isWindow\n  };\n}\n/**\n * @param {?} height\n * @param {?} element\n * @param {?} resolver\n * @return {?}\n */\nfunction calculatePointsForElement(height, element, resolver) {\n  const {\n    axis,\n    container\n  } = resolver;\n  // perhaps use container.offsetTop instead of 'scrollTop'\n  /** @type {?} */\n  const scrolled = container[axis.scrollTopKey()];\n  /** @type {?} */\n  const totalToScroll = container[axis.scrollHeightKey()];\n  return {\n    height,\n    scrolled,\n    totalToScroll,\n    isWindow: false\n  };\n}\n/**\n * @param {?} axis\n * @return {?}\n */\nfunction extractHeightPropKeys(axis) {\n  return {\n    offsetHeightKey: axis.offsetHeightKey(),\n    clientHeightKey: axis.clientHeightKey()\n  };\n}\n/**\n * @param {?} __0\n * @return {?}\n */\nfunction extractHeightForElement({\n  container,\n  isWindow,\n  axis\n}) {\n  const {\n    offsetHeightKey,\n    clientHeightKey\n  } = extractHeightPropKeys(axis);\n  return getElementHeight(container, isWindow, offsetHeightKey, clientHeightKey);\n}\n/**\n * @param {?} elem\n * @param {?} isWindow\n * @param {?} offsetHeightKey\n * @param {?} clientHeightKey\n * @return {?}\n */\nfunction getElementHeight(elem, isWindow, offsetHeightKey, clientHeightKey) {\n  if (isNaN(elem[offsetHeightKey])) {\n    /** @type {?} */\n    const docElem = getDocumentElement(isWindow, elem);\n    return docElem ? docElem[clientHeightKey] : 0;\n  } else {\n    return elem[offsetHeightKey];\n  }\n}\n/**\n * @param {?} elem\n * @param {?} axis\n * @param {?} isWindow\n * @return {?}\n */\nfunction getElementOffsetTop(elem, axis, isWindow) {\n  /** @type {?} */\n  const topKey = axis.topKey();\n  // elem = elem.nativeElement;\n  if (!elem.getBoundingClientRect) {\n    // || elem.css('none')) {\n    return;\n  }\n  return elem.getBoundingClientRect()[topKey] + getElementPageYOffset(elem, axis, isWindow);\n}\n/**\n * @param {?} elem\n * @param {?} axis\n * @param {?} isWindow\n * @return {?}\n */\nfunction getElementPageYOffset(elem, axis, isWindow) {\n  /** @type {?} */\n  const pageYOffset = axis.pageYOffsetKey();\n  /** @type {?} */\n  const scrollTop = axis.scrollTopKey();\n  /** @type {?} */\n  const offsetTop = axis.offsetTopKey();\n  if (isNaN(window.pageYOffset)) {\n    return getDocumentElement(isWindow, elem)[scrollTop];\n  } else if (elem.ownerDocument) {\n    return elem.ownerDocument.defaultView[pageYOffset];\n  } else {\n    return elem[offsetTop];\n  }\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/services/scroll-resolver.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} container\n * @param {?} distance\n * @param {?} scrollingDown\n * @return {?}\n */\nfunction shouldFireScrollEvent(container, distance, scrollingDown) {\n  /** @type {?} */\n  let remaining;\n  /** @type {?} */\n  let containerBreakpoint;\n  if (container.totalToScroll <= 0) {\n    return false;\n  }\n  /** @type {?} */\n  const scrolledUntilNow = container.isWindow ? container.scrolled : container.height + container.scrolled;\n  if (scrollingDown) {\n    remaining = (container.totalToScroll - scrolledUntilNow) / container.totalToScroll;\n    containerBreakpoint = distance.down / 10;\n  } else {\n    /** @type {?} */\n    const totalHiddenContentHeight = container.scrolled + (container.totalToScroll - scrolledUntilNow);\n    remaining = container.scrolled / totalHiddenContentHeight;\n    containerBreakpoint = distance.up / 10;\n  }\n  /** @type {?} */\n  const shouldFireEvent = remaining <= containerBreakpoint;\n  return shouldFireEvent;\n}\n/**\n * @param {?} lastScrollPosition\n * @param {?} container\n * @return {?}\n */\nfunction isScrollingDownwards(lastScrollPosition, container) {\n  return lastScrollPosition < container.scrolled;\n}\n/**\n * @param {?} lastScrollPosition\n * @param {?} container\n * @param {?} distance\n * @return {?}\n */\nfunction getScrollStats(lastScrollPosition, container, distance) {\n  /** @type {?} */\n  const scrollDown = isScrollingDownwards(lastScrollPosition, container);\n  return {\n    fire: shouldFireScrollEvent(container, distance, scrollDown),\n    scrollDown\n  };\n}\n/**\n * @param {?} position\n * @param {?} scrollState\n * @return {?}\n */\n\n/**\n * @param {?} totalToScroll\n * @param {?} scrollState\n * @return {?}\n */\n\n/**\n * @param {?} scrollState\n * @return {?}\n */\n\n/**\n * @param {?} scroll\n * @param {?} scrollState\n * @param {?} triggered\n * @param {?} isScrollingDown\n * @return {?}\n */\n\n/**\n * @param {?} totalToScroll\n * @param {?} scrollState\n * @param {?} isScrollingDown\n * @return {?}\n */\n\n/**\n * @param {?} scrollState\n * @param {?} scrolledUntilNow\n * @param {?} totalToScroll\n * @return {?}\n */\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/services/scroll-state.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass ScrollState {\n  /**\n   * @param {?} __0\n   */\n  constructor({\n    totalToScroll\n  }) {\n    this.lastScrollPosition = 0;\n    this.lastTotalToScroll = 0;\n    this.totalToScroll = 0;\n    this.triggered = {\n      down: 0,\n      up: 0\n    };\n    this.totalToScroll = totalToScroll;\n  }\n  /**\n   * @param {?} position\n   * @return {?}\n   */\n  updateScrollPosition(position) {\n    return this.lastScrollPosition = position;\n  }\n  /**\n   * @param {?} totalToScroll\n   * @return {?}\n   */\n  updateTotalToScroll(totalToScroll) {\n    if (this.lastTotalToScroll !== totalToScroll) {\n      this.lastTotalToScroll = this.totalToScroll;\n      this.totalToScroll = totalToScroll;\n    }\n  }\n  /**\n   * @param {?} scrolledUntilNow\n   * @param {?} totalToScroll\n   * @return {?}\n   */\n  updateScroll(scrolledUntilNow, totalToScroll) {\n    this.updateScrollPosition(scrolledUntilNow);\n    this.updateTotalToScroll(totalToScroll);\n  }\n  /**\n   * @param {?} scroll\n   * @param {?} isScrollingDown\n   * @return {?}\n   */\n  updateTriggeredFlag(scroll, isScrollingDown) {\n    if (isScrollingDown) {\n      this.triggered.down = scroll;\n    } else {\n      this.triggered.up = scroll;\n    }\n  }\n  /**\n   * @param {?} totalToScroll\n   * @param {?} isScrollingDown\n   * @return {?}\n   */\n  isTriggeredScroll(totalToScroll, isScrollingDown) {\n    return isScrollingDown ? this.triggered.down === totalToScroll : this.triggered.up === totalToScroll;\n  }\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/services/scroll-register.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} config\n * @return {?}\n */\nfunction createScroller(config) {\n  const {\n    scrollContainer,\n    scrollWindow,\n    element,\n    fromRoot\n  } = config;\n  /** @type {?} */\n  const resolver = createResolver({\n    axis: new AxisResolver(!config.horizontal),\n    windowElement: resolveContainerElement(scrollContainer, scrollWindow, element, fromRoot)\n  });\n  /** @type {?} */\n  const scrollState = new ScrollState({\n    totalToScroll: calculatePoints(element, resolver)\n  });\n  /** @type {?} */\n  const options = {\n    container: resolver.container,\n    throttle: config.throttle\n  };\n  /** @type {?} */\n  const distance = {\n    up: config.upDistance,\n    down: config.downDistance\n  };\n  return attachScrollEvent(options).pipe(mergeMap(\n  /**\n  * @return {?}\n  */\n  () => of(calculatePoints(element, resolver))), map(\n  /**\n  * @param {?} positionStats\n  * @return {?}\n  */\n  positionStats => toInfiniteScrollParams(scrollState.lastScrollPosition, positionStats, distance)), tap(\n  /**\n  * @param {?} __0\n  * @return {?}\n  */\n  ({\n    stats\n  }) => scrollState.updateScroll(stats.scrolled, stats.totalToScroll)), filter(\n  /**\n  * @param {?} __0\n  * @return {?}\n  */\n  ({\n    fire,\n    scrollDown,\n    stats: {\n      totalToScroll\n    }\n  }) => shouldTriggerEvents(config.alwaysCallback, fire, scrollState.isTriggeredScroll(totalToScroll, scrollDown))), tap(\n  /**\n  * @param {?} __0\n  * @return {?}\n  */\n  ({\n    scrollDown,\n    stats: {\n      totalToScroll\n    }\n  }) => {\n    scrollState.updateTriggeredFlag(totalToScroll, scrollDown);\n  }), map(toInfiniteScrollAction));\n}\n/**\n * @param {?} options\n * @return {?}\n */\nfunction attachScrollEvent(options) {\n  /** @type {?} */\n  let obs = fromEvent(options.container, 'scroll');\n  // For an unknown reason calling `sampleTime()` causes trouble for many users, even with `options.throttle = 0`.\n  // Let's avoid calling the function unless needed.\n  // Replacing with throttleTime seems to solve the problem\n  // See https://github.com/orizens/ngx-infinite-scroll/issues/198\n  if (options.throttle) {\n    obs = obs.pipe(throttleTime(options.throttle));\n  }\n  return obs;\n}\n/**\n * @param {?} lastScrollPosition\n * @param {?} stats\n * @param {?} distance\n * @return {?}\n */\nfunction toInfiniteScrollParams(lastScrollPosition, stats, distance) {\n  const {\n    scrollDown,\n    fire\n  } = getScrollStats(lastScrollPosition, stats, distance);\n  return {\n    scrollDown,\n    fire,\n    stats\n  };\n}\n/** @type {?} */\nconst InfiniteScrollActions = {\n  DOWN: '[NGX_ISE] DOWN',\n  UP: '[NGX_ISE] UP'\n};\n/**\n * @param {?} response\n * @return {?}\n */\nfunction toInfiniteScrollAction(response) {\n  const {\n    scrollDown,\n    stats: {\n      scrolled: currentScrollPosition\n    }\n  } = response;\n  return {\n    type: scrollDown ? InfiniteScrollActions.DOWN : InfiniteScrollActions.UP,\n    payload: {\n      currentScrollPosition\n    }\n  };\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/modules/infinite-scroll.directive.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass InfiniteScrollDirective {\n  /**\n   * @param {?} element\n   * @param {?} zone\n   */\n  constructor(element, zone) {\n    this.element = element;\n    this.zone = zone;\n    this.scrolled = new EventEmitter();\n    this.scrolledUp = new EventEmitter();\n    this.infiniteScrollDistance = 2;\n    this.infiniteScrollUpDistance = 1.5;\n    this.infiniteScrollThrottle = 150;\n    this.infiniteScrollDisabled = false;\n    this.infiniteScrollContainer = null;\n    this.scrollWindow = true;\n    this.immediateCheck = false;\n    this.horizontal = false;\n    this.alwaysCallback = false;\n    this.fromRoot = false;\n  }\n  /**\n   * @return {?}\n   */\n  ngAfterViewInit() {\n    if (!this.infiniteScrollDisabled) {\n      this.setup();\n    }\n  }\n  /**\n   * @param {?} __0\n   * @return {?}\n   */\n  ngOnChanges({\n    infiniteScrollContainer,\n    infiniteScrollDisabled,\n    infiniteScrollDistance\n  }) {\n    /** @type {?} */\n    const containerChanged = inputPropChanged(infiniteScrollContainer);\n    /** @type {?} */\n    const disabledChanged = inputPropChanged(infiniteScrollDisabled);\n    /** @type {?} */\n    const distanceChanged = inputPropChanged(infiniteScrollDistance);\n    /** @type {?} */\n    const shouldSetup = !disabledChanged && !this.infiniteScrollDisabled || disabledChanged && !infiniteScrollDisabled.currentValue || distanceChanged;\n    if (containerChanged || disabledChanged || distanceChanged) {\n      this.destroyScroller();\n      if (shouldSetup) {\n        this.setup();\n      }\n    }\n  }\n  /**\n   * @return {?}\n   */\n  setup() {\n    if (hasWindowDefined()) {\n      this.zone.runOutsideAngular(\n      /**\n      * @return {?}\n      */\n      () => {\n        this.disposeScroller = createScroller({\n          fromRoot: this.fromRoot,\n          alwaysCallback: this.alwaysCallback,\n          disable: this.infiniteScrollDisabled,\n          downDistance: this.infiniteScrollDistance,\n          element: this.element,\n          horizontal: this.horizontal,\n          scrollContainer: this.infiniteScrollContainer,\n          scrollWindow: this.scrollWindow,\n          throttle: this.infiniteScrollThrottle,\n          upDistance: this.infiniteScrollUpDistance\n        }).subscribe(\n        /**\n        * @param {?} payload\n        * @return {?}\n        */\n        payload => this.zone.run(\n        /**\n        * @return {?}\n        */\n        () => this.handleOnScroll(payload)));\n      });\n    }\n  }\n  /**\n   * @param {?} __0\n   * @return {?}\n   */\n  handleOnScroll({\n    type,\n    payload\n  }) {\n    switch (type) {\n      case InfiniteScrollActions.DOWN:\n        return this.scrolled.emit(payload);\n      case InfiniteScrollActions.UP:\n        return this.scrolledUp.emit(payload);\n      default:\n        return;\n    }\n  }\n  /**\n   * @return {?}\n   */\n  ngOnDestroy() {\n    this.destroyScroller();\n  }\n  /**\n   * @return {?}\n   */\n  destroyScroller() {\n    if (this.disposeScroller) {\n      this.disposeScroller.unsubscribe();\n    }\n  }\n}\nInfiniteScrollDirective.ɵfac = function InfiniteScrollDirective_Factory(t) {\n  return new (t || InfiniteScrollDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n};\nInfiniteScrollDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n  type: InfiniteScrollDirective,\n  selectors: [[\"\", \"infiniteScroll\", \"\"], [\"\", \"infinite-scroll\", \"\"], [\"\", \"data-infinite-scroll\", \"\"]],\n  inputs: {\n    infiniteScrollDistance: \"infiniteScrollDistance\",\n    infiniteScrollUpDistance: \"infiniteScrollUpDistance\",\n    infiniteScrollThrottle: \"infiniteScrollThrottle\",\n    infiniteScrollDisabled: \"infiniteScrollDisabled\",\n    infiniteScrollContainer: \"infiniteScrollContainer\",\n    scrollWindow: \"scrollWindow\",\n    immediateCheck: \"immediateCheck\",\n    horizontal: \"horizontal\",\n    alwaysCallback: \"alwaysCallback\",\n    fromRoot: \"fromRoot\"\n  },\n  outputs: {\n    scrolled: \"scrolled\",\n    scrolledUp: \"scrolledUp\"\n  },\n  features: [ɵngcc0.ɵɵNgOnChangesFeature]\n});\n/** @nocollapse */\nInfiniteScrollDirective.ctorParameters = () => [{\n  type: ElementRef\n}, {\n  type: NgZone\n}];\nInfiniteScrollDirective.propDecorators = {\n  scrolled: [{\n    type: Output\n  }],\n  scrolledUp: [{\n    type: Output\n  }],\n  infiniteScrollDistance: [{\n    type: Input\n  }],\n  infiniteScrollUpDistance: [{\n    type: Input\n  }],\n  infiniteScrollThrottle: [{\n    type: Input\n  }],\n  infiniteScrollDisabled: [{\n    type: Input\n  }],\n  infiniteScrollContainer: [{\n    type: Input\n  }],\n  scrollWindow: [{\n    type: Input\n  }],\n  immediateCheck: [{\n    type: Input\n  }],\n  horizontal: [{\n    type: Input\n  }],\n  alwaysCallback: [{\n    type: Input\n  }],\n  fromRoot: [{\n    type: Input\n  }]\n};\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(InfiniteScrollDirective, [{\n    type: Directive,\n    args: [{\n      selector: '[infiniteScroll], [infinite-scroll], [data-infinite-scroll]'\n    }]\n  }], function () {\n    return [{\n      type: ɵngcc0.ElementRef\n    }, {\n      type: ɵngcc0.NgZone\n    }];\n  }, {\n    scrolled: [{\n      type: Output\n    }],\n    scrolledUp: [{\n      type: Output\n    }],\n    infiniteScrollDistance: [{\n      type: Input\n    }],\n    infiniteScrollUpDistance: [{\n      type: Input\n    }],\n    infiniteScrollThrottle: [{\n      type: Input\n    }],\n    infiniteScrollDisabled: [{\n      type: Input\n    }],\n    infiniteScrollContainer: [{\n      type: Input\n    }],\n    scrollWindow: [{\n      type: Input\n    }],\n    immediateCheck: [{\n      type: Input\n    }],\n    horizontal: [{\n      type: Input\n    }],\n    alwaysCallback: [{\n      type: Input\n    }],\n    fromRoot: [{\n      type: Input\n    }]\n  });\n})();\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/modules/ngx-infinite-scroll.module.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass InfiniteScrollModule {}\nInfiniteScrollModule.ɵfac = function InfiniteScrollModule_Factory(t) {\n  return new (t || InfiniteScrollModule)();\n};\nInfiniteScrollModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n  type: InfiniteScrollModule\n});\nInfiniteScrollModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(InfiniteScrollModule, [{\n    type: NgModule,\n    args: [{\n      declarations: [InfiniteScrollDirective],\n      exports: [InfiniteScrollDirective],\n      imports: [],\n      providers: []\n    }]\n  }], null, null);\n})();\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(InfiniteScrollModule, {\n    declarations: [InfiniteScrollDirective],\n    exports: [InfiniteScrollDirective]\n  });\n})();\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/ngx-infinite-scroll.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * Generated from: public-api.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Angular library starter.\n * Build an Angular library compatible with AoT compilation & Tree shaking.\n * Written by Roberto Simonetti.\n * MIT license.\n * https://github.com/robisim74/angular-library-starter\n */\n/**\n * Entry point for all public APIs of the package.\n */\n\n/**\n * @fileoverview added by tsickle\n * Generated from: ngx-infinite-scroll.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { InfiniteScrollDirective, InfiniteScrollModule };","map":{"version":3,"names":["Directive","ElementRef","EventEmitter","Input","NgModule","NgZone","Output","fromEvent","of","filter","map","mergeMap","tap","throttleTime","ɵngcc0","resolveContainerElement","selector","scrollWindow","defaultElement","fromRoot","hasWindow","window","document","documentElement","container","containerIsString","findElement","nativeElement","Error","customRoot","rootEl","querySelector","inputPropChanged","prop","firstChange","hasWindowDefined","VerticalProps","clientHeight","offsetHeight","scrollHeight","pageYOffset","offsetTop","scrollTop","top","HorizontalProps","AxisResolver","constructor","vertical","propsMap","clientHeightKey","offsetHeightKey","scrollHeightKey","pageYOffsetKey","offsetTopKey","scrollTopKey","topKey","shouldTriggerEvents","alwaysCallback","shouldFireScrollEvent","isTriggeredCurrentTotal","createResolver","windowElement","axis","createResolverWithContainer","isWindow","isElementWindow","resolver","Object","assign","some","obj","prototype","toString","call","includes","getDocumentElement","isContainerWindow","calculatePoints","element","height","extractHeightForElement","calculatePointsForWindow","calculatePointsForElement","extractHeightPropKeys","scrolled","getElementPageYOffset","nativeElementHeight","getElementHeight","totalToScroll","getElementOffsetTop","elem","isNaN","docElem","getBoundingClientRect","ownerDocument","defaultView","distance","scrollingDown","remaining","containerBreakpoint","scrolledUntilNow","down","totalHiddenContentHeight","up","shouldFireEvent","isScrollingDownwards","lastScrollPosition","getScrollStats","scrollDown","fire","ScrollState","lastTotalToScroll","triggered","updateScrollPosition","position","updateTotalToScroll","updateScroll","updateTriggeredFlag","scroll","isScrollingDown","isTriggeredScroll","createScroller","config","scrollContainer","horizontal","scrollState","options","throttle","upDistance","downDistance","attachScrollEvent","pipe","positionStats","toInfiniteScrollParams","stats","toInfiniteScrollAction","obs","InfiniteScrollActions","DOWN","UP","response","currentScrollPosition","type","payload","InfiniteScrollDirective","zone","scrolledUp","infiniteScrollDistance","infiniteScrollUpDistance","infiniteScrollThrottle","infiniteScrollDisabled","infiniteScrollContainer","immediateCheck","ngAfterViewInit","setup","ngOnChanges","containerChanged","disabledChanged","distanceChanged","shouldSetup","currentValue","destroyScroller","runOutsideAngular","disposeScroller","disable","subscribe","run","handleOnScroll","emit","ngOnDestroy","unsubscribe","ɵfac","InfiniteScrollDirective_Factory","t","ɵɵdirectiveInject","ɵdir","ɵɵdefineDirective","selectors","inputs","outputs","features","ɵɵNgOnChangesFeature","ctorParameters","propDecorators","ngDevMode","ɵsetClassMetadata","args","InfiniteScrollModule","InfiniteScrollModule_Factory","ɵmod","ɵɵdefineNgModule","ɵinj","ɵɵdefineInjector","declarations","exports","imports","providers","ngJitMode","ɵɵsetNgModuleScope"],"sources":["/home/ceo/mmmm/createyourevent/node_modules/ngx-infinite-scroll/__ivy_ngcc__/modules/ngx-infinite-scroll.js"],"sourcesContent":["import { Directive, ElementRef, EventEmitter, Input, NgModule, NgZone, Output } from '@angular/core';\nimport { fromEvent, of } from 'rxjs';\nimport { filter, map, mergeMap, tap, throttleTime } from 'rxjs/operators';\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/services/ngx-ins-utils.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} selector\n * @param {?} scrollWindow\n * @param {?} defaultElement\n * @param {?} fromRoot\n * @return {?}\n */\nimport * as ɵngcc0 from '@angular/core';\nfunction resolveContainerElement(selector, scrollWindow, defaultElement, fromRoot) {\n    /** @type {?} */\n    const hasWindow = window && !!window.document && window.document.documentElement;\n    /** @type {?} */\n    let container = hasWindow && scrollWindow ? window : defaultElement;\n    if (selector) {\n        /** @type {?} */\n        const containerIsString = selector && hasWindow && typeof selector === 'string';\n        container = containerIsString\n            ? findElement(selector, defaultElement.nativeElement, fromRoot)\n            : selector;\n        if (!container) {\n            throw new Error('ngx-infinite-scroll {resolveContainerElement()}: selector for');\n        }\n    }\n    return container;\n}\n/**\n * @param {?} selector\n * @param {?} customRoot\n * @param {?} fromRoot\n * @return {?}\n */\nfunction findElement(selector, customRoot, fromRoot) {\n    /** @type {?} */\n    const rootEl = fromRoot ? window.document : customRoot;\n    return rootEl.querySelector(selector);\n}\n/**\n * @param {?} prop\n * @return {?}\n */\nfunction inputPropChanged(prop) {\n    return prop && !prop.firstChange;\n}\n/**\n * @return {?}\n */\nfunction hasWindowDefined() {\n    return typeof window !== 'undefined';\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/services/axis-resolver.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @type {?} */\nconst VerticalProps = {\n    clientHeight: \"clientHeight\",\n    offsetHeight: \"offsetHeight\",\n    scrollHeight: \"scrollHeight\",\n    pageYOffset: \"pageYOffset\",\n    offsetTop: \"offsetTop\",\n    scrollTop: \"scrollTop\",\n    top: \"top\"\n};\n/** @type {?} */\nconst HorizontalProps = {\n    clientHeight: \"clientWidth\",\n    offsetHeight: \"offsetWidth\",\n    scrollHeight: \"scrollWidth\",\n    pageYOffset: \"pageXOffset\",\n    offsetTop: \"offsetLeft\",\n    scrollTop: \"scrollLeft\",\n    top: \"left\"\n};\nclass AxisResolver {\n    /**\n     * @param {?=} vertical\n     */\n    constructor(vertical = true) {\n        this.vertical = vertical;\n        this.propsMap = vertical ? VerticalProps : HorizontalProps;\n    }\n    /**\n     * @return {?}\n     */\n    clientHeightKey() {\n        return this.propsMap.clientHeight;\n    }\n    /**\n     * @return {?}\n     */\n    offsetHeightKey() {\n        return this.propsMap.offsetHeight;\n    }\n    /**\n     * @return {?}\n     */\n    scrollHeightKey() {\n        return this.propsMap.scrollHeight;\n    }\n    /**\n     * @return {?}\n     */\n    pageYOffsetKey() {\n        return this.propsMap.pageYOffset;\n    }\n    /**\n     * @return {?}\n     */\n    offsetTopKey() {\n        return this.propsMap.offsetTop;\n    }\n    /**\n     * @return {?}\n     */\n    scrollTopKey() {\n        return this.propsMap.scrollTop;\n    }\n    /**\n     * @return {?}\n     */\n    topKey() {\n        return this.propsMap.top;\n    }\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/services/event-trigger.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @record\n */\n\n/**\n * @record\n */\n\n/**\n * @record\n */\n\n/**\n * @record\n */\n\n/**\n * @param {?} alwaysCallback\n * @param {?} shouldFireScrollEvent\n * @param {?} isTriggeredCurrentTotal\n * @return {?}\n */\nfunction shouldTriggerEvents(alwaysCallback, shouldFireScrollEvent, isTriggeredCurrentTotal) {\n    if (alwaysCallback && shouldFireScrollEvent) {\n        return true;\n    }\n    if (!isTriggeredCurrentTotal && shouldFireScrollEvent) {\n        return true;\n    }\n    return false;\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/services/position-resolver.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} __0\n * @return {?}\n */\nfunction createResolver({ windowElement, axis }) {\n    return createResolverWithContainer({ axis, isWindow: isElementWindow(windowElement) }, windowElement);\n}\n/**\n * @param {?} resolver\n * @param {?} windowElement\n * @return {?}\n */\nfunction createResolverWithContainer(resolver, windowElement) {\n    /** @type {?} */\n    const container = resolver.isWindow || (windowElement && !windowElement.nativeElement)\n        ? windowElement\n        : windowElement.nativeElement;\n    return Object.assign(Object.assign({}, resolver), { container });\n}\n/**\n * @param {?} windowElement\n * @return {?}\n */\nfunction isElementWindow(windowElement) {\n    /** @type {?} */\n    const isWindow = ['Window', 'global'].some((/**\n     * @param {?} obj\n     * @return {?}\n     */\n    (obj) => Object.prototype.toString.call(windowElement).includes(obj)));\n    return isWindow;\n}\n/**\n * @param {?} isContainerWindow\n * @param {?} windowElement\n * @return {?}\n */\nfunction getDocumentElement(isContainerWindow, windowElement) {\n    return isContainerWindow ? windowElement.document.documentElement : null;\n}\n/**\n * @param {?} element\n * @param {?} resolver\n * @return {?}\n */\nfunction calculatePoints(element, resolver) {\n    /** @type {?} */\n    const height = extractHeightForElement(resolver);\n    return resolver.isWindow\n        ? calculatePointsForWindow(height, element, resolver)\n        : calculatePointsForElement(height, element, resolver);\n}\n/**\n * @param {?} height\n * @param {?} element\n * @param {?} resolver\n * @return {?}\n */\nfunction calculatePointsForWindow(height, element, resolver) {\n    const { axis, container, isWindow } = resolver;\n    const { offsetHeightKey, clientHeightKey } = extractHeightPropKeys(axis);\n    // scrolled until now / current y point\n    /** @type {?} */\n    const scrolled = height +\n        getElementPageYOffset(getDocumentElement(isWindow, container), axis, isWindow);\n    // total height / most bottom y point\n    /** @type {?} */\n    const nativeElementHeight = getElementHeight(element.nativeElement, isWindow, offsetHeightKey, clientHeightKey);\n    /** @type {?} */\n    const totalToScroll = getElementOffsetTop(element.nativeElement, axis, isWindow) +\n        nativeElementHeight;\n    return { height, scrolled, totalToScroll, isWindow };\n}\n/**\n * @param {?} height\n * @param {?} element\n * @param {?} resolver\n * @return {?}\n */\nfunction calculatePointsForElement(height, element, resolver) {\n    const { axis, container } = resolver;\n    // perhaps use container.offsetTop instead of 'scrollTop'\n    /** @type {?} */\n    const scrolled = container[axis.scrollTopKey()];\n    /** @type {?} */\n    const totalToScroll = container[axis.scrollHeightKey()];\n    return { height, scrolled, totalToScroll, isWindow: false };\n}\n/**\n * @param {?} axis\n * @return {?}\n */\nfunction extractHeightPropKeys(axis) {\n    return {\n        offsetHeightKey: axis.offsetHeightKey(),\n        clientHeightKey: axis.clientHeightKey()\n    };\n}\n/**\n * @param {?} __0\n * @return {?}\n */\nfunction extractHeightForElement({ container, isWindow, axis }) {\n    const { offsetHeightKey, clientHeightKey } = extractHeightPropKeys(axis);\n    return getElementHeight(container, isWindow, offsetHeightKey, clientHeightKey);\n}\n/**\n * @param {?} elem\n * @param {?} isWindow\n * @param {?} offsetHeightKey\n * @param {?} clientHeightKey\n * @return {?}\n */\nfunction getElementHeight(elem, isWindow, offsetHeightKey, clientHeightKey) {\n    if (isNaN(elem[offsetHeightKey])) {\n        /** @type {?} */\n        const docElem = getDocumentElement(isWindow, elem);\n        return docElem ? docElem[clientHeightKey] : 0;\n    }\n    else {\n        return elem[offsetHeightKey];\n    }\n}\n/**\n * @param {?} elem\n * @param {?} axis\n * @param {?} isWindow\n * @return {?}\n */\nfunction getElementOffsetTop(elem, axis, isWindow) {\n    /** @type {?} */\n    const topKey = axis.topKey();\n    // elem = elem.nativeElement;\n    if (!elem.getBoundingClientRect) {\n        // || elem.css('none')) {\n        return;\n    }\n    return (elem.getBoundingClientRect()[topKey] +\n        getElementPageYOffset(elem, axis, isWindow));\n}\n/**\n * @param {?} elem\n * @param {?} axis\n * @param {?} isWindow\n * @return {?}\n */\nfunction getElementPageYOffset(elem, axis, isWindow) {\n    /** @type {?} */\n    const pageYOffset = axis.pageYOffsetKey();\n    /** @type {?} */\n    const scrollTop = axis.scrollTopKey();\n    /** @type {?} */\n    const offsetTop = axis.offsetTopKey();\n    if (isNaN(window.pageYOffset)) {\n        return getDocumentElement(isWindow, elem)[scrollTop];\n    }\n    else if (elem.ownerDocument) {\n        return elem.ownerDocument.defaultView[pageYOffset];\n    }\n    else {\n        return elem[offsetTop];\n    }\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/services/scroll-resolver.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} container\n * @param {?} distance\n * @param {?} scrollingDown\n * @return {?}\n */\nfunction shouldFireScrollEvent(container, distance, scrollingDown) {\n    /** @type {?} */\n    let remaining;\n    /** @type {?} */\n    let containerBreakpoint;\n    if (container.totalToScroll <= 0) {\n        return false;\n    }\n    /** @type {?} */\n    const scrolledUntilNow = container.isWindow ? container.scrolled : container.height + container.scrolled;\n    if (scrollingDown) {\n        remaining =\n            (container.totalToScroll - scrolledUntilNow) / container.totalToScroll;\n        containerBreakpoint = distance.down / 10;\n    }\n    else {\n        /** @type {?} */\n        const totalHiddenContentHeight = container.scrolled + (container.totalToScroll - scrolledUntilNow);\n        remaining = container.scrolled / totalHiddenContentHeight;\n        containerBreakpoint = distance.up / 10;\n    }\n    /** @type {?} */\n    const shouldFireEvent = remaining <= containerBreakpoint;\n    return shouldFireEvent;\n}\n/**\n * @param {?} lastScrollPosition\n * @param {?} container\n * @return {?}\n */\nfunction isScrollingDownwards(lastScrollPosition, container) {\n    return lastScrollPosition < container.scrolled;\n}\n/**\n * @param {?} lastScrollPosition\n * @param {?} container\n * @param {?} distance\n * @return {?}\n */\nfunction getScrollStats(lastScrollPosition, container, distance) {\n    /** @type {?} */\n    const scrollDown = isScrollingDownwards(lastScrollPosition, container);\n    return {\n        fire: shouldFireScrollEvent(container, distance, scrollDown),\n        scrollDown\n    };\n}\n/**\n * @param {?} position\n * @param {?} scrollState\n * @return {?}\n */\n\n/**\n * @param {?} totalToScroll\n * @param {?} scrollState\n * @return {?}\n */\n\n/**\n * @param {?} scrollState\n * @return {?}\n */\n\n/**\n * @param {?} scroll\n * @param {?} scrollState\n * @param {?} triggered\n * @param {?} isScrollingDown\n * @return {?}\n */\n\n/**\n * @param {?} totalToScroll\n * @param {?} scrollState\n * @param {?} isScrollingDown\n * @return {?}\n */\n\n/**\n * @param {?} scrollState\n * @param {?} scrolledUntilNow\n * @param {?} totalToScroll\n * @return {?}\n */\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/services/scroll-state.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass ScrollState {\n    /**\n     * @param {?} __0\n     */\n    constructor({ totalToScroll }) {\n        this.lastScrollPosition = 0;\n        this.lastTotalToScroll = 0;\n        this.totalToScroll = 0;\n        this.triggered = {\n            down: 0,\n            up: 0\n        };\n        this.totalToScroll = totalToScroll;\n    }\n    /**\n     * @param {?} position\n     * @return {?}\n     */\n    updateScrollPosition(position) {\n        return (this.lastScrollPosition = position);\n    }\n    /**\n     * @param {?} totalToScroll\n     * @return {?}\n     */\n    updateTotalToScroll(totalToScroll) {\n        if (this.lastTotalToScroll !== totalToScroll) {\n            this.lastTotalToScroll = this.totalToScroll;\n            this.totalToScroll = totalToScroll;\n        }\n    }\n    /**\n     * @param {?} scrolledUntilNow\n     * @param {?} totalToScroll\n     * @return {?}\n     */\n    updateScroll(scrolledUntilNow, totalToScroll) {\n        this.updateScrollPosition(scrolledUntilNow);\n        this.updateTotalToScroll(totalToScroll);\n    }\n    /**\n     * @param {?} scroll\n     * @param {?} isScrollingDown\n     * @return {?}\n     */\n    updateTriggeredFlag(scroll, isScrollingDown) {\n        if (isScrollingDown) {\n            this.triggered.down = scroll;\n        }\n        else {\n            this.triggered.up = scroll;\n        }\n    }\n    /**\n     * @param {?} totalToScroll\n     * @param {?} isScrollingDown\n     * @return {?}\n     */\n    isTriggeredScroll(totalToScroll, isScrollingDown) {\n        return isScrollingDown\n            ? this.triggered.down === totalToScroll\n            : this.triggered.up === totalToScroll;\n    }\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/services/scroll-register.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} config\n * @return {?}\n */\nfunction createScroller(config) {\n    const { scrollContainer, scrollWindow, element, fromRoot } = config;\n    /** @type {?} */\n    const resolver = createResolver({\n        axis: new AxisResolver(!config.horizontal),\n        windowElement: resolveContainerElement(scrollContainer, scrollWindow, element, fromRoot)\n    });\n    /** @type {?} */\n    const scrollState = new ScrollState({\n        totalToScroll: calculatePoints(element, resolver)\n    });\n    /** @type {?} */\n    const options = {\n        container: resolver.container,\n        throttle: config.throttle\n    };\n    /** @type {?} */\n    const distance = {\n        up: config.upDistance,\n        down: config.downDistance\n    };\n    return attachScrollEvent(options).pipe(mergeMap((/**\n     * @return {?}\n     */\n    () => of(calculatePoints(element, resolver)))), map((/**\n     * @param {?} positionStats\n     * @return {?}\n     */\n    (positionStats) => toInfiniteScrollParams(scrollState.lastScrollPosition, positionStats, distance))), tap((/**\n     * @param {?} __0\n     * @return {?}\n     */\n    ({ stats }) => scrollState.updateScroll(stats.scrolled, stats.totalToScroll))), filter((/**\n     * @param {?} __0\n     * @return {?}\n     */\n    ({ fire, scrollDown, stats: { totalToScroll } }) => shouldTriggerEvents(config.alwaysCallback, fire, scrollState.isTriggeredScroll(totalToScroll, scrollDown)))), tap((/**\n     * @param {?} __0\n     * @return {?}\n     */\n    ({ scrollDown, stats: { totalToScroll } }) => {\n        scrollState.updateTriggeredFlag(totalToScroll, scrollDown);\n    })), map(toInfiniteScrollAction));\n}\n/**\n * @param {?} options\n * @return {?}\n */\nfunction attachScrollEvent(options) {\n    /** @type {?} */\n    let obs = fromEvent(options.container, 'scroll');\n    // For an unknown reason calling `sampleTime()` causes trouble for many users, even with `options.throttle = 0`.\n    // Let's avoid calling the function unless needed.\n    // Replacing with throttleTime seems to solve the problem\n    // See https://github.com/orizens/ngx-infinite-scroll/issues/198\n    if (options.throttle) {\n        obs = obs.pipe(throttleTime(options.throttle));\n    }\n    return obs;\n}\n/**\n * @param {?} lastScrollPosition\n * @param {?} stats\n * @param {?} distance\n * @return {?}\n */\nfunction toInfiniteScrollParams(lastScrollPosition, stats, distance) {\n    const { scrollDown, fire } = getScrollStats(lastScrollPosition, stats, distance);\n    return {\n        scrollDown,\n        fire,\n        stats\n    };\n}\n/** @type {?} */\nconst InfiniteScrollActions = {\n    DOWN: '[NGX_ISE] DOWN',\n    UP: '[NGX_ISE] UP'\n};\n/**\n * @param {?} response\n * @return {?}\n */\nfunction toInfiniteScrollAction(response) {\n    const { scrollDown, stats: { scrolled: currentScrollPosition } } = response;\n    return {\n        type: scrollDown ? InfiniteScrollActions.DOWN : InfiniteScrollActions.UP,\n        payload: {\n            currentScrollPosition\n        }\n    };\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/modules/infinite-scroll.directive.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass InfiniteScrollDirective {\n    /**\n     * @param {?} element\n     * @param {?} zone\n     */\n    constructor(element, zone) {\n        this.element = element;\n        this.zone = zone;\n        this.scrolled = new EventEmitter();\n        this.scrolledUp = new EventEmitter();\n        this.infiniteScrollDistance = 2;\n        this.infiniteScrollUpDistance = 1.5;\n        this.infiniteScrollThrottle = 150;\n        this.infiniteScrollDisabled = false;\n        this.infiniteScrollContainer = null;\n        this.scrollWindow = true;\n        this.immediateCheck = false;\n        this.horizontal = false;\n        this.alwaysCallback = false;\n        this.fromRoot = false;\n    }\n    /**\n     * @return {?}\n     */\n    ngAfterViewInit() {\n        if (!this.infiniteScrollDisabled) {\n            this.setup();\n        }\n    }\n    /**\n     * @param {?} __0\n     * @return {?}\n     */\n    ngOnChanges({ infiniteScrollContainer, infiniteScrollDisabled, infiniteScrollDistance }) {\n        /** @type {?} */\n        const containerChanged = inputPropChanged(infiniteScrollContainer);\n        /** @type {?} */\n        const disabledChanged = inputPropChanged(infiniteScrollDisabled);\n        /** @type {?} */\n        const distanceChanged = inputPropChanged(infiniteScrollDistance);\n        /** @type {?} */\n        const shouldSetup = (!disabledChanged && !this.infiniteScrollDisabled) ||\n            (disabledChanged && !infiniteScrollDisabled.currentValue) || distanceChanged;\n        if (containerChanged || disabledChanged || distanceChanged) {\n            this.destroyScroller();\n            if (shouldSetup) {\n                this.setup();\n            }\n        }\n    }\n    /**\n     * @return {?}\n     */\n    setup() {\n        if (hasWindowDefined()) {\n            this.zone.runOutsideAngular((/**\n             * @return {?}\n             */\n            () => {\n                this.disposeScroller = createScroller({\n                    fromRoot: this.fromRoot,\n                    alwaysCallback: this.alwaysCallback,\n                    disable: this.infiniteScrollDisabled,\n                    downDistance: this.infiniteScrollDistance,\n                    element: this.element,\n                    horizontal: this.horizontal,\n                    scrollContainer: this.infiniteScrollContainer,\n                    scrollWindow: this.scrollWindow,\n                    throttle: this.infiniteScrollThrottle,\n                    upDistance: this.infiniteScrollUpDistance\n                }).subscribe((/**\n                 * @param {?} payload\n                 * @return {?}\n                 */\n                (payload) => this.zone.run((/**\n                 * @return {?}\n                 */\n                () => this.handleOnScroll(payload)))));\n            }));\n        }\n    }\n    /**\n     * @param {?} __0\n     * @return {?}\n     */\n    handleOnScroll({ type, payload }) {\n        switch (type) {\n            case InfiniteScrollActions.DOWN:\n                return this.scrolled.emit(payload);\n            case InfiniteScrollActions.UP:\n                return this.scrolledUp.emit(payload);\n            default:\n                return;\n        }\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        this.destroyScroller();\n    }\n    /**\n     * @return {?}\n     */\n    destroyScroller() {\n        if (this.disposeScroller) {\n            this.disposeScroller.unsubscribe();\n        }\n    }\n}\nInfiniteScrollDirective.ɵfac = function InfiniteScrollDirective_Factory(t) { return new (t || InfiniteScrollDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };\nInfiniteScrollDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: InfiniteScrollDirective, selectors: [[\"\", \"infiniteScroll\", \"\"], [\"\", \"infinite-scroll\", \"\"], [\"\", \"data-infinite-scroll\", \"\"]], inputs: { infiniteScrollDistance: \"infiniteScrollDistance\", infiniteScrollUpDistance: \"infiniteScrollUpDistance\", infiniteScrollThrottle: \"infiniteScrollThrottle\", infiniteScrollDisabled: \"infiniteScrollDisabled\", infiniteScrollContainer: \"infiniteScrollContainer\", scrollWindow: \"scrollWindow\", immediateCheck: \"immediateCheck\", horizontal: \"horizontal\", alwaysCallback: \"alwaysCallback\", fromRoot: \"fromRoot\" }, outputs: { scrolled: \"scrolled\", scrolledUp: \"scrolledUp\" }, features: [ɵngcc0.ɵɵNgOnChangesFeature] });\n/** @nocollapse */\nInfiniteScrollDirective.ctorParameters = () => [\n    { type: ElementRef },\n    { type: NgZone }\n];\nInfiniteScrollDirective.propDecorators = {\n    scrolled: [{ type: Output }],\n    scrolledUp: [{ type: Output }],\n    infiniteScrollDistance: [{ type: Input }],\n    infiniteScrollUpDistance: [{ type: Input }],\n    infiniteScrollThrottle: [{ type: Input }],\n    infiniteScrollDisabled: [{ type: Input }],\n    infiniteScrollContainer: [{ type: Input }],\n    scrollWindow: [{ type: Input }],\n    immediateCheck: [{ type: Input }],\n    horizontal: [{ type: Input }],\n    alwaysCallback: [{ type: Input }],\n    fromRoot: [{ type: Input }]\n};\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(InfiniteScrollDirective, [{\n        type: Directive,\n        args: [{\n                selector: '[infiniteScroll], [infinite-scroll], [data-infinite-scroll]'\n            }]\n    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, { scrolled: [{\n            type: Output\n        }], scrolledUp: [{\n            type: Output\n        }], infiniteScrollDistance: [{\n            type: Input\n        }], infiniteScrollUpDistance: [{\n            type: Input\n        }], infiniteScrollThrottle: [{\n            type: Input\n        }], infiniteScrollDisabled: [{\n            type: Input\n        }], infiniteScrollContainer: [{\n            type: Input\n        }], scrollWindow: [{\n            type: Input\n        }], immediateCheck: [{\n            type: Input\n        }], horizontal: [{\n            type: Input\n        }], alwaysCallback: [{\n            type: Input\n        }], fromRoot: [{\n            type: Input\n        }] }); })();\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/modules/ngx-infinite-scroll.module.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass InfiniteScrollModule {\n}\nInfiniteScrollModule.ɵfac = function InfiniteScrollModule_Factory(t) { return new (t || InfiniteScrollModule)(); };\nInfiniteScrollModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: InfiniteScrollModule });\nInfiniteScrollModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({});\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(InfiniteScrollModule, [{\n        type: NgModule,\n        args: [{\n                declarations: [InfiniteScrollDirective],\n                exports: [InfiniteScrollDirective],\n                imports: [],\n                providers: []\n            }]\n    }], null, null); })();\n(function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(InfiniteScrollModule, { declarations: [InfiniteScrollDirective], exports: [InfiniteScrollDirective] }); })();\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/ngx-infinite-scroll.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * Generated from: public-api.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Angular library starter.\n * Build an Angular library compatible with AoT compilation & Tree shaking.\n * Written by Roberto Simonetti.\n * MIT license.\n * https://github.com/robisim74/angular-library-starter\n */\n/**\n * Entry point for all public APIs of the package.\n */\n\n/**\n * @fileoverview added by tsickle\n * Generated from: ngx-infinite-scroll.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { InfiniteScrollDirective, InfiniteScrollModule };\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}