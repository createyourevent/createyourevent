{"ast":null,"code":"import { EventEmitter, Injectable, NgZone, NgModule } from '@angular/core';\nimport { HttpRequest, HttpClient } from '@angular/common/http';\nimport { KeepaliveSvc, NgIdleModule } from '@ng-idle/core';\n\n/**\n * An example of an injectable service.\n */\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@angular/common/http';\nimport * as ɵngcc2 from '@ng-idle/core';\nclass Keepalive extends KeepaliveSvc {\n  /*\n   * Initializes a new instance of Keepalive\n   * @param http - The HTTP service.\n   */\n  constructor(http, zone) {\n    super();\n    this.http = http;\n    this.zone = zone;\n    this.pingInterval = 10 * 60;\n    /*\n     * An event emitted when the service is pinging.\n     */\n    this.onPing = new EventEmitter();\n    /*\n     * An event emitted when the service has pinged an HTTP endpoint and received a response.\n     */\n    this.onPingResponse = new EventEmitter();\n  }\n  /*\n   * Sets the string or Request that should be used when pinging.\n   * @param url - The URL or Request object to use when pinging.\n   * @return The current Request used when pinging.\n   */\n  request(url) {\n    if (typeof url === 'string') {\n      this.pingRequest = new HttpRequest('GET', url);\n    } else if (url instanceof HttpRequest) {\n      this.pingRequest = url;\n    } else if (url === null) {\n      this.pingRequest = null;\n    }\n    return this.pingRequest;\n  }\n  /*\n   * Sets the interval (in seconds) at which the ping operation will occur when start() is called.\n   * @param seconds - The ping interval in seconds.\n   * @return The current interval value.\n   */\n  interval(seconds) {\n    if (!isNaN(seconds) && seconds > 0) {\n      this.pingInterval = seconds;\n    } else if (!isNaN(seconds) && seconds <= 0) {\n      throw new Error('Interval value must be greater than zero.');\n    }\n    return this.pingInterval;\n  }\n  /*\n   * Immediately performs the ping operation. If a request has been set, an HTTP\n   * request will be made and the response will be emitted via the\n   * onPingResponse event.\n   */\n  ping() {\n    this.onPing.emit(null);\n    if (this.pingRequest) {\n      this.http.request(this.pingRequest).subscribe(response => {\n        this.onPingResponse.emit(response);\n      }, error => {\n        this.onPingResponse.emit(error);\n      });\n    }\n  }\n  /*\n   * Starts pinging on an interval.\n   */\n  start() {\n    this.stop();\n    this.zone.runOutsideAngular(() => {\n      this.pingHandle = setInterval(() => {\n        this.zone.run(() => {\n          this.ping();\n        });\n      }, this.pingInterval * 1000);\n    });\n  }\n  /*\n   * Stops pinging on an interval.\n   */\n  stop() {\n    if (this.hasPingHandle()) {\n      clearInterval(this.pingHandle);\n      this.pingHandle = null;\n    }\n  }\n  /*\n   * Performs any cleanup tasks when Angular destroys the instance.\n   */\n  ngOnDestroy() {\n    this.stop();\n  }\n  /*\n   * Returns whether or not the service will ping automatically at the specified interval.\n   * @return True if the service will ping at the specified interval; otherwise, false.\n   */\n  isRunning() {\n    return this.hasPingHandle();\n  }\n  hasPingHandle() {\n    return this.pingHandle !== null && typeof this.pingHandle !== 'undefined';\n  }\n}\nKeepalive.ɵfac = function Keepalive_Factory(t) {\n  return new (t || Keepalive)(ɵngcc0.ɵɵinject(ɵngcc1.HttpClient), ɵngcc0.ɵɵinject(ɵngcc0.NgZone));\n};\nKeepalive.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n  token: Keepalive,\n  factory: Keepalive.ɵfac\n});\nKeepalive.ctorParameters = () => [{\n  type: HttpClient\n}, {\n  type: NgZone\n}];\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(Keepalive, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: ɵngcc1.HttpClient\n    }, {\n      type: ɵngcc0.NgZone\n    }];\n  }, null);\n})();\nclass NgIdleKeepaliveModule {\n  static forRoot() {\n    return {\n      ngModule: NgIdleKeepaliveModule,\n      providers: [Keepalive, {\n        provide: KeepaliveSvc,\n        useExisting: Keepalive\n      }]\n    };\n  }\n}\nNgIdleKeepaliveModule.ɵfac = function NgIdleKeepaliveModule_Factory(t) {\n  return new (t || NgIdleKeepaliveModule)();\n};\nNgIdleKeepaliveModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n  type: NgIdleKeepaliveModule\n});\nNgIdleKeepaliveModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n  imports: [NgIdleModule.forRoot()]\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NgIdleKeepaliveModule, [{\n    type: NgModule,\n    args: [{\n      imports: [NgIdleModule.forRoot()]\n    }]\n  }], null, null);\n})();\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NgIdleKeepaliveModule, {\n    imports: [ɵngcc2.NgIdleModule]\n  });\n})();\n\n/*\n * Public API Surface of keepalive\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { Keepalive, NgIdleKeepaliveModule };","map":{"version":3,"names":["EventEmitter","Injectable","NgZone","NgModule","HttpRequest","HttpClient","KeepaliveSvc","NgIdleModule","ɵngcc0","ɵngcc1","ɵngcc2","Keepalive","constructor","http","zone","pingInterval","onPing","onPingResponse","request","url","pingRequest","interval","seconds","isNaN","Error","ping","emit","subscribe","response","error","start","stop","runOutsideAngular","pingHandle","setInterval","run","hasPingHandle","clearInterval","ngOnDestroy","isRunning","ɵfac","Keepalive_Factory","t","ɵɵinject","ɵprov","ɵɵdefineInjectable","token","factory","ctorParameters","type","ngDevMode","ɵsetClassMetadata","NgIdleKeepaliveModule","forRoot","ngModule","providers","provide","useExisting","NgIdleKeepaliveModule_Factory","ɵmod","ɵɵdefineNgModule","ɵinj","ɵɵdefineInjector","imports","args","ngJitMode","ɵɵsetNgModuleScope"],"sources":["/home/ceo/mmmm/createyourevent/node_modules/@ng-idle/keepalive/__ivy_ngcc__/fesm2015/ng-idle-keepalive.js"],"sourcesContent":["import { EventEmitter, Injectable, NgZone, NgModule } from '@angular/core';\nimport { HttpRequest, HttpClient } from '@angular/common/http';\nimport { KeepaliveSvc, NgIdleModule } from '@ng-idle/core';\n\n/**\n * An example of an injectable service.\n */\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@angular/common/http';\nimport * as ɵngcc2 from '@ng-idle/core';\nclass Keepalive extends KeepaliveSvc {\n    /*\n     * Initializes a new instance of Keepalive\n     * @param http - The HTTP service.\n     */\n    constructor(http, zone) {\n        super();\n        this.http = http;\n        this.zone = zone;\n        this.pingInterval = 10 * 60;\n        /*\n         * An event emitted when the service is pinging.\n         */\n        this.onPing = new EventEmitter();\n        /*\n         * An event emitted when the service has pinged an HTTP endpoint and received a response.\n         */\n        this.onPingResponse = new EventEmitter();\n    }\n    /*\n     * Sets the string or Request that should be used when pinging.\n     * @param url - The URL or Request object to use when pinging.\n     * @return The current Request used when pinging.\n     */\n    request(url) {\n        if (typeof url === 'string') {\n            this.pingRequest = new HttpRequest('GET', url);\n        }\n        else if (url instanceof HttpRequest) {\n            this.pingRequest = url;\n        }\n        else if (url === null) {\n            this.pingRequest = null;\n        }\n        return this.pingRequest;\n    }\n    /*\n     * Sets the interval (in seconds) at which the ping operation will occur when start() is called.\n     * @param seconds - The ping interval in seconds.\n     * @return The current interval value.\n     */\n    interval(seconds) {\n        if (!isNaN(seconds) && seconds > 0) {\n            this.pingInterval = seconds;\n        }\n        else if (!isNaN(seconds) && seconds <= 0) {\n            throw new Error('Interval value must be greater than zero.');\n        }\n        return this.pingInterval;\n    }\n    /*\n     * Immediately performs the ping operation. If a request has been set, an HTTP\n     * request will be made and the response will be emitted via the\n     * onPingResponse event.\n     */\n    ping() {\n        this.onPing.emit(null);\n        if (this.pingRequest) {\n            this.http.request(this.pingRequest).subscribe((response) => {\n                this.onPingResponse.emit(response);\n            }, (error) => {\n                this.onPingResponse.emit(error);\n            });\n        }\n    }\n    /*\n     * Starts pinging on an interval.\n     */\n    start() {\n        this.stop();\n        this.zone.runOutsideAngular(() => {\n            this.pingHandle = setInterval(() => {\n                this.zone.run(() => {\n                    this.ping();\n                });\n            }, this.pingInterval * 1000);\n        });\n    }\n    /*\n     * Stops pinging on an interval.\n     */\n    stop() {\n        if (this.hasPingHandle()) {\n            clearInterval(this.pingHandle);\n            this.pingHandle = null;\n        }\n    }\n    /*\n     * Performs any cleanup tasks when Angular destroys the instance.\n     */\n    ngOnDestroy() {\n        this.stop();\n    }\n    /*\n     * Returns whether or not the service will ping automatically at the specified interval.\n     * @return True if the service will ping at the specified interval; otherwise, false.\n     */\n    isRunning() {\n        return this.hasPingHandle();\n    }\n    hasPingHandle() {\n        return this.pingHandle !== null && typeof this.pingHandle !== 'undefined';\n    }\n}\nKeepalive.ɵfac = function Keepalive_Factory(t) { return new (t || Keepalive)(ɵngcc0.ɵɵinject(ɵngcc1.HttpClient), ɵngcc0.ɵɵinject(ɵngcc0.NgZone)); };\nKeepalive.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: Keepalive, factory: Keepalive.ɵfac });\nKeepalive.ctorParameters = () => [\n    { type: HttpClient },\n    { type: NgZone }\n];\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(Keepalive, [{\n        type: Injectable\n    }], function () { return [{ type: ɵngcc1.HttpClient }, { type: ɵngcc0.NgZone }]; }, null); })();\n\nclass NgIdleKeepaliveModule {\n    static forRoot() {\n        return {\n            ngModule: NgIdleKeepaliveModule,\n            providers: [Keepalive, { provide: KeepaliveSvc, useExisting: Keepalive }]\n        };\n    }\n}\nNgIdleKeepaliveModule.ɵfac = function NgIdleKeepaliveModule_Factory(t) { return new (t || NgIdleKeepaliveModule)(); };\nNgIdleKeepaliveModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: NgIdleKeepaliveModule });\nNgIdleKeepaliveModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [NgIdleModule.forRoot()] });\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NgIdleKeepaliveModule, [{\n        type: NgModule,\n        args: [{ imports: [NgIdleModule.forRoot()] }]\n    }], null, null); })();\n(function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NgIdleKeepaliveModule, { imports: [ɵngcc2.NgIdleModule] }); })();\n\n/*\n * Public API Surface of keepalive\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { Keepalive, NgIdleKeepaliveModule };\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}