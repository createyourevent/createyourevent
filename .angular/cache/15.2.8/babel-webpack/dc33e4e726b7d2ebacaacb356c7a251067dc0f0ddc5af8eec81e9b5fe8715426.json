{"ast":null,"code":"\"use strict\";\n\n/* angular2-moment (c) 2015, 2016 Uri Shaked / MIT Licence */\nvar ɵngcc0 = require('@angular/core');\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = this && this.__metadata || function (k, v) {\n  if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar core_1 = require(\"@angular/core\");\nvar moment = require(\"moment\");\n// under systemjs, moment is actually exported as the default export, so we account for that\nvar momentConstructor = moment.default || moment;\nvar CalendarPipe = /** @class */function () {\n  function CalendarPipe(cdRef, ngZone) {\n    var _this = this;\n    this.cdRef = cdRef;\n    this.ngZone = ngZone;\n    // using a single static timer for all instances of this pipe for performance reasons\n    CalendarPipe_1.initTimer(ngZone);\n    CalendarPipe_1.refs++;\n    // values such as Today will need to be replaced with Yesterday after midnight,\n    // so make sure we subscribe to an EventEmitter that we set up to emit at midnight\n    this.midnightSub = CalendarPipe_1.midnight.subscribe(function () {\n      _this.ngZone.run(function () {\n        return _this.cdRef.markForCheck();\n      });\n    });\n  }\n  CalendarPipe_1 = CalendarPipe;\n  CalendarPipe.prototype.transform = function (value) {\n    var args = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n      args[_i - 1] = arguments[_i];\n    }\n    var formats = null;\n    var referenceTime = null;\n    for (var i = 0, len = args.length; i < len; i++) {\n      if (args[i] !== null) {\n        if (typeof args[i] === 'object' && !moment.isMoment(args[i])) {\n          formats = args[i];\n        } else {\n          referenceTime = momentConstructor(args[i]);\n        }\n      }\n    }\n    return momentConstructor(value).calendar(referenceTime, formats);\n  };\n  CalendarPipe.prototype.ngOnDestroy = function () {\n    if (CalendarPipe_1.refs > 0) {\n      CalendarPipe_1.refs--;\n    }\n    if (CalendarPipe_1.refs === 0) {\n      CalendarPipe_1.removeTimer();\n    }\n    this.midnightSub.unsubscribe();\n  };\n  CalendarPipe.initTimer = function (ngZone) {\n    // initialize the timer\n    if (!CalendarPipe_1.midnight) {\n      CalendarPipe_1.midnight = new core_1.EventEmitter();\n      if (typeof window !== 'undefined') {\n        var timeToUpdate_1 = CalendarPipe_1._getMillisecondsUntilUpdate();\n        CalendarPipe_1.timer = ngZone.runOutsideAngular(function () {\n          return window.setTimeout(function () {\n            // emit the current date\n            CalendarPipe_1.midnight.emit(new Date());\n            // refresh the timer\n            CalendarPipe_1.removeTimer();\n            CalendarPipe_1.initTimer(ngZone);\n          }, timeToUpdate_1);\n        });\n      }\n    }\n  };\n  CalendarPipe.removeTimer = function () {\n    if (CalendarPipe_1.timer) {\n      window.clearTimeout(CalendarPipe_1.timer);\n      CalendarPipe_1.timer = null;\n      CalendarPipe_1.midnight = null;\n    }\n  };\n  CalendarPipe._getMillisecondsUntilUpdate = function () {\n    var now = momentConstructor();\n    var tomorrow = momentConstructor().startOf('day').add(1, 'days');\n    var timeToMidnight = tomorrow.valueOf() - now.valueOf();\n    return timeToMidnight + 1000; // 1 second after midnight\n  };\n  /**\r\n   * @private Internal reference counter, so we can clean up when no instances are in use\r\n   * @type {number}\r\n   */\n  CalendarPipe.refs = 0;\n  CalendarPipe = CalendarPipe_1 = __decorate([__metadata(\"design:paramtypes\", [core_1.ChangeDetectorRef, core_1.NgZone])], CalendarPipe);\n  CalendarPipe.ɵfac = function CalendarPipe_Factory(t) {\n    return new (t || CalendarPipe)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef, 16), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone, 16));\n  };\n  CalendarPipe.ɵpipe = /*@__PURE__*/ɵngcc0.ɵɵdefinePipe({\n    name: \"amCalendar\",\n    type: CalendarPipe,\n    pure: false\n  });\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n  return CalendarPipe;\n  var CalendarPipe_1;\n}();\nexports.CalendarPipe = CalendarPipe;\n\n//# sourceMappingURL=calendar.pipe.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}