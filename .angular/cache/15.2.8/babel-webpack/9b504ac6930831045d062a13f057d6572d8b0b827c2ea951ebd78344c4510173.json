{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { EventEmitter, Component, Input, Output, HostListener, NgModule } from '@angular/core';\nconst DEFAULT_HEIGHT = 400;\nconst DEFAULT_WIDTH = 1;\nconst DEFAULT_STEP = 1;\nlet TagCloudComponent = /*#__PURE__*/(() => {\n  class TagCloudComponent {\n    constructor(el, r2) {\n      this.el = el;\n      this.r2 = r2;\n      this.data = [];\n      this.config = {};\n      this.clicked = new EventEmitter();\n      this.dataChanges = new EventEmitter();\n      this.afterInit = new EventEmitter();\n      this.afterChecked = new EventEmitter();\n      this.cloudDataHtmlElements = [];\n      this.dataArr = [];\n    }\n    get calculatedWidth() {\n      let width = this.config.width || this.width || DEFAULT_WIDTH;\n      if (this.el.nativeElement.parentNode.offsetWidth > 0 && width <= 1 && width > 0) {\n        width = this.el.nativeElement.parentNode.offsetWidth * width;\n      }\n      return width;\n    }\n    get calculatedHeight() {\n      let height = this.config.height || this.height || DEFAULT_HEIGHT;\n      if (this.el.nativeElement.parentNode.offsetHeight > 0 && height <= 1 && height > 0) {\n        height = this.el.nativeElement.parentNode.offsetHeight * height;\n      }\n      return height;\n    }\n    onResize(event) {\n      this.logMessage('debug', 'rezisze triggered');\n      window.clearTimeout(this.timeoutId);\n      this.timeoutId = window.setTimeout(() => {\n        if (this.options.realignOnResize) {\n          this.reDraw();\n        }\n      }, 200);\n    }\n    ngOnChanges(changes) {\n      this.logMessage('debug', 'ngOnChanges fired', changes);\n      // set default values\n      this.config = Object.assign({\n        width: 500,\n        height: 300,\n        overflow: true,\n        strict: false,\n        zoomOnHover: {\n          transitionTime: 0,\n          scale: 1,\n          delay: 0\n        },\n        realignOnResize: false,\n        randomizeAngle: false,\n        step: 2.0,\n        log: false\n      }, this.config);\n      // override properties if explicitly set\n      if (this.width) {\n        this.config.width = this.width;\n      }\n      if (this.height) {\n        this.config.height = this.height;\n      }\n      if (typeof this.overflow === 'boolean') {\n        this.config.overflow = this.overflow;\n      }\n      if (typeof this.strict === 'boolean') {\n        this.config.strict = this.strict;\n      }\n      if (typeof this.realignOnResize === 'boolean') {\n        this.config.realignOnResize = this.realignOnResize;\n      }\n      if (typeof this.randomizeAngle === 'boolean') {\n        this.config.randomizeAngle = this.randomizeAngle;\n      }\n      if (typeof this.background === 'string') {\n        this.config.background = this.background;\n      }\n      if (typeof this.font === 'string') {\n        this.config.font = this.font;\n      }\n      if (this.zoomOnHover) {\n        this.config.zoomOnHover = this.zoomOnHover;\n      }\n      if (this.step) {\n        this.config.step = this.step;\n      }\n      if (this.log) {\n        this.config.log = this.log;\n      }\n      if (this.delay) {\n        this.config.delay = this.delay;\n      }\n      this.logMessage('warn', 'cloud configuration', this.config);\n      // set the basic font style if property is provided\n      if (this.config.font) {\n        this.r2.setStyle(this.el.nativeElement, 'font', this.config.font);\n      }\n      // set a background image if property is provided\n      if (this.config.background) {\n        this.r2.setStyle(this.el.nativeElement, 'background', this.config.background);\n      }\n      this.reDraw(changes);\n    }\n    ngAfterContentInit() {\n      var _a;\n      (_a = this.afterInit) === null || _a === void 0 ? void 0 : _a.emit();\n      this.logMessage('debug', 'afterInit emitted');\n    }\n    ngAfterContentChecked() {\n      var _a;\n      (_a = this.afterChecked) === null || _a === void 0 ? void 0 : _a.emit();\n      this.logMessage('debug', 'afterChecked emitted');\n    }\n    /**\n     * re-draw the word cloud\n     * @param changes the change set\n     */\n    reDraw(changes) {\n      var _a, _b;\n      (_a = this.dataChanges) === null || _a === void 0 ? void 0 : _a.emit(changes);\n      (_b = this.afterChecked) === null || _b === void 0 ? void 0 : _b.emit();\n      this.logMessage('debug', 'dataChanges emitted');\n      this.cloudDataHtmlElements = [];\n      // check if data is not null or empty\n      if (!this.data) {\n        console.error('angular-tag-cloud: No data passed. Please pass an Array of CloudData');\n        return;\n      }\n      // values changed, reset cloud\n      this.el.nativeElement.innerHTML = '';\n      // set value changes\n      if (changes && changes.data) {\n        this.dataArr = changes.data.currentValue;\n      }\n      // set options\n      this.options = Object.assign(Object.assign({}, this.config), {\n        aspectRatio: this.calculatedWidth / this.calculatedHeight,\n        width: this.calculatedWidth,\n        height: this.calculatedHeight,\n        center: {\n          x: this.calculatedWidth / 2.0,\n          y: this.calculatedHeight / 2.0\n        }\n      });\n      // set the dimensions\n      this.r2.setStyle(this.el.nativeElement, 'width', this.options.width + 'px');\n      this.r2.setStyle(this.el.nativeElement, 'height', this.options.height + 'px');\n      // draw the cloud\n      this.drawWordCloud();\n      this.logMessage('debug', 'reDraw finished');\n    }\n    /**\n     * helper to generate a descriptive string for an entry to use when sorting alphabetically\n     * @param entry the cloud entry to be used\n     */\n    descriptiveEntry(entry) {\n      let description = entry.text;\n      description += entry.color ? `-${entry.color}` : '';\n      description += entry.external ? `-${entry.external}` : '';\n      description += entry.link ? `-${entry.link}` : '';\n      description += entry.rotate ? `-${entry.rotate}` : '';\n      return description;\n    }\n    /**\n     * proceed draw the cloud\n     */\n    drawWordCloud() {\n      // Sort alphabetically to ensure that, all things being equal, words are placed uniformly\n      this.dataArr.sort((a, b) => this.descriptiveEntry(a).localeCompare(this.descriptiveEntry(b)));\n      // Sort this._dataArr from the word with the highest weight to the one with the lowest\n      this.dataArr.sort((a, b) => b.weight - a.weight);\n      // place fixed elements first\n      const elementsWithFixedPositions = this.dataArr.filter(item => item.position);\n      const elementsWithRandomPositions = this.dataArr.filter(item => !item.position);\n      elementsWithFixedPositions.forEach((elem, index) => {\n        this.drawWord(index, elem);\n      });\n      elementsWithRandomPositions.forEach((elem, index) => {\n        this.drawWord(index, elem);\n      });\n    }\n    /**\n     * Helper function to test if an element overlaps others\n     * @param testEl the HTML Element to be tested\n     */\n    hitTest(testEl) {\n      // Check elements for overlap one by one, stop and return false as soon as an overlap is found\n      for (const item of this.cloudDataHtmlElements) {\n        if (this.overlapping(testEl, item)) {\n          return true;\n        }\n      }\n      return false;\n    }\n    /**\n     * Pairwise overlap detection\n     * @param e1 the first element for overlap detection\n     * @param e2 the second element for overlap detection\n     */\n    overlapping(e1, e2) {\n      const rect1 = e1.getBoundingClientRect();\n      const rect2 = e2.getBoundingClientRect();\n      const overlap = !(rect1.right < rect2.left || rect1.left > rect2.right || rect1.bottom < rect2.top || rect1.top > rect2.bottom);\n      return overlap;\n    }\n    /**\n     * Check if min(weight) > max(weight) otherwise use default\n     * @param word the particular word configuration\n     */\n    getWeightForWord(word) {\n      let weight = 5;\n      if (this.dataArr[0].weight > this.dataArr[this.dataArr.length - 1].weight) {\n        // check if strict mode is active\n        if (!this.options.strict) {\n          // Linearly map the original weight to a discrete scale from 1 to 10\n          weight = Math.round((word.weight - this.dataArr[this.dataArr.length - 1].weight) / (this.dataArr[0].weight - this.dataArr[this.dataArr.length - 1].weight) * 9.0) + 1;\n        } else {\n          // use given value for weigth directly\n          // fallback to 10\n          if (word.weight > 10) {\n            weight = 10;\n            this.logMessage('warn', `[TagCloud strict] Weight property ${word.weight} > 10. Fallback to 10 as you are using strict mode`, word);\n          } else if (word.weight < 1) {\n            // fallback to 1\n            weight = 1;\n            this.logMessage('warn', `[TagCloud strict] Given weight property ${word.weight} < 1. Fallback to 1 as you are using strict mode`, word);\n          } else if (word.weight % 1 !== 0) {\n            // round if given value is not an integer\n            weight = Math.round(word.weight);\n            this.logMessage('warn', `[TagCloud strict] Given weight property ${word.weight} is not an integer. Rounded value to ${weight}`, word);\n          } else {\n            weight = word.weight;\n          }\n        }\n      }\n      return weight;\n    }\n    /**\n     * change the HTMLElements color style\n     * @param el the HTML element\n     * @param color the CSS color value\n     */\n    setWordColor(el, color) {\n      this.r2.setStyle(el, 'color', color);\n    }\n    /**\n     * Add a tooltip to the element\n     * @param el the HTML element\n     * @param tooltip the tooltip text\n     */\n    setTooltip(el, tooltip) {\n      this.r2.addClass(el, 'tooltip');\n      const tooltipSpan = this.r2.createElement('span');\n      tooltipSpan.className = 'tooltiptext';\n      const text = this.r2.createText(tooltip);\n      tooltipSpan.appendChild(text);\n      el.appendChild(tooltipSpan);\n    }\n    /**\n     * change the HTMLElements rotation style\n     * @param el the HTML element\n     * @param deg the rotation value (degrees)\n     */\n    setWordRotation(el, deg) {\n      const transformString = deg ? `rotate(${deg}deg)` : '';\n      this.r2.setStyle(el, 'transform', transformString);\n      return transformString;\n    }\n    /**\n     * wrap the given node into an HTML anchor element\n     * @param node the HTML node that should be wrapped\n     * @param word the particular word configuration\n     */\n    wrapNodeIntoAnchorElement(node, word) {\n      const wordLink = this.r2.createElement('a');\n      wordLink.href = word.link || '';\n      if (word.external !== undefined && word.external) {\n        wordLink.target = '_blank';\n      }\n      wordLink.appendChild(node);\n      return wordLink;\n    }\n    /**\n     * wrap the given node into an HTML anchor element\n     * @param node the HTML node that should be wrapped\n     * @param word the particular word configuration\n     */\n    applyZoomStyle(node, el, link, transformString) {\n      if (this.options.zoomOnHover && this.options.zoomOnHover.scale !== 1) {\n        if (!this.options.zoomOnHover.transitionTime) {\n          this.options.zoomOnHover.transitionTime = 0;\n        }\n        if (!this.options.zoomOnHover.scale) {\n          this.options.zoomOnHover.scale = 1;\n        }\n        el.onmouseover = () => {\n          var _a, _b, _c, _d;\n          if ((_a = this.options.zoomOnHover) === null || _a === void 0 ? void 0 : _a.transitionTime) {\n            this.r2.setStyle(el, 'transition', `transform ${this.options.zoomOnHover.transitionTime}s`);\n          }\n          if ((_b = this.options.zoomOnHover) === null || _b === void 0 ? void 0 : _b.scale) {\n            this.r2.setStyle(el, 'transform', `scale(${this.options.zoomOnHover.scale}) ${transformString}`);\n          }\n          if ((_c = this.options.zoomOnHover) === null || _c === void 0 ? void 0 : _c.delay) {\n            this.r2.setStyle(el, 'transition-delay', `${this.options.zoomOnHover.delay}s`);\n          }\n          if ((_d = this.options.zoomOnHover) === null || _d === void 0 ? void 0 : _d.color) {\n            link ? this.r2.setStyle(node, 'color', this.options.zoomOnHover.color) : this.r2.setStyle(el, 'color', this.options.zoomOnHover.color);\n          }\n        };\n        el.onmouseout = () => {\n          var _a;\n          this.r2.setStyle(el, 'transform', `none ${transformString}`);\n          if ((_a = this.options.zoomOnHover) === null || _a === void 0 ? void 0 : _a.color) {\n            link ? this.r2.removeStyle(node, 'color') : this.r2.removeStyle(el, 'color');\n          }\n        };\n      }\n    }\n    /**\n     * Place the word at a calculated position\n     * @param wordSpan The HTML Span element to be placed\n     * @param word The word to be placed\n     * @param index The index of the element\n     */\n    setPosition(wordSpan, word, index) {\n      var _a, _b;\n      let angle = this.options.randomizeAngle ? 6.28 * Math.random() : 0;\n      let radius = 0;\n      // Save a reference to the style property, for better performance\n      const wordStyle = wordSpan.style;\n      wordStyle.position = 'absolute';\n      const useFixedPosition = Boolean(word.position && word.position.left && word.position.top);\n      const width = wordSpan.offsetWidth;\n      const height = wordSpan.offsetHeight;\n      let left = useFixedPosition && ((_a = word.position) === null || _a === void 0 ? void 0 : _a.left) ? word.position.left : this.options.center.x - width / 2;\n      let top = useFixedPosition && ((_b = word.position) === null || _b === void 0 ? void 0 : _b.top) ? word.position.top : this.options.center.y - height / 2;\n      // place the first word\n      wordStyle.left = left + 'px';\n      wordStyle.top = top + 'px';\n      // delayed appearance\n      if (this.options.delay) {\n        wordStyle.animation = 'fadeIn 0.5s';\n        wordStyle.opacity = '0';\n        wordStyle.animationFillMode = 'forwards';\n        wordStyle.animationDelay = `${this.options.delay * index}ms`;\n      }\n      // default case: place randomly\n      if (!useFixedPosition) {\n        // do not place the first word always right in the middle\n        if (index === 0) {\n          wordStyle.left = left + (Math.random() - 0.5) * 2 * (this.calculatedWidth / 5) + 'px';\n          wordStyle.top = top + (Math.random() - 0.5) * 2 * (this.calculatedHeight / 5) + '30px';\n        } else {\n          while (this.options.width && this.options.height && wordSpan.offsetHeight && wordSpan.offsetWidth && this.hitTest(wordSpan)) {\n            radius += this.options.step || DEFAULT_STEP;\n            angle += (index % 2 === 0 ? 1 : -1) * (this.options.step || DEFAULT_STEP);\n            left = this.options.center.x - width / 2.0 + radius * Math.cos(angle) * this.options.aspectRatio;\n            top = this.options.center.y + radius * Math.sin(angle) - height / 2.0;\n            wordStyle.left = left + 'px';\n            wordStyle.top = top + 'px';\n          }\n        }\n      }\n      // Don't render word if part of it would be outside the container\n      if (!this.options.overflow && (left < 0 || top < 0 || left + width > this.calculatedWidth || top + height > this.calculatedHeight)) {\n        this.logMessage('warn', \"Word did not fit into the cloud and overflow is set to 'false'. The element will be removed\", wordSpan);\n        wordSpan.remove();\n        return;\n      }\n    }\n    /**\n     * Methods to draw a word, by moving it in spiral until it finds a suitable empty place.\n     * This will be iterated on each word.\n     * @param index the index number for the word\n     * @param word the particular word configuration\n     */\n    drawWord(index, word) {\n      let wordSpan;\n      // get calculated word weight\n      const weight = this.getWeightForWord(word);\n      // Create a new span and insert node.\n      wordSpan = this.r2.createElement('span');\n      wordSpan.className = `w${weight}`;\n      // emit onclick event\n      wordSpan.onclick = () => {\n        var _a;\n        (_a = this.clicked) === null || _a === void 0 ? void 0 : _a.emit(word);\n      };\n      // Put the word (and its tooltip) in foreground when cursor is above\n      wordSpan.onmouseenter = () => {\n        wordSpan.style.zIndex = '2';\n      };\n      // Otherwise, restore standard priority\n      wordSpan.onmouseleave = () => {\n        wordSpan.style.zIndex = '1';\n      };\n      // append word text\n      let node = this.r2.createText(word.text);\n      // set color\n      if (word.color) this.setWordColor(wordSpan, word.color);\n      // rotate word possibly\n      const transformString = this.setWordRotation(wordSpan, word.rotate);\n      // Append href if there's a link along with the tag\n      if (word.link) node = this.wrapNodeIntoAnchorElement(node, word);\n      // set zoomOption\n      if (this.options.zoomOnHover && this.options.zoomOnHover.scale !== 1) {\n        this.applyZoomStyle(node, wordSpan, word.link, transformString);\n      }\n      wordSpan.appendChild(node);\n      this.r2.appendChild(this.el.nativeElement, wordSpan);\n      // add tooltip if provided\n      if (word.tooltip) this.setTooltip(wordSpan, word.tooltip);\n      // set a unique id\n      wordSpan.id = `angular-tag-cloud-item-${index}`;\n      // define the elements position\n      this.setPosition(wordSpan, word, index);\n      this.logMessage('debug', 'Adds new word <span>', wordSpan);\n      this.cloudDataHtmlElements.push(wordSpan);\n      this.logMessage('debug', 'Placed words', this.cloudDataHtmlElements);\n    }\n    /**\n     * Log messages to console\n     * @param level the log level\n     * @param args extra args to be logged\n     */\n    logMessage(level, ...args) {\n      if (!this.config) {\n        return;\n      }\n      if (this.config.log === 'debug') {\n        console.log(`[AngularTagCloudModule ${level}]`, ...args);\n      } else if (this.config.log === 'warn' && level === 'warn') {\n        console.warn(`[AngularTagCloudModule ${level}]`, ...args);\n      }\n    }\n  }\n  TagCloudComponent.ɵfac = function TagCloudComponent_Factory(t) {\n    return new (t || TagCloudComponent)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2));\n  };\n  TagCloudComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: TagCloudComponent,\n    selectors: [[\"angular-tag-cloud\"], [\"ng-tag-cloud\"], [\"ngtc\"]],\n    hostBindings: function TagCloudComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"resize\", function TagCloudComponent_resize_HostBindingHandler($event) {\n          return ctx.onResize($event);\n        }, false, i0.ɵɵresolveWindow);\n      }\n    },\n    inputs: {\n      data: \"data\",\n      width: \"width\",\n      height: \"height\",\n      step: \"step\",\n      overflow: \"overflow\",\n      strict: \"strict\",\n      zoomOnHover: \"zoomOnHover\",\n      realignOnResize: \"realignOnResize\",\n      randomizeAngle: \"randomizeAngle\",\n      background: \"background\",\n      font: \"font\",\n      delay: \"delay\",\n      config: \"config\",\n      log: \"log\"\n    },\n    outputs: {\n      clicked: \"clicked\",\n      dataChanges: \"dataChanges\",\n      afterInit: \"afterInit\",\n      afterChecked: \"afterChecked\"\n    },\n    features: [i0.ɵɵNgOnChangesFeature],\n    decls: 0,\n    vars: 0,\n    template: function TagCloudComponent_Template(rf, ctx) {},\n    styles: [\"[_nghost-%COMP%]{font-family:\\\"Helvetica\\\",\\\"Arial\\\",sans-serif;font-size:10px;line-height:normal;color:#09f;overflow:hidden;position:relative;display:block}span[_ngcontent-%COMP%]{padding:0}span.w10[_ngcontent-%COMP%]{font-size:550%}span.w9[_ngcontent-%COMP%]{font-size:500%}span.w8[_ngcontent-%COMP%]{font-size:450%}span.w7[_ngcontent-%COMP%]{font-size:400%}span.w6[_ngcontent-%COMP%]{font-size:350%}span.w5[_ngcontent-%COMP%]{font-size:300%}span.w4[_ngcontent-%COMP%]{font-size:250%}span.w3[_ngcontent-%COMP%]{font-size:200%}span.w2[_ngcontent-%COMP%]{font-size:150%}span.w1[_ngcontent-%COMP%]{font-size:100%}a[_ngcontent-%COMP%]:hover{color:#0df}a[_ngcontent-%COMP%]:hover{color:#0cf}span.w10[_ngcontent-%COMP%]{color:#0cf}span.w9[_ngcontent-%COMP%]{color:#0cf}span.w8[_ngcontent-%COMP%]{color:#0cf}span.w7[_ngcontent-%COMP%]{color:#39d}span.w6[_ngcontent-%COMP%]{color:#90c5f0}span.w5[_ngcontent-%COMP%]{color:#90a0dd}span.w4[_ngcontent-%COMP%]{color:#90c5f0}span.w3[_ngcontent-%COMP%]{color:#a0ddff}span.w2[_ngcontent-%COMP%]{color:#9ce}span.w1[_ngcontent-%COMP%]{color:#aab5f0}.tooltip[_ngcontent-%COMP%]   .tooltiptext[_ngcontent-%COMP%]{visibility:hidden;width:inherit;background-color:#555;color:#fff;text-align:center;border-radius:6px;padding:5px 10px;position:absolute;bottom:100%;left:0px;opacity:0;transition:opacity .3s}.tooltip[_ngcontent-%COMP%]   .tooltiptext[_ngcontent-%COMP%]:after{content:\\\"\\\";position:absolute;top:100%;left:50%;margin-left:-5px;border-width:5px;border-style:solid;border-color:#555 transparent transparent transparent}.tooltip[_ngcontent-%COMP%]:hover   .tooltiptext[_ngcontent-%COMP%]{visibility:visible;opacity:1}@keyframes _ngcontent-%COMP%_fadeIn{0%{opacity:0}to{opacity:1}}\"]\n  });\n  return TagCloudComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet TagCloudModule = /*#__PURE__*/(() => {\n  class TagCloudModule {}\n  TagCloudModule.ɵfac = function TagCloudModule_Factory(t) {\n    return new (t || TagCloudModule)();\n  };\n  TagCloudModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: TagCloudModule\n  });\n  TagCloudModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  return TagCloudModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/*\n * Public API Surface of angular-tag-cloud-module\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { TagCloudComponent, TagCloudModule };\n//# sourceMappingURL=angular-tag-cloud-module.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}