{"ast":null,"code":"import { SecurityContext } from '@angular/core';\nimport { translationNotFoundMessage } from 'app/config/translation.config';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/platform-browser\";\nimport * as i2 from \"@ngx-translate/core\";\nexport let AlertService = /*#__PURE__*/(() => {\n  class AlertService {\n    constructor(sanitizer, ngZone, translateService) {\n      this.sanitizer = sanitizer;\n      this.ngZone = ngZone;\n      this.translateService = translateService;\n      this.timeout = 5000;\n      this.toast = false;\n      this.position = 'top right';\n      // unique id for each alert. Starts from 0.\n      this.alertId = 0;\n      this.alerts = [];\n    }\n    clear() {\n      this.alerts = [];\n    }\n    get() {\n      return this.alerts;\n    }\n    /**\n     * Adds alert to alerts array and returns added alert.\n     * @param alert      Alert to add. If `timeout`, `toast` or `position` is missing then applying default value.\n     *                   If `translateKey` is available then it's translation else `message` is used for showing.\n     * @param extAlerts  If missing then adding `alert` to `AlertService` internal array and alerts can be retrieved by `get()`.\n     *                   Else adding `alert` to `extAlerts`.\n     * @returns  Added alert\n     */\n    addAlert(alert, extAlerts) {\n      alert.id = this.alertId++;\n      if (alert.translationKey) {\n        const translatedMessage = this.translateService.instant(alert.translationKey, alert.translationParams);\n        // if translation key exists\n        if (translatedMessage !== `${translationNotFoundMessage}[${alert.translationKey}]`) {\n          alert.message = translatedMessage;\n        } else if (!alert.message) {\n          alert.message = alert.translationKey;\n        }\n      }\n      alert.message = this.sanitizer.sanitize(SecurityContext.HTML, alert.message ?? '') ?? '';\n      alert.timeout = alert.timeout ?? this.timeout;\n      alert.toast = alert.toast ?? this.toast;\n      alert.position = alert.position ?? this.position;\n      alert.close = alertsArray => this.closeAlert(alert.id, alertsArray);\n      (extAlerts ?? this.alerts).push(alert);\n      if (alert.timeout > 0) {\n        // Workaround protractor waiting for setTimeout.\n        // Reference https://www.protractortest.org/#/timeouts\n        this.ngZone.runOutsideAngular(() => {\n          setTimeout(() => {\n            this.ngZone.run(() => {\n              this.closeAlert(alert.id, extAlerts ?? this.alerts);\n            });\n          }, alert.timeout);\n        });\n      }\n      return alert;\n    }\n    closeAlert(alertId, extAlerts) {\n      const alerts = extAlerts ?? this.alerts;\n      const alertIndex = alerts.map(alert => alert.id).indexOf(alertId);\n      // if found alert then remove\n      if (alertIndex >= 0) {\n        alerts.splice(alertIndex, 1);\n      }\n    }\n  }\n  AlertService.ɵfac = function AlertService_Factory(t) {\n    return new (t || AlertService)(i0.ɵɵinject(i1.DomSanitizer), i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(i2.TranslateService));\n  };\n  AlertService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: AlertService,\n    factory: AlertService.ɵfac,\n    providedIn: 'root'\n  });\n  return AlertService;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}