{"ast":null,"code":"import { InjectionToken, ɵɵdefineInjectable, ɵɵinject, Injectable, Inject, Directive, ElementRef, Input, Component, NgModule } from '@angular/core';\nimport { Subject } from 'rxjs';\nimport * as Mousetrap from 'mousetrap';\nimport { prototype } from 'mousetrap';\nimport { CommonModule } from '@angular/common';\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@angular/common';\nfunction HotkeysCheatsheetComponent_tr_11_span_4_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"span\", 8);\n    ɵngcc0.ɵɵtext(1);\n    ɵngcc0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const key_r3 = ctx.$implicit;\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵtextInterpolate(key_r3);\n  }\n}\nfunction HotkeysCheatsheetComponent_tr_11_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"tr\");\n    ɵngcc0.ɵɵtext(1, \"\\n                \");\n    ɵngcc0.ɵɵelementStart(2, \"td\", 5);\n    ɵngcc0.ɵɵtext(3, \"\\n                    \");\n    ɵngcc0.ɵɵtemplate(4, HotkeysCheatsheetComponent_tr_11_span_4_Template, 2, 1, \"span\", 6);\n    ɵngcc0.ɵɵtext(5, \"\\n                \");\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵtext(6, \"\\n                \");\n    ɵngcc0.ɵɵelementStart(7, \"td\", 7);\n    ɵngcc0.ɵɵtext(8);\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵtext(9, \"\\n            \");\n    ɵngcc0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const hotkey_r1 = ctx.$implicit;\n    ɵngcc0.ɵɵadvance(4);\n    ɵngcc0.ɵɵproperty(\"ngForOf\", hotkey_r1.formatted);\n    ɵngcc0.ɵɵadvance(4);\n    ɵngcc0.ɵɵtextInterpolate(hotkey_r1.description);\n  }\n}\nconst _c0 = function (a0) {\n  return {\n    \"in\": a0\n  };\n};\nclass Hotkey {\n  /**\n   * Creates a new Hotkey for Mousetrap binding\n   *\n   * @param combo       mousetrap key binding\n   * @param description description for the help menu\n   * @param callback    method to call when key is pressed\n   * @param action      the type of event to listen for (for mousetrap)\n   * @param allowIn     an array of tag names to allow this combo in ('INPUT', 'SELECT', and/or 'TEXTAREA')\n   * @param persistent  if true, the binding is preserved upon route changes\n   */\n  constructor(combo, callback, allowIn, description, action, persistent) {\n    this.combo = combo;\n    this.callback = callback;\n    this.allowIn = allowIn;\n    this.description = description;\n    this.action = action;\n    this.persistent = persistent;\n    this.combo = Array.isArray(combo) ? combo : [combo];\n    this.allowIn = allowIn || [];\n    this.description = description || '';\n  }\n  static symbolize(combo) {\n    const map = {\n      command: '\\u2318',\n      shift: '\\u21E7',\n      left: '\\u2190',\n      right: '\\u2192',\n      up: '\\u2191',\n      down: '\\u2193',\n      // tslint:disable-next-line:object-literal-key-quotes\n      'return': '\\u23CE',\n      backspace: '\\u232B' // ⌫\n    };\n\n    const comboSplit = combo.split('+');\n    for (let i = 0; i < comboSplit.length; i++) {\n      // try to resolve command / ctrl based on OS:\n      if (comboSplit[i] === 'mod') {\n        if (window.navigator && window.navigator.platform.indexOf('Mac') >= 0) {\n          comboSplit[i] = 'command';\n        } else {\n          comboSplit[i] = 'ctrl';\n        }\n      }\n      comboSplit[i] = map[comboSplit[i]] || comboSplit[i];\n    }\n    return comboSplit.join(' + ');\n  }\n  get formatted() {\n    if (!this.formattedHotkey) {\n      const sequence = this.combo;\n      for (let i = 0; i < sequence.length; i++) {\n        sequence[i] = Hotkey.symbolize(sequence[i]);\n      }\n      this.formattedHotkey = sequence;\n    }\n    return this.formattedHotkey;\n  }\n}\nconst HotkeyOptions = new InjectionToken('HotkeyOptions');\nlet HotkeysService = /*#__PURE__*/(() => {\n  class HotkeysService {\n    constructor(options) {\n      this.options = options;\n      this.hotkeys = [];\n      this.pausedHotkeys = [];\n      this.cheatSheetToggle = new Subject();\n      this.preventIn = ['INPUT', 'SELECT', 'TEXTAREA'];\n      // noinspection JSUnusedGlobalSymbols,JSUnusedLocalSymbols\n      prototype.stopCallback = (event, element, combo, callback) => {\n        // if the element has the class \"mousetrap\" then no need to stop\n        if ((' ' + element.className + ' ').indexOf(' mousetrap ') > -1) {\n          return false;\n        }\n        return element.contentEditable && element.contentEditable === 'true';\n      };\n      this.mousetrap = new Mousetrap();\n      this.initCheatSheet();\n    }\n    initCheatSheet() {\n      if (!this.options.disableCheatSheet) {\n        this.add(new Hotkey(this.options.cheatSheetHotkey || '?', function (_) {\n          this.cheatSheetToggle.next();\n        }.bind(this), [], this.options.cheatSheetDescription || 'Show / hide this help menu'));\n      }\n      if (this.options.cheatSheetCloseEsc) {\n        this.add(new Hotkey('esc', function (_) {\n          this.cheatSheetToggle.next(false);\n        }.bind(this), ['HOTKEYS-CHEATSHEET'], this.options.cheatSheetCloseEscDescription || 'Hide this help menu'));\n      }\n    }\n    add(hotkey, specificEvent) {\n      if (Array.isArray(hotkey)) {\n        const temp = [];\n        for (const key of hotkey) {\n          temp.push(this.add(key, specificEvent));\n        }\n        return temp;\n      }\n      this.remove(hotkey);\n      this.hotkeys.push(hotkey);\n      this.mousetrap.bind(hotkey.combo, (event, combo) => {\n        let shouldExecute = true;\n        // if the callback is executed directly `hotkey.get('w').callback()`\n        // there will be no event, so just execute the callback.\n        if (event) {\n          const target = event.target || event.srcElement; // srcElement is IE only\n          const nodeName = target.nodeName.toUpperCase();\n          // check if the input has a mousetrap class, and skip checking preventIn if so\n          if ((' ' + target.className + ' ').indexOf(' mousetrap ') > -1) {\n            shouldExecute = true;\n          } else if (this.preventIn.indexOf(nodeName) > -1 && hotkey.allowIn.map(allow => allow.toUpperCase()).indexOf(nodeName) === -1) {\n            // don't execute callback if the event was fired from inside an element listed in preventIn but not in allowIn\n            shouldExecute = false;\n          }\n        }\n        if (shouldExecute) {\n          return hotkey.callback.apply(this, [event, combo]);\n        }\n      }, specificEvent);\n      return hotkey;\n    }\n    remove(hotkey, specificEvent) {\n      const temp = [];\n      if (!hotkey) {\n        for (const key of this.hotkeys) {\n          temp.push(this.remove(key, specificEvent));\n        }\n        return temp;\n      }\n      if (Array.isArray(hotkey)) {\n        for (const key of hotkey) {\n          temp.push(this.remove(key));\n        }\n        return temp;\n      }\n      const index = this.findHotkey(hotkey);\n      if (index > -1) {\n        this.hotkeys.splice(index, 1);\n        this.mousetrap.unbind(hotkey.combo, specificEvent);\n        return hotkey;\n      }\n      return null;\n    }\n    get(combo) {\n      if (!combo) {\n        return this.hotkeys;\n      }\n      if (Array.isArray(combo)) {\n        const temp = [];\n        for (const key of combo) {\n          temp.push(this.get(key));\n        }\n        return temp;\n      }\n      for (const hotkey of this.hotkeys) {\n        if (hotkey.combo.indexOf(combo) > -1) {\n          return hotkey;\n        }\n      }\n      return null;\n    }\n    // noinspection JSUnusedGlobalSymbols\n    pause(hotkey) {\n      if (!hotkey) {\n        return this.pause(this.hotkeys);\n      }\n      if (Array.isArray(hotkey)) {\n        const temp = [];\n        for (const key of hotkey) {\n          temp.push(this.pause(key));\n        }\n        return temp;\n      }\n      this.remove(hotkey);\n      this.pausedHotkeys.push(hotkey);\n      return hotkey;\n    }\n    // noinspection JSUnusedGlobalSymbols\n    unpause(hotkey) {\n      if (!hotkey) {\n        return this.unpause(this.pausedHotkeys);\n      }\n      if (Array.isArray(hotkey)) {\n        const temp = [];\n        for (const key of hotkey) {\n          temp.push(this.unpause(key));\n        }\n        return temp;\n      }\n      const index = this.pausedHotkeys.indexOf(hotkey);\n      if (index > -1) {\n        this.add(hotkey);\n        return this.pausedHotkeys.splice(index, 1);\n      }\n      return null;\n    }\n    // noinspection JSUnusedGlobalSymbols\n    reset() {\n      this.mousetrap.reset();\n      this.hotkeys = [];\n      this.pausedHotkeys = [];\n      this.initCheatSheet();\n    }\n    findHotkey(hotkey) {\n      return this.hotkeys.indexOf(hotkey);\n    }\n  }\n  HotkeysService.ɵfac = function HotkeysService_Factory(t) {\n    return new (t || HotkeysService)(ɵngcc0.ɵɵinject(HotkeyOptions));\n  };\n  HotkeysService.ɵprov = ɵɵdefineInjectable({\n    factory: function HotkeysService_Factory() {\n      return new HotkeysService(ɵɵinject(HotkeyOptions));\n    },\n    token: HotkeysService,\n    providedIn: \"root\"\n  });\n  return HotkeysService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet HotkeysDirective = /*#__PURE__*/(() => {\n  class HotkeysDirective {\n    constructor(hotkeysService, elementRef) {\n      this.hotkeysService = hotkeysService;\n      this.elementRef = elementRef;\n      this.hotkeysList = [];\n      this.oldHotkeys = [];\n      this.mousetrap = new Mousetrap(this.elementRef.nativeElement); // Bind hotkeys to the current element (and any children)\n    }\n\n    ngOnInit() {\n      for (const hotkey of this.hotkeys) {\n        const combo = Object.keys(hotkey)[0];\n        const hotkeyObj = new Hotkey(combo, hotkey[combo]);\n        const oldHotkey = this.hotkeysService.get(combo);\n        if (oldHotkey !== null) {\n          // We let the user overwrite callbacks temporarily if you specify it in HTML\n          this.oldHotkeys.push(oldHotkey);\n          this.hotkeysService.remove(oldHotkey);\n        }\n        this.hotkeysList.push(hotkeyObj);\n        this.mousetrap.bind(hotkeyObj.combo, hotkeyObj.callback);\n      }\n    }\n    ngOnDestroy() {\n      for (const hotkey of this.hotkeysList) {\n        this.mousetrap.unbind(hotkey.combo);\n      }\n      this.hotkeysService.add(this.oldHotkeys);\n    }\n  }\n  HotkeysDirective.ɵfac = function HotkeysDirective_Factory(t) {\n    return new (t || HotkeysDirective)(ɵngcc0.ɵɵdirectiveInject(HotkeysService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef));\n  };\n  HotkeysDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: HotkeysDirective,\n    selectors: [[\"\", \"hotkeys\", \"\"]],\n    inputs: {\n      hotkeys: \"hotkeys\"\n    },\n    features: [ɵngcc0.ɵɵProvidersFeature([HotkeysService])]\n  });\n  return HotkeysDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet HotkeysCheatsheetComponent = /*#__PURE__*/(() => {\n  class HotkeysCheatsheetComponent {\n    constructor(hotkeysService) {\n      this.hotkeysService = hotkeysService;\n      this.helpVisible = false;\n      this.title = 'Keyboard Shortcuts:';\n    }\n    ngOnInit() {\n      this.subscription = this.hotkeysService.cheatSheetToggle.subscribe(isOpen => {\n        if (isOpen !== false) {\n          this.hotkeys = this.hotkeysService.hotkeys.filter(hotkey => hotkey.description);\n        }\n        if (isOpen === false) {\n          this.helpVisible = false;\n        } else {\n          this.toggleCheatSheet();\n        }\n      });\n    }\n    ngOnDestroy() {\n      if (this.subscription) {\n        this.subscription.unsubscribe();\n      }\n    }\n    toggleCheatSheet() {\n      this.helpVisible = !this.helpVisible;\n    }\n  }\n  HotkeysCheatsheetComponent.ɵfac = function HotkeysCheatsheetComponent_Factory(t) {\n    return new (t || HotkeysCheatsheetComponent)(ɵngcc0.ɵɵdirectiveInject(HotkeysService));\n  };\n  HotkeysCheatsheetComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: HotkeysCheatsheetComponent,\n    selectors: [[\"hotkeys-cheatsheet\"]],\n    inputs: {\n      title: \"title\"\n    },\n    decls: 20,\n    vars: 5,\n    consts: [[1, \"cfp-hotkeys-container\", \"fade\", 2, \"display\", \"none\", 3, \"ngClass\"], [1, \"cfp-hotkeys\"], [1, \"cfp-hotkeys-title\"], [4, \"ngFor\", \"ngForOf\"], [1, \"cfp-hotkeys-close\", 3, \"click\"], [1, \"cfp-hotkeys-keys\"], [\"class\", \"cfp-hotkeys-key\", 4, \"ngFor\", \"ngForOf\"], [1, \"cfp-hotkeys-text\"], [1, \"cfp-hotkeys-key\"]],\n    template: function HotkeysCheatsheetComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵelementStart(0, \"div\", 0);\n        ɵngcc0.ɵɵtext(1, \"\\n    \");\n        ɵngcc0.ɵɵelementStart(2, \"div\", 1);\n        ɵngcc0.ɵɵtext(3, \"\\n        \");\n        ɵngcc0.ɵɵelementStart(4, \"h4\", 2);\n        ɵngcc0.ɵɵtext(5);\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵtext(6, \"\\n        \");\n        ɵngcc0.ɵɵelementStart(7, \"table\");\n        ɵngcc0.ɵɵtext(8, \"\\n            \");\n        ɵngcc0.ɵɵelementStart(9, \"tbody\");\n        ɵngcc0.ɵɵtext(10, \"\\n            \");\n        ɵngcc0.ɵɵtemplate(11, HotkeysCheatsheetComponent_tr_11_Template, 10, 2, \"tr\", 3);\n        ɵngcc0.ɵɵtext(12, \"\\n            \");\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵtext(13, \"\\n        \");\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵtext(14, \"\\n        \");\n        ɵngcc0.ɵɵelementStart(15, \"div\", 4);\n        ɵngcc0.ɵɵlistener(\"click\", function HotkeysCheatsheetComponent_Template_div_click_15_listener() {\n          return ctx.toggleCheatSheet();\n        });\n        ɵngcc0.ɵɵtext(16, \"\\u00D7\");\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵtext(17, \"\\n    \");\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵtext(18, \"\\n\");\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵtext(19, \"\\n\");\n      }\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"ngClass\", ɵngcc0.ɵɵpureFunction1(3, _c0, ctx.helpVisible));\n        ɵngcc0.ɵɵadvance(5);\n        ɵngcc0.ɵɵtextInterpolate(ctx.title);\n        ɵngcc0.ɵɵadvance(6);\n        ɵngcc0.ɵɵproperty(\"ngForOf\", ctx.hotkeys);\n      }\n    },\n    dependencies: [ɵngcc1.NgClass, ɵngcc1.NgForOf],\n    styles: [\".cfp-hotkeys-container[_ngcontent-%COMP%]{display:table!important;position:fixed;width:100%;height:100%;top:0;left:0;color:#333;font-size:1em;background-color:hsla(0,0%,100%,.9)}.cfp-hotkeys-container.fade[_ngcontent-%COMP%]{z-index:-1024;visibility:hidden;opacity:0;transition:opacity .15s linear}.cfp-hotkeys-container.fade.in[_ngcontent-%COMP%]{z-index:10002;visibility:visible;opacity:1}.cfp-hotkeys-title[_ngcontent-%COMP%]{font-weight:700;text-align:center;font-size:1.2em}.cfp-hotkeys[_ngcontent-%COMP%]{width:100%;height:100%;display:table-cell;vertical-align:middle}.cfp-hotkeys[_ngcontent-%COMP%]   table[_ngcontent-%COMP%]{margin:auto;color:#333}.cfp-content[_ngcontent-%COMP%]{display:table-cell;vertical-align:middle}.cfp-hotkeys-keys[_ngcontent-%COMP%]{padding:5px;text-align:right}.cfp-hotkeys-key[_ngcontent-%COMP%]{display:inline-block;color:#fff;background-color:#333;border:1px solid #333;border-radius:5px;text-align:center;margin-right:5px;box-shadow:inset 0 1px 0 #666,0 1px 0 #bbb;padding:5px 9px;font-size:1em}.cfp-hotkeys-text[_ngcontent-%COMP%]{padding-left:10px;font-size:1em}.cfp-hotkeys-close[_ngcontent-%COMP%]{position:fixed;top:20px;right:20px;font-size:2em;font-weight:700;padding:5px 10px;border:1px solid #ddd;border-radius:5px;min-height:45px;min-width:45px;text-align:center}.cfp-hotkeys-close[_ngcontent-%COMP%]:hover{background-color:#fff;cursor:pointer}@media (max-width:500px){.cfp-hotkeys[_ngcontent-%COMP%]{font-size:.8em}}@media (min-width:750px){.cfp-hotkeys[_ngcontent-%COMP%]{font-size:1.2em}}\"]\n  });\n  return HotkeysCheatsheetComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet HotkeyModule = /*#__PURE__*/(() => {\n  class HotkeyModule {\n    // noinspection JSUnusedGlobalSymbols\n    static forRoot(options = {}) {\n      return {\n        ngModule: HotkeyModule,\n        providers: [HotkeysService, {\n          provide: HotkeyOptions,\n          useValue: options\n        }]\n      };\n    }\n  }\n  HotkeyModule.ɵfac = function HotkeyModule_Factory(t) {\n    return new (t || HotkeyModule)();\n  };\n  HotkeyModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: HotkeyModule\n  });\n  HotkeyModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    imports: [CommonModule]\n  });\n  return HotkeyModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(HotkeyModule, {\n    declarations: function () {\n      return [HotkeysDirective, HotkeysCheatsheetComponent];\n    },\n    imports: function () {\n      return [CommonModule];\n    },\n    exports: function () {\n      return [HotkeysDirective, HotkeysCheatsheetComponent];\n    }\n  });\n})();\n\n/*\n * Public API Surface of angular2-hotkeys\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { Hotkey, HotkeyModule, HotkeyOptions, HotkeysCheatsheetComponent, HotkeysDirective, HotkeysService };\n\n//# sourceMappingURL=angular2-hotkeys.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}