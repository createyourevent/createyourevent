{"ast":null,"code":"import { InjectionToken, Injectable, Inject, Component, ChangeDetectionStrategy, ChangeDetectorRef, EventEmitter, ElementRef, Renderer2, Input, Output, NgModule } from '@angular/core';\nimport { Subject } from 'rxjs';\nimport { CommonModule } from '@angular/common';\n\n/**\n * Notification\n *\n * This class describes the structure of a notifiction, including all information it needs to live, and everyone else needs to work with it.\n */\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@angular/common';\nfunction NotifierContainerComponent_li_2_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r3 = ɵngcc0.ɵɵgetCurrentView();\n    ɵngcc0.ɵɵelementStart(0, \"li\", 2);\n    ɵngcc0.ɵɵtext(1, \"\\n    \");\n    ɵngcc0.ɵɵelementStart(2, \"notifier-notification\", 3);\n    ɵngcc0.ɵɵlistener(\"ready\", function NotifierContainerComponent_li_2_Template_notifier_notification_ready_2_listener($event) {\n      ɵngcc0.ɵɵrestoreView(_r3);\n      const ctx_r2 = ɵngcc0.ɵɵnextContext();\n      return ɵngcc0.ɵɵresetView(ctx_r2.onNotificationReady($event));\n    })(\"dismiss\", function NotifierContainerComponent_li_2_Template_notifier_notification_dismiss_2_listener($event) {\n      ɵngcc0.ɵɵrestoreView(_r3);\n      const ctx_r4 = ɵngcc0.ɵɵnextContext();\n      return ɵngcc0.ɵɵresetView(ctx_r4.onNotificationDismiss($event));\n    });\n    ɵngcc0.ɵɵtext(3, \"\\n    \");\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵtext(4, \"\\n  \");\n    ɵngcc0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const notification_r1 = ctx.$implicit;\n    ɵngcc0.ɵɵadvance(2);\n    ɵngcc0.ɵɵproperty(\"notification\", notification_r1);\n  }\n}\nconst _c0 = function (a0) {\n  return {\n    notification: a0\n  };\n};\nfunction NotifierNotificationComponent_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementContainerStart(0, 2);\n    ɵngcc0.ɵɵtext(1, \"\\n\");\n    ɵngcc0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const ctx_r0 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r0.notification.template)(\"ngTemplateOutletContext\", ɵngcc0.ɵɵpureFunction1(2, _c0, ctx_r0.notification));\n  }\n}\nfunction NotifierNotificationComponent_ng_template_2_button_4_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r5 = ɵngcc0.ɵɵgetCurrentView();\n    ɵngcc0.ɵɵelementStart(0, \"button\", 5);\n    ɵngcc0.ɵɵlistener(\"click\", function NotifierNotificationComponent_ng_template_2_button_4_Template_button_click_0_listener() {\n      ɵngcc0.ɵɵrestoreView(_r5);\n      const ctx_r4 = ɵngcc0.ɵɵnextContext(2);\n      return ɵngcc0.ɵɵresetView(ctx_r4.onClickDismiss());\n    });\n    ɵngcc0.ɵɵtext(1, \"\\n    \");\n    ɵngcc0.ɵɵnamespaceSVG();\n    ɵngcc0.ɵɵelementStart(2, \"svg\", 6);\n    ɵngcc0.ɵɵtext(3, \"\\n      \");\n    ɵngcc0.ɵɵelement(4, \"path\", 7);\n    ɵngcc0.ɵɵtext(5, \"\\n    \");\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵtext(6, \"\\n  \");\n    ɵngcc0.ɵɵelementEnd();\n  }\n}\nfunction NotifierNotificationComponent_ng_template_2_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵtext(0, \"\\n  \");\n    ɵngcc0.ɵɵelementStart(1, \"p\", 3);\n    ɵngcc0.ɵɵtext(2);\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵtext(3, \"\\n  \");\n    ɵngcc0.ɵɵtemplate(4, NotifierNotificationComponent_ng_template_2_button_4_Template, 7, 0, \"button\", 4);\n    ɵngcc0.ɵɵtext(5, \"\\n\");\n  }\n  if (rf & 2) {\n    const ctx_r2 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵadvance(2);\n    ɵngcc0.ɵɵtextInterpolate(ctx_r2.notification.message);\n    ɵngcc0.ɵɵadvance(2);\n    ɵngcc0.ɵɵproperty(\"ngIf\", ctx_r2.config.behaviour.showDismissButton);\n  }\n}\nclass NotifierNotification {\n  /**\n   * Constructor\n   *\n   * @param options Notifier options\n   */\n  constructor(options) {\n    /**\n     * The template to customize\n     * the appearance of the notification\n     */\n    this.template = null;\n    Object.assign(this, options);\n    // If not set manually, we have to create a unique notification ID by ourselves. The ID generation relies on the current browser\n    // datetime in ms, in praticular the moment this notification gets constructed. Concurrency, and thus two IDs being the exact same,\n    // is not possible due to the action queue concept.\n    if (options.id === undefined) {\n      this.id = `ID_${new Date().getTime()}`;\n    }\n  }\n}\n\n/**\n * Notifier configuration\n *\n * The notifier configuration defines what notifications look like, how they behave, and how they get animated. It is a global\n * configuration, which means that it only can be set once (at the beginning), and cannot be changed afterwards. Aligning to the world of\n * Angular, this configuration can be provided in the root app module - alternatively, a meaningful default configuration will be used.\n */\nclass NotifierConfig {\n  /**\n   * Constructor\n   *\n   * @param [customOptions={}] Custom notifier options, optional\n   */\n  constructor(customOptions = {}) {\n    // Set default values\n    this.animations = {\n      enabled: true,\n      hide: {\n        easing: 'ease',\n        offset: 50,\n        preset: 'fade',\n        speed: 300\n      },\n      overlap: 150,\n      shift: {\n        easing: 'ease',\n        speed: 300\n      },\n      show: {\n        easing: 'ease',\n        preset: 'slide',\n        speed: 300\n      }\n    };\n    this.behaviour = {\n      autoHide: 7000,\n      onClick: false,\n      onMouseover: 'pauseAutoHide',\n      showDismissButton: true,\n      stacking: 4\n    };\n    this.position = {\n      horizontal: {\n        distance: 12,\n        position: 'left'\n      },\n      vertical: {\n        distance: 12,\n        gap: 10,\n        position: 'bottom'\n      }\n    };\n    this.theme = 'material';\n    // The following merges the custom options into the notifier config, respecting the already set default values\n    // This linear, more explicit and code-sizy workflow is preferred here over a recursive one (because we know the object structure)\n    // Technical sidenote: Objects are merged, other types of values simply overwritten / copied\n    if (customOptions.theme !== undefined) {\n      this.theme = customOptions.theme;\n    }\n    if (customOptions.animations !== undefined) {\n      if (customOptions.animations.enabled !== undefined) {\n        this.animations.enabled = customOptions.animations.enabled;\n      }\n      if (customOptions.animations.overlap !== undefined) {\n        this.animations.overlap = customOptions.animations.overlap;\n      }\n      if (customOptions.animations.hide !== undefined) {\n        Object.assign(this.animations.hide, customOptions.animations.hide);\n      }\n      if (customOptions.animations.shift !== undefined) {\n        Object.assign(this.animations.shift, customOptions.animations.shift);\n      }\n      if (customOptions.animations.show !== undefined) {\n        Object.assign(this.animations.show, customOptions.animations.show);\n      }\n    }\n    if (customOptions.behaviour !== undefined) {\n      Object.assign(this.behaviour, customOptions.behaviour);\n    }\n    if (customOptions.position !== undefined) {\n      if (customOptions.position.horizontal !== undefined) {\n        Object.assign(this.position.horizontal, customOptions.position.horizontal);\n      }\n      if (customOptions.position.vertical !== undefined) {\n        Object.assign(this.position.vertical, customOptions.position.vertical);\n      }\n    }\n  }\n}\n\n/**\n * Injection Token for notifier options\n */\nconst NotifierOptionsToken = new InjectionToken('[angular-notifier] Notifier Options');\n/**\n * Injection Token for notifier configuration\n */\nconst NotifierConfigToken = new InjectionToken('[anuglar-notifier] Notifier Config');\n\n/**\n * Notifier queue service\n *\n * In general, API calls don't get processed right away. Instead, we have to queue them up in order to prevent simultanious API calls\n * interfering with each other. This, at least in theory, is possible at any time. In particular, animations - which potentially overlap -\n * can cause changes in JS classes as well as affect the DOM. Therefore, the queue service takes all actions, puts them in a queue, and\n * processes them at the right time (which is when the previous action has been processed successfully).\n *\n * Technical sidenote:\n * An action looks pretty similar to the ones within the Flux / Redux pattern.\n */\nclass NotifierQueueService {\n  /**\n   * Constructor\n   */\n  constructor() {\n    this.actionStream = new Subject();\n    this.actionQueue = [];\n    this.isActionInProgress = false;\n  }\n  /**\n   * Push a new action to the queue, and try to run it\n   *\n   * @param action Action object\n   */\n  push(action) {\n    this.actionQueue.push(action);\n    this.tryToRunNextAction();\n  }\n  /**\n   * Continue with the next action (called when the current action is finished)\n   */\n  continue() {\n    this.isActionInProgress = false;\n    this.tryToRunNextAction();\n  }\n  /**\n   * Try to run the next action in the queue; we skip if there already is some action in progress, or if there is no action left\n   */\n  tryToRunNextAction() {\n    if (this.isActionInProgress || this.actionQueue.length === 0) {\n      return; // Skip (the queue can now go drink a coffee as it has nothing to do anymore)\n    }\n\n    this.isActionInProgress = true;\n    this.actionStream.next(this.actionQueue.shift()); // Push next action to the stream, and remove the current action from the queue\n  }\n}\n\nNotifierQueueService.ɵfac = function NotifierQueueService_Factory(t) {\n  return new (t || NotifierQueueService)();\n};\nNotifierQueueService.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n  token: NotifierQueueService,\n  factory: NotifierQueueService.ɵfac\n});\nNotifierQueueService.ctorParameters = () => [];\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NotifierQueueService, [{\n    type: Injectable\n  }], function () {\n    return [];\n  }, null);\n})();\n\n/**\n * Notifier service\n *\n * This service provides access to the public notifier API. Once injected into a component, directive, pipe, service, or any other building\n * block of an applications, it can be used to show new notifications, and hide existing ones. Internally, it transforms API calls into\n * actions, which then get thrown into the action queue - eventually being processed at the right moment.\n */\nclass NotifierService {\n  /**\n   * Constructor\n   *\n   * @param notifierQueueService Notifier queue service\n   * @param config               Notifier configuration, optionally injected as a dependency\n   */\n  constructor(notifierQueueService, config) {\n    this.queueService = notifierQueueService;\n    this.config = config;\n  }\n  /**\n   * Get the notifier configuration\n   *\n   * @returns Notifier configuration\n   */\n  getConfig() {\n    return this.config;\n  }\n  /**\n   * Get the observable for handling actions\n   *\n   * @returns Observable of NotifierAction\n   */\n  get actionStream() {\n    return this.queueService.actionStream.asObservable();\n  }\n  /**\n   * API: Show a new notification\n   *\n   * @param notificationOptions Notification options\n   */\n  show(notificationOptions) {\n    this.queueService.push({\n      payload: notificationOptions,\n      type: 'SHOW'\n    });\n  }\n  /**\n   * API: Hide a specific notification, given its ID\n   *\n   * @param notificationId ID of the notification to hide\n   */\n  hide(notificationId) {\n    this.queueService.push({\n      payload: notificationId,\n      type: 'HIDE'\n    });\n  }\n  /**\n   * API: Hide the newest notification\n   */\n  hideNewest() {\n    this.queueService.push({\n      type: 'HIDE_NEWEST'\n    });\n  }\n  /**\n   * API: Hide the oldest notification\n   */\n  hideOldest() {\n    this.queueService.push({\n      type: 'HIDE_OLDEST'\n    });\n  }\n  /**\n   * API: Hide all notifications at once\n   */\n  hideAll() {\n    this.queueService.push({\n      type: 'HIDE_ALL'\n    });\n  }\n  /**\n   * API: Shortcut for showing a new notification\n   *\n   * @param type             Type of the notification\n   * @param message          Message of the notification\n   * @param [notificationId] Unique ID for the notification (optional)\n   */\n  notify(type, message, notificationId) {\n    const notificationOptions = {\n      message,\n      type\n    };\n    if (notificationId !== undefined) {\n      notificationOptions.id = notificationId;\n    }\n    this.show(notificationOptions);\n  }\n}\nNotifierService.ɵfac = function NotifierService_Factory(t) {\n  return new (t || NotifierService)(ɵngcc0.ɵɵinject(NotifierQueueService), ɵngcc0.ɵɵinject(NotifierConfigToken));\n};\nNotifierService.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n  token: NotifierService,\n  factory: NotifierService.ɵfac\n});\nNotifierService.ctorParameters = () => [{\n  type: NotifierQueueService\n}, {\n  type: NotifierConfig,\n  decorators: [{\n    type: Inject,\n    args: [NotifierConfigToken]\n  }]\n}];\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NotifierService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: NotifierQueueService\n    }, {\n      type: NotifierConfig,\n      decorators: [{\n        type: Inject,\n        args: [NotifierConfigToken]\n      }]\n    }];\n  }, null);\n})();\n\n/**\n * Notifier container component\n * ----------------------------\n * This component acts as a wrapper for all notification components; consequently, it is responsible for creating a new notification\n * component and removing an existing notification component. Being more precicely, it also handles side effects of those actions, such as\n * shifting or even completely removing other notifications as well. Overall, this components handles actions coming from the queue service\n * by subscribing to its action stream.\n *\n * Technical sidenote:\n * This component has to be used somewhere in an application to work; it will not inject and create itself automatically, primarily in order\n * to not break the Angular AoT compilation. Moreover, this component (and also the notification components) set their change detection\n * strategy onPush, which means that we handle change detection manually in order to get the best performance. (#perfmatters)\n */\nclass NotifierContainerComponent {\n  /**\n   * Constructor\n   *\n   * @param changeDetector       Change detector, used for manually triggering change detection runs\n   * @param notifierQueueService Notifier queue service\n   * @param notifierService      Notifier service\n   */\n  constructor(changeDetector, notifierQueueService, notifierService) {\n    this.changeDetector = changeDetector;\n    this.queueService = notifierQueueService;\n    this.config = notifierService.getConfig();\n    this.notifications = [];\n    // Connects this component up to the action queue, then handle incoming actions\n    this.queueServiceSubscription = this.queueService.actionStream.subscribe(action => {\n      this.handleAction(action).then(() => {\n        this.queueService.continue();\n      });\n    });\n  }\n  /**\n   * Component destroyment lifecycle hook, cleans up the observable subsciption\n   */\n  ngOnDestroy() {\n    if (this.queueServiceSubscription) {\n      this.queueServiceSubscription.unsubscribe();\n    }\n  }\n  /**\n   * Notification identifier, used as the ngFor trackby function\n   *\n   * @param   index        Index\n   * @param   notification Notifier notification\n   * @returns Notification ID as the unique identnfier\n   */\n  identifyNotification(index, notification) {\n    return notification.id;\n  }\n  /**\n   * Event handler, handles clicks on notification dismiss buttons\n   *\n   * @param notificationId ID of the notification to dismiss\n   */\n  onNotificationDismiss(notificationId) {\n    this.queueService.push({\n      payload: notificationId,\n      type: 'HIDE'\n    });\n  }\n  /**\n   * Event handler, handles notification ready events\n   *\n   * @param notificationComponent Notification component reference\n   */\n  onNotificationReady(notificationComponent) {\n    const currentNotification = this.notifications[this.notifications.length - 1]; // Get the latest notification\n    currentNotification.component = notificationComponent; // Save the new omponent reference\n    this.continueHandleShowAction(currentNotification); // Continue with handling the show action\n  }\n  /**\n   * Handle incoming actions by mapping action types to methods, and then running them\n   *\n   * @param   action Action object\n   * @returns Promise, resolved when done\n   */\n  handleAction(action) {\n    switch (action.type // TODO: Maybe a map (actionType -> class method) is a cleaner solution here?\n    ) {\n      case 'SHOW':\n        return this.handleShowAction(action);\n      case 'HIDE':\n        return this.handleHideAction(action);\n      case 'HIDE_OLDEST':\n        return this.handleHideOldestAction(action);\n      case 'HIDE_NEWEST':\n        return this.handleHideNewestAction(action);\n      case 'HIDE_ALL':\n        return this.handleHideAllAction();\n      default:\n        return new Promise(resolve => {\n          resolve(); // Ignore unknown action types\n        });\n    }\n  }\n  /**\n   * Show a new notification\n   *\n   * We simply add the notification to the list, and then wait until its properly initialized / created / rendered.\n   *\n   * @param   action Action object\n   * @returns Promise, resolved when done\n   */\n  handleShowAction(action) {\n    return new Promise(resolve => {\n      this.tempPromiseResolver = resolve; // Save the promise resolve function so that it can be called later on by another method\n      this.addNotificationToList(new NotifierNotification(action.payload));\n    });\n  }\n  /**\n   * Continue to show a new notification (after the notification components is initialized / created / rendered).\n   *\n   * If this is the first (and thus only) notification, we can simply show it. Otherwhise, if stacking is disabled (or a low value), we\n   * switch out notifications, in particular we hide the existing one, and then show our new one. Yet, if stacking is enabled, we first\n   * shift all older notifications, and then show our new notification. In addition, if there are too many notification on the screen,\n   * we hide the oldest one first. Furthermore, if configured, animation overlapping is applied.\n   *\n   * @param notification New notification to show\n   */\n  continueHandleShowAction(notification) {\n    // First (which means only one) notification in the list?\n    const numberOfNotifications = this.notifications.length;\n    if (numberOfNotifications === 1) {\n      notification.component.show().then(this.tempPromiseResolver); // Done\n    } else {\n      const implicitStackingLimit = 2;\n      // Stacking enabled? (stacking value below 2 means stacking is disabled)\n      if (this.config.behaviour.stacking === false || this.config.behaviour.stacking < implicitStackingLimit) {\n        this.notifications[0].component.hide().then(() => {\n          this.removeNotificationFromList(this.notifications[0]);\n          notification.component.show().then(this.tempPromiseResolver); // Done\n        });\n      } else {\n        const stepPromises = [];\n        // Are there now too many notifications?\n        if (numberOfNotifications > this.config.behaviour.stacking) {\n          const oldNotifications = this.notifications.slice(1, numberOfNotifications - 1);\n          // Are animations enabled?\n          if (this.config.animations.enabled) {\n            // Is animation overlap enabled?\n            if (this.config.animations.overlap !== false && this.config.animations.overlap > 0) {\n              stepPromises.push(this.notifications[0].component.hide());\n              setTimeout(() => {\n                stepPromises.push(this.shiftNotifications(oldNotifications, notification.component.getHeight(), true));\n              }, this.config.animations.hide.speed - this.config.animations.overlap);\n              setTimeout(() => {\n                stepPromises.push(notification.component.show());\n              }, this.config.animations.hide.speed + this.config.animations.shift.speed - this.config.animations.overlap);\n            } else {\n              stepPromises.push(new Promise(resolve => {\n                this.notifications[0].component.hide().then(() => {\n                  this.shiftNotifications(oldNotifications, notification.component.getHeight(), true).then(() => {\n                    notification.component.show().then(resolve);\n                  });\n                });\n              }));\n            }\n          } else {\n            stepPromises.push(this.notifications[0].component.hide());\n            stepPromises.push(this.shiftNotifications(oldNotifications, notification.component.getHeight(), true));\n            stepPromises.push(notification.component.show());\n          }\n        } else {\n          const oldNotifications = this.notifications.slice(0, numberOfNotifications - 1);\n          // Are animations enabled?\n          if (this.config.animations.enabled) {\n            // Is animation overlap enabled?\n            if (this.config.animations.overlap !== false && this.config.animations.overlap > 0) {\n              stepPromises.push(this.shiftNotifications(oldNotifications, notification.component.getHeight(), true));\n              setTimeout(() => {\n                stepPromises.push(notification.component.show());\n              }, this.config.animations.shift.speed - this.config.animations.overlap);\n            } else {\n              stepPromises.push(new Promise(resolve => {\n                this.shiftNotifications(oldNotifications, notification.component.getHeight(), true).then(() => {\n                  notification.component.show().then(resolve);\n                });\n              }));\n            }\n          } else {\n            stepPromises.push(this.shiftNotifications(oldNotifications, notification.component.getHeight(), true));\n            stepPromises.push(notification.component.show());\n          }\n        }\n        Promise.all(stepPromises).then(() => {\n          if (numberOfNotifications > this.config.behaviour.stacking) {\n            this.removeNotificationFromList(this.notifications[0]);\n          }\n          this.tempPromiseResolver();\n        }); // Done\n      }\n    }\n  }\n  /**\n   * Hide an existing notification\n   *\n   * Fist, we skip everything if there are no notifications at all, or the given notification does not exist. Then, we hide the given\n   * notification. If there exist older notifications, we then shift them around to fill the gap. Once both hiding the given notification\n   * and shifting the older notificaitons is done, the given notification gets finally removed (from the DOM).\n   *\n   * @param   action Action object, payload contains the notification ID\n   * @returns Promise, resolved when done\n   */\n  handleHideAction(action) {\n    return new Promise(resolve => {\n      const stepPromises = [];\n      // Does the notification exist / are there even any notifications? (let's prevent accidential errors)\n      const notification = this.findNotificationById(action.payload);\n      if (notification === undefined) {\n        resolve();\n        return;\n      }\n      // Get older notifications\n      const notificationIndex = this.findNotificationIndexById(action.payload);\n      if (notificationIndex === undefined) {\n        resolve();\n        return;\n      }\n      const oldNotifications = this.notifications.slice(0, notificationIndex);\n      // Do older notifications exist, and thus do we need to shift other notifications as a consequence?\n      if (oldNotifications.length > 0) {\n        // Are animations enabled?\n        if (this.config.animations.enabled && this.config.animations.hide.speed > 0) {\n          // Is animation overlap enabled?\n          if (this.config.animations.overlap !== false && this.config.animations.overlap > 0) {\n            stepPromises.push(notification.component.hide());\n            setTimeout(() => {\n              stepPromises.push(this.shiftNotifications(oldNotifications, notification.component.getHeight(), false));\n            }, this.config.animations.hide.speed - this.config.animations.overlap);\n          } else {\n            notification.component.hide().then(() => {\n              stepPromises.push(this.shiftNotifications(oldNotifications, notification.component.getHeight(), false));\n            });\n          }\n        } else {\n          stepPromises.push(notification.component.hide());\n          stepPromises.push(this.shiftNotifications(oldNotifications, notification.component.getHeight(), false));\n        }\n      } else {\n        stepPromises.push(notification.component.hide());\n      }\n      // Wait until both hiding and shifting is done, then remove the notification from the list\n      Promise.all(stepPromises).then(() => {\n        this.removeNotificationFromList(notification);\n        resolve(); // Done\n      });\n    });\n  }\n  /**\n   * Hide the oldest notification (bridge to handleHideAction)\n   *\n   * @param   action Action object\n   * @returns Promise, resolved when done\n   */\n  handleHideOldestAction(action) {\n    // Are there any notifications? (prevent accidential errors)\n    if (this.notifications.length === 0) {\n      return new Promise(resolve => {\n        resolve();\n      }); // Done\n    } else {\n      action.payload = this.notifications[0].id;\n      return this.handleHideAction(action);\n    }\n  }\n  /**\n   * Hide the newest notification (bridge to handleHideAction)\n   *\n   * @param   action Action object\n   * @returns Promise, resolved when done\n   */\n  handleHideNewestAction(action) {\n    // Are there any notifications? (prevent accidential errors)\n    if (this.notifications.length === 0) {\n      return new Promise(resolve => {\n        resolve();\n      }); // Done\n    } else {\n      action.payload = this.notifications[this.notifications.length - 1].id;\n      return this.handleHideAction(action);\n    }\n  }\n  /**\n   * Hide all notifications at once\n   *\n   * @returns Promise, resolved when done\n   */\n  handleHideAllAction() {\n    return new Promise(resolve => {\n      // Are there any notifications? (prevent accidential errors)\n      const numberOfNotifications = this.notifications.length;\n      if (numberOfNotifications === 0) {\n        resolve(); // Done\n        return;\n      }\n      // Are animations enabled?\n      if (this.config.animations.enabled && this.config.animations.hide.speed > 0 && this.config.animations.hide.offset !== false && this.config.animations.hide.offset > 0) {\n        for (let i = numberOfNotifications - 1; i >= 0; i--) {\n          const animationOffset = this.config.position.vertical.position === 'top' ? numberOfNotifications - 1 : i;\n          setTimeout(() => {\n            this.notifications[i].component.hide().then(() => {\n              // Are we done here, was this the last notification to be hidden?\n              if (this.config.position.vertical.position === 'top' && i === 0 || this.config.position.vertical.position === 'bottom' && i === numberOfNotifications - 1) {\n                this.removeAllNotificationsFromList();\n                resolve(); // Done\n              }\n            });\n          }, this.config.animations.hide.offset * animationOffset);\n        }\n      } else {\n        const stepPromises = [];\n        for (let i = numberOfNotifications - 1; i >= 0; i--) {\n          stepPromises.push(this.notifications[i].component.hide());\n        }\n        Promise.all(stepPromises).then(() => {\n          this.removeAllNotificationsFromList();\n          resolve(); // Done\n        });\n      }\n    });\n  }\n  /**\n   * Shift multiple notifications at once\n   *\n   * @param   notifications List containing the notifications to be shifted\n   * @param   distance      Distance to shift (in px)\n   * @param   toMakePlace   Flag, defining in which direciton to shift\n   * @returns Promise, resolved when done\n   */\n  shiftNotifications(notifications, distance, toMakePlace) {\n    return new Promise(resolve => {\n      // Are there any notifications to shift?\n      if (notifications.length === 0) {\n        resolve();\n        return;\n      }\n      const notificationPromises = [];\n      for (let i = notifications.length - 1; i >= 0; i--) {\n        notificationPromises.push(notifications[i].component.shift(distance, toMakePlace));\n      }\n      Promise.all(notificationPromises).then(resolve); // Done\n    });\n  }\n  /**\n   * Add a new notification to the list of notifications (triggers change detection)\n   *\n   * @param notification Notification to add to the list of notifications\n   */\n  addNotificationToList(notification) {\n    this.notifications.push(notification);\n    this.changeDetector.markForCheck(); // Run change detection because the notification list changed\n  }\n  /**\n   * Remove an existing notification from the list of notifications (triggers change detection)\n   *\n   * @param notification Notification to be removed from the list of notifications\n   */\n  removeNotificationFromList(notification) {\n    this.notifications = this.notifications.filter(item => item.component !== notification.component);\n    this.changeDetector.markForCheck(); // Run change detection because the notification list changed\n  }\n  /**\n   * Remove all notifications from the list (triggers change detection)\n   */\n  removeAllNotificationsFromList() {\n    this.notifications = [];\n    this.changeDetector.markForCheck(); // Run change detection because the notification list changed\n  }\n  /**\n   * Helper: Find a notification in the notification list by a given notification ID\n   *\n   * @param   notificationId Notification ID, used for finding notification\n   * @returns Notification, undefined if not found\n   */\n  findNotificationById(notificationId) {\n    return this.notifications.find(currentNotification => currentNotification.id === notificationId);\n  }\n  /**\n   * Helper: Find a notification's index by a given notification ID\n   *\n   * @param   notificationId Notification ID, used for finding a notification's index\n   * @returns Notification index, undefined if not found\n   */\n  findNotificationIndexById(notificationId) {\n    const notificationIndex = this.notifications.findIndex(currentNotification => currentNotification.id === notificationId);\n    return notificationIndex !== -1 ? notificationIndex : undefined;\n  }\n}\nNotifierContainerComponent.ɵfac = function NotifierContainerComponent_Factory(t) {\n  return new (t || NotifierContainerComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(NotifierQueueService), ɵngcc0.ɵɵdirectiveInject(NotifierService));\n};\nNotifierContainerComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n  type: NotifierContainerComponent,\n  selectors: [[\"notifier-container\"]],\n  hostAttrs: [1, \"notifier__container\"],\n  decls: 5,\n  vars: 2,\n  consts: [[1, \"notifier__container-list\"], [\"class\", \"notifier__container-list-item\", 4, \"ngFor\", \"ngForOf\", \"ngForTrackBy\"], [1, \"notifier__container-list-item\"], [3, \"notification\", \"ready\", \"dismiss\"]],\n  template: function NotifierContainerComponent_Template(rf, ctx) {\n    if (rf & 1) {\n      ɵngcc0.ɵɵelementStart(0, \"ul\", 0);\n      ɵngcc0.ɵɵtext(1, \"\\n  \");\n      ɵngcc0.ɵɵtemplate(2, NotifierContainerComponent_li_2_Template, 5, 1, \"li\", 1);\n      ɵngcc0.ɵɵtext(3, \"\\n\");\n      ɵngcc0.ɵɵelementEnd();\n      ɵngcc0.ɵɵtext(4, \"\\n\");\n    }\n    if (rf & 2) {\n      ɵngcc0.ɵɵadvance(2);\n      ɵngcc0.ɵɵproperty(\"ngForOf\", ctx.notifications)(\"ngForTrackBy\", ctx.identifyNotification);\n    }\n  },\n  dependencies: function () {\n    return [ɵngcc1.NgForOf, NotifierNotificationComponent];\n  },\n  encapsulation: 2,\n  changeDetection: 0\n});\nNotifierContainerComponent.ctorParameters = () => [{\n  type: ChangeDetectorRef\n}, {\n  type: NotifierQueueService\n}, {\n  type: NotifierService\n}];\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NotifierContainerComponent, [{\n    type: Component,\n    args: [{\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      host: {\n        class: 'notifier__container'\n      },\n      selector: 'notifier-container',\n      template: \"<ul class=\\\"notifier__container-list\\\">\\n  <li class=\\\"notifier__container-list-item\\\" *ngFor=\\\"let notification of notifications; trackBy: identifyNotification\\\">\\n    <notifier-notification [notification]=\\\"notification\\\" (ready)=\\\"onNotificationReady($event)\\\" (dismiss)=\\\"onNotificationDismiss($event)\\\">\\n    </notifier-notification>\\n  </li>\\n</ul>\\n\"\n    }]\n  }], function () {\n    return [{\n      type: ɵngcc0.ChangeDetectorRef\n    }, {\n      type: NotifierQueueService\n    }, {\n      type: NotifierService\n    }];\n  }, null);\n})();\nconst ɵ0 = () => {\n    return {\n      from: {\n        opacity: '1'\n      },\n      to: {\n        opacity: '0'\n      }\n    };\n  },\n  ɵ1 = () => {\n    return {\n      from: {\n        opacity: '0'\n      },\n      to: {\n        opacity: '1'\n      }\n    };\n  };\n/**\n * Fade animation preset\n */\nconst fade = {\n  hide: ɵ0,\n  show: ɵ1\n};\nconst ɵ0$1 = notification => {\n    // Prepare variables\n    const config = notification.component.getConfig();\n    const shift = notification.component.getShift();\n    let from;\n    let to;\n    // Configure variables, depending on configuration and component\n    if (config.position.horizontal.position === 'left') {\n      from = {\n        transform: `translate3d( 0, ${shift}px, 0 )`\n      };\n      to = {\n        transform: `translate3d( calc( -100% - ${config.position.horizontal.distance}px - 10px ), ${shift}px, 0 )`\n      };\n    } else if (config.position.horizontal.position === 'right') {\n      from = {\n        transform: `translate3d( 0, ${shift}px, 0 )`\n      };\n      to = {\n        transform: `translate3d( calc( 100% + ${config.position.horizontal.distance}px + 10px ), ${shift}px, 0 )`\n      };\n    } else {\n      let horizontalPosition;\n      if (config.position.vertical.position === 'top') {\n        horizontalPosition = `calc( -100% - ${config.position.horizontal.distance}px - 10px )`;\n      } else {\n        horizontalPosition = `calc( 100% + ${config.position.horizontal.distance}px + 10px )`;\n      }\n      from = {\n        transform: `translate3d( -50%, ${shift}px, 0 )`\n      };\n      to = {\n        transform: `translate3d( -50%, ${horizontalPosition}, 0 )`\n      };\n    }\n    // Done\n    return {\n      from,\n      to\n    };\n  },\n  ɵ1$1 = notification => {\n    // Prepare variables\n    const config = notification.component.getConfig();\n    let from;\n    let to;\n    // Configure variables, depending on configuration and component\n    if (config.position.horizontal.position === 'left') {\n      from = {\n        transform: `translate3d( calc( -100% - ${config.position.horizontal.distance}px - 10px ), 0, 0 )`\n      };\n      to = {\n        transform: 'translate3d( 0, 0, 0 )'\n      };\n    } else if (config.position.horizontal.position === 'right') {\n      from = {\n        transform: `translate3d( calc( 100% + ${config.position.horizontal.distance}px + 10px ), 0, 0 )`\n      };\n      to = {\n        transform: 'translate3d( 0, 0, 0 )'\n      };\n    } else {\n      let horizontalPosition;\n      if (config.position.vertical.position === 'top') {\n        horizontalPosition = `calc( -100% - ${config.position.horizontal.distance}px - 10px )`;\n      } else {\n        horizontalPosition = `calc( 100% + ${config.position.horizontal.distance}px + 10px )`;\n      }\n      from = {\n        transform: `translate3d( -50%, ${horizontalPosition}, 0 )`\n      };\n      to = {\n        transform: 'translate3d( -50%, 0, 0 )'\n      };\n    }\n    // Done\n    return {\n      from,\n      to\n    };\n  };\n/**\n * Slide animation preset\n */\nconst slide = {\n  hide: ɵ0$1,\n  show: ɵ1$1\n};\n\n/**\n * Notifier animation service\n */\nclass NotifierAnimationService {\n  /**\n   * Constructor\n   */\n  constructor() {\n    this.animationPresets = {\n      fade,\n      slide\n    };\n  }\n  /**\n   * Get animation data\n   *\n   * This method generates all data the Web Animations API needs to animate our notification. The result depends on both the animation\n   * direction (either in or out) as well as the notifications (and its attributes) itself.\n   *\n   * @param   direction    Animation direction, either in or out\n   * @param   notification Notification the animation data should be generated for\n   * @returns Animation information\n   */\n  getAnimationData(direction, notification) {\n    // Get all necessary animation data\n    let keyframes;\n    let duration;\n    let easing;\n    if (direction === 'show') {\n      keyframes = this.animationPresets[notification.component.getConfig().animations.show.preset].show(notification);\n      duration = notification.component.getConfig().animations.show.speed;\n      easing = notification.component.getConfig().animations.show.easing;\n    } else {\n      keyframes = this.animationPresets[notification.component.getConfig().animations.hide.preset].hide(notification);\n      duration = notification.component.getConfig().animations.hide.speed;\n      easing = notification.component.getConfig().animations.hide.easing;\n    }\n    // Build and return animation data\n    return {\n      keyframes: [keyframes.from, keyframes.to],\n      options: {\n        duration,\n        easing,\n        fill: 'forwards'\n      }\n    };\n  }\n}\nNotifierAnimationService.ɵfac = function NotifierAnimationService_Factory(t) {\n  return new (t || NotifierAnimationService)();\n};\nNotifierAnimationService.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n  token: NotifierAnimationService,\n  factory: NotifierAnimationService.ɵfac\n});\nNotifierAnimationService.ctorParameters = () => [];\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NotifierAnimationService, [{\n    type: Injectable\n  }], function () {\n    return [];\n  }, null);\n})();\n\n/**\n * Notifier timer service\n *\n * This service acts as a timer, needed due to the still rather limited setTimeout JavaScript API. The timer service can start and stop a\n * timer. Furthermore, it can also pause the timer at any time, and resume later on. The timer API workd promise-based.\n */\nclass NotifierTimerService {\n  /**\n   * Constructor\n   */\n  constructor() {\n    this.now = 0;\n    this.remaining = 0;\n  }\n  /**\n   * Start (or resume) the timer\n   *\n   * @param   duration Timer duration, in ms\n   * @returns          Promise, resolved once the timer finishes\n   */\n  start(duration) {\n    return new Promise(resolve => {\n      // For the first run ...\n      this.remaining = duration;\n      // Setup, then start the timer\n      this.finishPromiseResolver = resolve;\n      this.continue();\n    });\n  }\n  /**\n   * Pause the timer\n   */\n  pause() {\n    clearTimeout(this.timerId);\n    this.remaining -= new Date().getTime() - this.now;\n  }\n  /**\n   * Continue the timer\n   */\n  continue() {\n    this.now = new Date().getTime();\n    this.timerId = window.setTimeout(() => {\n      this.finish();\n    }, this.remaining);\n  }\n  /**\n   * Stop the timer\n   */\n  stop() {\n    clearTimeout(this.timerId);\n    this.remaining = 0;\n  }\n  /**\n   * Finish up the timeout by resolving the timer promise\n   */\n  finish() {\n    this.finishPromiseResolver();\n  }\n}\nNotifierTimerService.ɵfac = function NotifierTimerService_Factory(t) {\n  return new (t || NotifierTimerService)();\n};\nNotifierTimerService.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n  token: NotifierTimerService,\n  factory: NotifierTimerService.ɵfac\n});\nNotifierTimerService.ctorParameters = () => [];\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NotifierTimerService, [{\n    type: Injectable\n  }], function () {\n    return [];\n  }, null);\n})();\n\n/**\n * Notifier notification component\n * -------------------------------\n * This component is responsible for actually displaying the notification on screen. In addition, it's able to show and hide this\n * notification, in particular to animate this notification in and out, as well as shift (move) this notification vertically around.\n * Furthermore, the notification component handles all interactions the user has with this notification / component, such as clicks and\n * mouse movements.\n */\nclass NotifierNotificationComponent {\n  /**\n   * Constructor\n   *\n   * @param elementRef               Reference to the component's element\n   * @param renderer                 Angular renderer\n   * @param notifierService          Notifier service\n   * @param notifierTimerService     Notifier timer service\n   * @param notifierAnimationService Notifier animation service\n   */\n  constructor(elementRef, renderer, notifierService, notifierTimerService, notifierAnimationService) {\n    this.config = notifierService.getConfig();\n    this.ready = new EventEmitter();\n    this.dismiss = new EventEmitter();\n    this.timerService = notifierTimerService;\n    this.animationService = notifierAnimationService;\n    this.renderer = renderer;\n    this.element = elementRef.nativeElement;\n    this.elementShift = 0;\n  }\n  /**\n   * Component after view init lifecycle hook, setts up the component and then emits the ready event\n   */\n  ngAfterViewInit() {\n    this.setup();\n    this.elementHeight = this.element.offsetHeight;\n    this.elementWidth = this.element.offsetWidth;\n    this.ready.emit(this);\n  }\n  /**\n   * Get the notifier config\n   *\n   * @returns Notifier configuration\n   */\n  getConfig() {\n    return this.config;\n  }\n  /**\n   * Get notification element height (in px)\n   *\n   * @returns Notification element height (in px)\n   */\n  getHeight() {\n    return this.elementHeight;\n  }\n  /**\n   * Get notification element width (in px)\n   *\n   * @returns Notification element height (in px)\n   */\n  getWidth() {\n    return this.elementWidth;\n  }\n  /**\n   * Get notification shift offset (in px)\n   *\n   * @returns Notification element shift offset (in px)\n   */\n  getShift() {\n    return this.elementShift;\n  }\n  /**\n   * Show (animate in) this notification\n   *\n   * @returns Promise, resolved when done\n   */\n  show() {\n    return new Promise(resolve => {\n      // Are animations enabled?\n      if (this.config.animations.enabled && this.config.animations.show.speed > 0) {\n        // Get animation data\n        const animationData = this.animationService.getAnimationData('show', this.notification);\n        // Set initial styles (styles before animation), prevents quick flicker when animation starts\n        const animatedProperties = Object.keys(animationData.keyframes[0]);\n        for (let i = animatedProperties.length - 1; i >= 0; i--) {\n          this.renderer.setStyle(this.element, animatedProperties[i], animationData.keyframes[0][animatedProperties[i]]);\n        }\n        // Animate notification in\n        this.renderer.setStyle(this.element, 'visibility', 'visible');\n        const animation = this.element.animate(animationData.keyframes, animationData.options);\n        animation.onfinish = () => {\n          this.startAutoHideTimer();\n          resolve(); // Done\n        };\n      } else {\n        // Show notification\n        this.renderer.setStyle(this.element, 'visibility', 'visible');\n        this.startAutoHideTimer();\n        resolve(); // Done\n      }\n    });\n  }\n  /**\n   * Hide (animate out) this notification\n   *\n   * @returns Promise, resolved when done\n   */\n  hide() {\n    return new Promise(resolve => {\n      this.stopAutoHideTimer();\n      // Are animations enabled?\n      if (this.config.animations.enabled && this.config.animations.hide.speed > 0) {\n        const animationData = this.animationService.getAnimationData('hide', this.notification);\n        const animation = this.element.animate(animationData.keyframes, animationData.options);\n        animation.onfinish = () => {\n          resolve(); // Done\n        };\n      } else {\n        resolve(); // Done\n      }\n    });\n  }\n  /**\n   * Shift (move) this notification\n   *\n   * @param   distance         Distance to shift (in px)\n   * @param   shiftToMakePlace Flag, defining in which direction to shift\n   * @returns Promise, resolved when done\n   */\n  shift(distance, shiftToMakePlace) {\n    return new Promise(resolve => {\n      // Calculate new position (position after the shift)\n      let newElementShift;\n      if (this.config.position.vertical.position === 'top' && shiftToMakePlace || this.config.position.vertical.position === 'bottom' && !shiftToMakePlace) {\n        newElementShift = this.elementShift + distance + this.config.position.vertical.gap;\n      } else {\n        newElementShift = this.elementShift - distance - this.config.position.vertical.gap;\n      }\n      const horizontalPosition = this.config.position.horizontal.position === 'middle' ? '-50%' : '0';\n      // Are animations enabled?\n      if (this.config.animations.enabled && this.config.animations.shift.speed > 0) {\n        const animationData = {\n          // TODO: Extract into animation service\n          keyframes: [{\n            transform: `translate3d( ${horizontalPosition}, ${this.elementShift}px, 0 )`\n          }, {\n            transform: `translate3d( ${horizontalPosition}, ${newElementShift}px, 0 )`\n          }],\n          options: {\n            duration: this.config.animations.shift.speed,\n            easing: this.config.animations.shift.easing,\n            fill: 'forwards'\n          }\n        };\n        this.elementShift = newElementShift;\n        const animation = this.element.animate(animationData.keyframes, animationData.options);\n        animation.onfinish = () => {\n          resolve(); // Done\n        };\n      } else {\n        this.renderer.setStyle(this.element, 'transform', `translate3d( ${horizontalPosition}, ${newElementShift}px, 0 )`);\n        this.elementShift = newElementShift;\n        resolve(); // Done\n      }\n    });\n  }\n  /**\n   * Handle click on dismiss button\n   */\n  onClickDismiss() {\n    this.dismiss.emit(this.notification.id);\n  }\n  /**\n   * Handle mouseover over notification area\n   */\n  onNotificationMouseover() {\n    if (this.config.behaviour.onMouseover === 'pauseAutoHide') {\n      this.pauseAutoHideTimer();\n    } else if (this.config.behaviour.onMouseover === 'resetAutoHide') {\n      this.stopAutoHideTimer();\n    }\n  }\n  /**\n   * Handle mouseout from notification area\n   */\n  onNotificationMouseout() {\n    if (this.config.behaviour.onMouseover === 'pauseAutoHide') {\n      this.continueAutoHideTimer();\n    } else if (this.config.behaviour.onMouseover === 'resetAutoHide') {\n      this.startAutoHideTimer();\n    }\n  }\n  /**\n   * Handle click on notification area\n   */\n  onNotificationClick() {\n    if (this.config.behaviour.onClick === 'hide') {\n      this.onClickDismiss();\n    }\n  }\n  /**\n   * Start the auto hide timer (if enabled)\n   */\n  startAutoHideTimer() {\n    if (this.config.behaviour.autoHide !== false && this.config.behaviour.autoHide > 0) {\n      this.timerService.start(this.config.behaviour.autoHide).then(() => {\n        this.onClickDismiss();\n      });\n    }\n  }\n  /**\n   * Pause the auto hide timer (if enabled)\n   */\n  pauseAutoHideTimer() {\n    if (this.config.behaviour.autoHide !== false && this.config.behaviour.autoHide > 0) {\n      this.timerService.pause();\n    }\n  }\n  /**\n   * Continue the auto hide timer (if enabled)\n   */\n  continueAutoHideTimer() {\n    if (this.config.behaviour.autoHide !== false && this.config.behaviour.autoHide > 0) {\n      this.timerService.continue();\n    }\n  }\n  /**\n   * Stop the auto hide timer (if enabled)\n   */\n  stopAutoHideTimer() {\n    if (this.config.behaviour.autoHide !== false && this.config.behaviour.autoHide > 0) {\n      this.timerService.stop();\n    }\n  }\n  /**\n   * Initial notification setup\n   */\n  setup() {\n    // Set start position (initially the exact same for every new notification)\n    if (this.config.position.horizontal.position === 'left') {\n      this.renderer.setStyle(this.element, 'left', `${this.config.position.horizontal.distance}px`);\n    } else if (this.config.position.horizontal.position === 'right') {\n      this.renderer.setStyle(this.element, 'right', `${this.config.position.horizontal.distance}px`);\n    } else {\n      this.renderer.setStyle(this.element, 'left', '50%');\n      // Let's get the GPU handle some work as well (#perfmatters)\n      this.renderer.setStyle(this.element, 'transform', 'translate3d( -50%, 0, 0 )');\n    }\n    if (this.config.position.vertical.position === 'top') {\n      this.renderer.setStyle(this.element, 'top', `${this.config.position.vertical.distance}px`);\n    } else {\n      this.renderer.setStyle(this.element, 'bottom', `${this.config.position.vertical.distance}px`);\n    }\n    // Add classes (responsible for visual design)\n    this.renderer.addClass(this.element, `notifier__notification--${this.notification.type}`);\n    this.renderer.addClass(this.element, `notifier__notification--${this.config.theme}`);\n  }\n}\nNotifierNotificationComponent.ɵfac = function NotifierNotificationComponent_Factory(t) {\n  return new (t || NotifierNotificationComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(NotifierService), ɵngcc0.ɵɵdirectiveInject(NotifierTimerService), ɵngcc0.ɵɵdirectiveInject(NotifierAnimationService));\n};\nNotifierNotificationComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n  type: NotifierNotificationComponent,\n  selectors: [[\"notifier-notification\"]],\n  hostAttrs: [1, \"notifier__notification\"],\n  hostBindings: function NotifierNotificationComponent_HostBindings(rf, ctx) {\n    if (rf & 1) {\n      ɵngcc0.ɵɵlistener(\"click\", function NotifierNotificationComponent_click_HostBindingHandler() {\n        return ctx.onNotificationClick();\n      })(\"mouseout\", function NotifierNotificationComponent_mouseout_HostBindingHandler() {\n        return ctx.onNotificationMouseout();\n      })(\"mouseover\", function NotifierNotificationComponent_mouseover_HostBindingHandler() {\n        return ctx.onNotificationMouseover();\n      });\n    }\n  },\n  inputs: {\n    notification: \"notification\"\n  },\n  outputs: {\n    ready: \"ready\",\n    dismiss: \"dismiss\"\n  },\n  features: [ɵngcc0.ɵɵProvidersFeature([\n  // We provide the timer to the component's local injector, so that every notification components gets its own\n  // instance of the timer service, thus running their timers independently from each other\n  NotifierTimerService])],\n  decls: 5,\n  vars: 2,\n  consts: [[3, \"ngTemplateOutlet\", \"ngTemplateOutletContext\", 4, \"ngIf\", \"ngIfElse\"], [\"predefinedNotification\", \"\"], [3, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"], [1, \"notifier__notification-message\"], [\"class\", \"notifier__notification-button\", \"type\", \"button\", \"title\", \"dismiss\", 3, \"click\", 4, \"ngIf\"], [\"type\", \"button\", \"title\", \"dismiss\", 1, \"notifier__notification-button\", 3, \"click\"], [\"viewBox\", \"0 0 24 24\", \"width\", \"20\", \"height\", \"20\", 1, \"notifier__notification-button-icon\"], [\"d\", \"M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z\"]],\n  template: function NotifierNotificationComponent_Template(rf, ctx) {\n    if (rf & 1) {\n      ɵngcc0.ɵɵtemplate(0, NotifierNotificationComponent_ng_container_0_Template, 2, 4, \"ng-container\", 0);\n      ɵngcc0.ɵɵtext(1, \"\\n\\n\");\n      ɵngcc0.ɵɵtemplate(2, NotifierNotificationComponent_ng_template_2_Template, 6, 2, \"ng-template\", null, 1, ɵngcc0.ɵɵtemplateRefExtractor);\n      ɵngcc0.ɵɵtext(4, \"\\n\");\n    }\n    if (rf & 2) {\n      const _r1 = ɵngcc0.ɵɵreference(3);\n      ɵngcc0.ɵɵproperty(\"ngIf\", ctx.notification.template)(\"ngIfElse\", _r1);\n    }\n  },\n  dependencies: [ɵngcc1.NgIf, ɵngcc1.NgTemplateOutlet],\n  encapsulation: 2,\n  changeDetection: 0\n});\nNotifierNotificationComponent.ctorParameters = () => [{\n  type: ElementRef\n}, {\n  type: Renderer2\n}, {\n  type: NotifierService\n}, {\n  type: NotifierTimerService\n}, {\n  type: NotifierAnimationService\n}];\nNotifierNotificationComponent.propDecorators = {\n  notification: [{\n    type: Input\n  }],\n  ready: [{\n    type: Output\n  }],\n  dismiss: [{\n    type: Output\n  }]\n};\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NotifierNotificationComponent, [{\n    type: Component,\n    args: [{\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      host: {\n        '(click)': 'onNotificationClick()',\n        '(mouseout)': 'onNotificationMouseout()',\n        '(mouseover)': 'onNotificationMouseover()',\n        class: 'notifier__notification'\n      },\n      providers: [\n      // We provide the timer to the component's local injector, so that every notification components gets its own\n      // instance of the timer service, thus running their timers independently from each other\n      NotifierTimerService],\n      selector: 'notifier-notification',\n      template: \"<ng-container\\n  *ngIf=\\\"notification.template; else predefinedNotification\\\"\\n  [ngTemplateOutlet]=\\\"notification.template\\\"\\n  [ngTemplateOutletContext]=\\\"{ notification: notification }\\\"\\n>\\n</ng-container>\\n\\n<ng-template #predefinedNotification>\\n  <p class=\\\"notifier__notification-message\\\">{{ notification.message }}</p>\\n  <button\\n    class=\\\"notifier__notification-button\\\"\\n    type=\\\"button\\\"\\n    title=\\\"dismiss\\\"\\n    *ngIf=\\\"config.behaviour.showDismissButton\\\"\\n    (click)=\\\"onClickDismiss()\\\"\\n  >\\n    <svg class=\\\"notifier__notification-button-icon\\\" viewBox=\\\"0 0 24 24\\\" width=\\\"20\\\" height=\\\"20\\\">\\n      <path d=\\\"M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z\\\" />\\n    </svg>\\n  </button>\\n</ng-template>\\n\"\n    }]\n  }], function () {\n    return [{\n      type: ɵngcc0.ElementRef\n    }, {\n      type: ɵngcc0.Renderer2\n    }, {\n      type: NotifierService\n    }, {\n      type: NotifierTimerService\n    }, {\n      type: NotifierAnimationService\n    }];\n  }, {\n    ready: [{\n      type: Output\n    }],\n    dismiss: [{\n      type: Output\n    }],\n    notification: [{\n      type: Input\n    }]\n  });\n})();\n\n/**\n * Factory for a notifier configuration with custom options\n *\n * Sidenote:\n * Required as Angular AoT compilation cannot handle dynamic functions; see <https://github.com/angular/angular/issues/11262>.\n *\n * @param   options - Custom notifier options\n * @returns - Notifier configuration as result\n */\nfunction notifierCustomConfigFactory(options) {\n  return new NotifierConfig(options);\n}\n/**\n * Factory for a notifier configuration with default options\n *\n * Sidenote:\n * Required as Angular AoT compilation cannot handle dynamic functions; see <https://github.com/angular/angular/issues/11262>.\n *\n * @returns - Notifier configuration as result\n */\nfunction notifierDefaultConfigFactory() {\n  return new NotifierConfig({});\n}\n/**\n * Notifier module\n */\nclass NotifierModule {\n  /**\n   * Setup the notifier module with custom providers, in this case with a custom configuration based on the givne options\n   *\n   * @param   [options={}] - Custom notifier options\n   * @returns - Notifier module with custom providers\n   */\n  static withConfig(options = {}) {\n    return {\n      ngModule: NotifierModule,\n      providers: [\n      // Provide the options itself upfront (as we need to inject them as dependencies -- see below)\n      {\n        provide: NotifierOptionsToken,\n        useValue: options\n      },\n      // Provide a custom notifier configuration, based on the given notifier options\n      {\n        deps: [NotifierOptionsToken],\n        provide: NotifierConfigToken,\n        useFactory: notifierCustomConfigFactory\n      }]\n    };\n  }\n}\nNotifierModule.ɵfac = function NotifierModule_Factory(t) {\n  return new (t || NotifierModule)();\n};\nNotifierModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n  type: NotifierModule\n});\nNotifierModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n  providers: [NotifierAnimationService, NotifierService, NotifierQueueService,\n  // Provide the default notifier configuration if just the module is imported\n  {\n    provide: NotifierConfigToken,\n    useFactory: notifierDefaultConfigFactory\n  }],\n  imports: [CommonModule]\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NotifierModule, [{\n    type: NgModule,\n    args: [{\n      declarations: [NotifierContainerComponent, NotifierNotificationComponent],\n      exports: [NotifierContainerComponent],\n      imports: [CommonModule],\n      providers: [NotifierAnimationService, NotifierService, NotifierQueueService,\n      // Provide the default notifier configuration if just the module is imported\n      {\n        provide: NotifierConfigToken,\n        useFactory: notifierDefaultConfigFactory\n      }]\n    }]\n  }], null, null);\n})();\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NotifierModule, {\n    declarations: function () {\n      return [NotifierContainerComponent, NotifierNotificationComponent];\n    },\n    imports: function () {\n      return [CommonModule];\n    },\n    exports: function () {\n      return [NotifierContainerComponent];\n    }\n  });\n})();\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { NotifierConfig, NotifierConfigToken, NotifierContainerComponent, NotifierModule, NotifierNotificationComponent, NotifierOptionsToken, NotifierService, notifierCustomConfigFactory, notifierDefaultConfigFactory, NotifierQueueService as ɵa, NotifierTimerService as ɵb, NotifierAnimationService as ɵc };","map":{"version":3,"names":["InjectionToken","Injectable","Inject","Component","ChangeDetectionStrategy","ChangeDetectorRef","EventEmitter","ElementRef","Renderer2","Input","Output","NgModule","Subject","CommonModule","ɵngcc0","ɵngcc1","NotifierContainerComponent_li_2_Template","rf","ctx","_r3","ɵɵgetCurrentView","ɵɵelementStart","ɵɵtext","ɵɵlistener","NotifierContainerComponent_li_2_Template_notifier_notification_ready_2_listener","$event","ɵɵrestoreView","ctx_r2","ɵɵnextContext","ɵɵresetView","onNotificationReady","NotifierContainerComponent_li_2_Template_notifier_notification_dismiss_2_listener","ctx_r4","onNotificationDismiss","ɵɵelementEnd","notification_r1","$implicit","ɵɵadvance","ɵɵproperty","_c0","a0","notification","NotifierNotificationComponent_ng_container_0_Template","ɵɵelementContainerStart","ɵɵelementContainerEnd","ctx_r0","template","ɵɵpureFunction1","NotifierNotificationComponent_ng_template_2_button_4_Template","_r5","NotifierNotificationComponent_ng_template_2_button_4_Template_button_click_0_listener","onClickDismiss","ɵɵnamespaceSVG","ɵɵelement","NotifierNotificationComponent_ng_template_2_Template","ɵɵtemplate","ɵɵtextInterpolate","message","config","behaviour","showDismissButton","NotifierNotification","constructor","options","Object","assign","id","undefined","Date","getTime","NotifierConfig","customOptions","animations","enabled","hide","easing","offset","preset","speed","overlap","shift","show","autoHide","onClick","onMouseover","stacking","position","horizontal","distance","vertical","gap","theme","NotifierOptionsToken","NotifierConfigToken","NotifierQueueService","actionStream","actionQueue","isActionInProgress","push","action","tryToRunNextAction","continue","length","next","ɵfac","NotifierQueueService_Factory","t","ɵprov","ɵɵdefineInjectable","token","factory","ctorParameters","ngDevMode","ɵsetClassMetadata","type","NotifierService","notifierQueueService","queueService","getConfig","asObservable","notificationOptions","payload","notificationId","hideNewest","hideOldest","hideAll","notify","NotifierService_Factory","ɵɵinject","decorators","args","NotifierContainerComponent","changeDetector","notifierService","notifications","queueServiceSubscription","subscribe","handleAction","then","ngOnDestroy","unsubscribe","identifyNotification","index","notificationComponent","currentNotification","component","continueHandleShowAction","handleShowAction","handleHideAction","handleHideOldestAction","handleHideNewestAction","handleHideAllAction","Promise","resolve","tempPromiseResolver","addNotificationToList","numberOfNotifications","implicitStackingLimit","removeNotificationFromList","stepPromises","oldNotifications","slice","setTimeout","shiftNotifications","getHeight","all","findNotificationById","notificationIndex","findNotificationIndexById","i","animationOffset","removeAllNotificationsFromList","toMakePlace","notificationPromises","markForCheck","filter","item","find","findIndex","NotifierContainerComponent_Factory","ɵɵdirectiveInject","ɵcmp","ɵɵdefineComponent","selectors","hostAttrs","decls","vars","consts","NotifierContainerComponent_Template","dependencies","NgForOf","NotifierNotificationComponent","encapsulation","changeDetection","OnPush","host","class","selector","ɵ0","from","opacity","to","ɵ1","fade","ɵ0$1","getShift","transform","horizontalPosition","ɵ1$1","slide","NotifierAnimationService","animationPresets","getAnimationData","direction","keyframes","duration","fill","NotifierAnimationService_Factory","NotifierTimerService","now","remaining","start","finishPromiseResolver","pause","clearTimeout","timerId","window","finish","stop","NotifierTimerService_Factory","elementRef","renderer","notifierTimerService","notifierAnimationService","ready","dismiss","timerService","animationService","element","nativeElement","elementShift","ngAfterViewInit","setup","elementHeight","offsetHeight","elementWidth","offsetWidth","emit","getWidth","animationData","animatedProperties","keys","setStyle","animation","animate","onfinish","startAutoHideTimer","stopAutoHideTimer","shiftToMakePlace","newElementShift","onNotificationMouseover","pauseAutoHideTimer","onNotificationMouseout","continueAutoHideTimer","onNotificationClick","addClass","NotifierNotificationComponent_Factory","hostBindings","NotifierNotificationComponent_HostBindings","NotifierNotificationComponent_click_HostBindingHandler","NotifierNotificationComponent_mouseout_HostBindingHandler","NotifierNotificationComponent_mouseover_HostBindingHandler","inputs","outputs","features","ɵɵProvidersFeature","NotifierNotificationComponent_Template","ɵɵtemplateRefExtractor","_r1","ɵɵreference","NgIf","NgTemplateOutlet","propDecorators","providers","notifierCustomConfigFactory","notifierDefaultConfigFactory","NotifierModule","withConfig","ngModule","provide","useValue","deps","useFactory","NotifierModule_Factory","ɵmod","ɵɵdefineNgModule","ɵinj","ɵɵdefineInjector","imports","declarations","exports","ngJitMode","ɵɵsetNgModuleScope","ɵa","ɵb","ɵc"],"sources":["/home/ceo/mmmm/createyourevent/node_modules/angular-notifier/__ivy_ngcc__/fesm2015/angular-notifier.js"],"sourcesContent":["import { InjectionToken, Injectable, Inject, Component, ChangeDetectionStrategy, ChangeDetectorRef, EventEmitter, ElementRef, Renderer2, Input, Output, NgModule } from '@angular/core';\nimport { Subject } from 'rxjs';\nimport { CommonModule } from '@angular/common';\n\n/**\n * Notification\n *\n * This class describes the structure of a notifiction, including all information it needs to live, and everyone else needs to work with it.\n */\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@angular/common';\n\nfunction NotifierContainerComponent_li_2_Template(rf, ctx) { if (rf & 1) {\n    const _r3 = ɵngcc0.ɵɵgetCurrentView();\n    ɵngcc0.ɵɵelementStart(0, \"li\", 2);\n    ɵngcc0.ɵɵtext(1, \"\\n    \");\n    ɵngcc0.ɵɵelementStart(2, \"notifier-notification\", 3);\n    ɵngcc0.ɵɵlistener(\"ready\", function NotifierContainerComponent_li_2_Template_notifier_notification_ready_2_listener($event) { ɵngcc0.ɵɵrestoreView(_r3); const ctx_r2 = ɵngcc0.ɵɵnextContext(); return ɵngcc0.ɵɵresetView(ctx_r2.onNotificationReady($event)); })(\"dismiss\", function NotifierContainerComponent_li_2_Template_notifier_notification_dismiss_2_listener($event) { ɵngcc0.ɵɵrestoreView(_r3); const ctx_r4 = ɵngcc0.ɵɵnextContext(); return ɵngcc0.ɵɵresetView(ctx_r4.onNotificationDismiss($event)); });\n    ɵngcc0.ɵɵtext(3, \"\\n    \");\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵtext(4, \"\\n  \");\n    ɵngcc0.ɵɵelementEnd();\n} if (rf & 2) {\n    const notification_r1 = ctx.$implicit;\n    ɵngcc0.ɵɵadvance(2);\n    ɵngcc0.ɵɵproperty(\"notification\", notification_r1);\n} }\nconst _c0 = function (a0) { return { notification: a0 }; };\nfunction NotifierNotificationComponent_ng_container_0_Template(rf, ctx) { if (rf & 1) {\n    ɵngcc0.ɵɵelementContainerStart(0, 2);\n    ɵngcc0.ɵɵtext(1, \"\\n\");\n    ɵngcc0.ɵɵelementContainerEnd();\n} if (rf & 2) {\n    const ctx_r0 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r0.notification.template)(\"ngTemplateOutletContext\", ɵngcc0.ɵɵpureFunction1(2, _c0, ctx_r0.notification));\n} }\nfunction NotifierNotificationComponent_ng_template_2_button_4_Template(rf, ctx) { if (rf & 1) {\n    const _r5 = ɵngcc0.ɵɵgetCurrentView();\n    ɵngcc0.ɵɵelementStart(0, \"button\", 5);\n    ɵngcc0.ɵɵlistener(\"click\", function NotifierNotificationComponent_ng_template_2_button_4_Template_button_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r5); const ctx_r4 = ɵngcc0.ɵɵnextContext(2); return ɵngcc0.ɵɵresetView(ctx_r4.onClickDismiss()); });\n    ɵngcc0.ɵɵtext(1, \"\\n    \");\n    ɵngcc0.ɵɵnamespaceSVG();\n    ɵngcc0.ɵɵelementStart(2, \"svg\", 6);\n    ɵngcc0.ɵɵtext(3, \"\\n      \");\n    ɵngcc0.ɵɵelement(4, \"path\", 7);\n    ɵngcc0.ɵɵtext(5, \"\\n    \");\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵtext(6, \"\\n  \");\n    ɵngcc0.ɵɵelementEnd();\n} }\nfunction NotifierNotificationComponent_ng_template_2_Template(rf, ctx) { if (rf & 1) {\n    ɵngcc0.ɵɵtext(0, \"\\n  \");\n    ɵngcc0.ɵɵelementStart(1, \"p\", 3);\n    ɵngcc0.ɵɵtext(2);\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵtext(3, \"\\n  \");\n    ɵngcc0.ɵɵtemplate(4, NotifierNotificationComponent_ng_template_2_button_4_Template, 7, 0, \"button\", 4);\n    ɵngcc0.ɵɵtext(5, \"\\n\");\n} if (rf & 2) {\n    const ctx_r2 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵadvance(2);\n    ɵngcc0.ɵɵtextInterpolate(ctx_r2.notification.message);\n    ɵngcc0.ɵɵadvance(2);\n    ɵngcc0.ɵɵproperty(\"ngIf\", ctx_r2.config.behaviour.showDismissButton);\n} }\nclass NotifierNotification {\n    /**\n     * Constructor\n     *\n     * @param options Notifier options\n     */\n    constructor(options) {\n        /**\n         * The template to customize\n         * the appearance of the notification\n         */\n        this.template = null;\n        Object.assign(this, options);\n        // If not set manually, we have to create a unique notification ID by ourselves. The ID generation relies on the current browser\n        // datetime in ms, in praticular the moment this notification gets constructed. Concurrency, and thus two IDs being the exact same,\n        // is not possible due to the action queue concept.\n        if (options.id === undefined) {\n            this.id = `ID_${new Date().getTime()}`;\n        }\n    }\n}\n\n/**\n * Notifier configuration\n *\n * The notifier configuration defines what notifications look like, how they behave, and how they get animated. It is a global\n * configuration, which means that it only can be set once (at the beginning), and cannot be changed afterwards. Aligning to the world of\n * Angular, this configuration can be provided in the root app module - alternatively, a meaningful default configuration will be used.\n */\nclass NotifierConfig {\n    /**\n     * Constructor\n     *\n     * @param [customOptions={}] Custom notifier options, optional\n     */\n    constructor(customOptions = {}) {\n        // Set default values\n        this.animations = {\n            enabled: true,\n            hide: {\n                easing: 'ease',\n                offset: 50,\n                preset: 'fade',\n                speed: 300,\n            },\n            overlap: 150,\n            shift: {\n                easing: 'ease',\n                speed: 300,\n            },\n            show: {\n                easing: 'ease',\n                preset: 'slide',\n                speed: 300,\n            },\n        };\n        this.behaviour = {\n            autoHide: 7000,\n            onClick: false,\n            onMouseover: 'pauseAutoHide',\n            showDismissButton: true,\n            stacking: 4,\n        };\n        this.position = {\n            horizontal: {\n                distance: 12,\n                position: 'left',\n            },\n            vertical: {\n                distance: 12,\n                gap: 10,\n                position: 'bottom',\n            },\n        };\n        this.theme = 'material';\n        // The following merges the custom options into the notifier config, respecting the already set default values\n        // This linear, more explicit and code-sizy workflow is preferred here over a recursive one (because we know the object structure)\n        // Technical sidenote: Objects are merged, other types of values simply overwritten / copied\n        if (customOptions.theme !== undefined) {\n            this.theme = customOptions.theme;\n        }\n        if (customOptions.animations !== undefined) {\n            if (customOptions.animations.enabled !== undefined) {\n                this.animations.enabled = customOptions.animations.enabled;\n            }\n            if (customOptions.animations.overlap !== undefined) {\n                this.animations.overlap = customOptions.animations.overlap;\n            }\n            if (customOptions.animations.hide !== undefined) {\n                Object.assign(this.animations.hide, customOptions.animations.hide);\n            }\n            if (customOptions.animations.shift !== undefined) {\n                Object.assign(this.animations.shift, customOptions.animations.shift);\n            }\n            if (customOptions.animations.show !== undefined) {\n                Object.assign(this.animations.show, customOptions.animations.show);\n            }\n        }\n        if (customOptions.behaviour !== undefined) {\n            Object.assign(this.behaviour, customOptions.behaviour);\n        }\n        if (customOptions.position !== undefined) {\n            if (customOptions.position.horizontal !== undefined) {\n                Object.assign(this.position.horizontal, customOptions.position.horizontal);\n            }\n            if (customOptions.position.vertical !== undefined) {\n                Object.assign(this.position.vertical, customOptions.position.vertical);\n            }\n        }\n    }\n}\n\n/**\n * Injection Token for notifier options\n */\nconst NotifierOptionsToken = new InjectionToken('[angular-notifier] Notifier Options');\n/**\n * Injection Token for notifier configuration\n */\nconst NotifierConfigToken = new InjectionToken('[anuglar-notifier] Notifier Config');\n\n/**\n * Notifier queue service\n *\n * In general, API calls don't get processed right away. Instead, we have to queue them up in order to prevent simultanious API calls\n * interfering with each other. This, at least in theory, is possible at any time. In particular, animations - which potentially overlap -\n * can cause changes in JS classes as well as affect the DOM. Therefore, the queue service takes all actions, puts them in a queue, and\n * processes them at the right time (which is when the previous action has been processed successfully).\n *\n * Technical sidenote:\n * An action looks pretty similar to the ones within the Flux / Redux pattern.\n */\nclass NotifierQueueService {\n    /**\n     * Constructor\n     */\n    constructor() {\n        this.actionStream = new Subject();\n        this.actionQueue = [];\n        this.isActionInProgress = false;\n    }\n    /**\n     * Push a new action to the queue, and try to run it\n     *\n     * @param action Action object\n     */\n    push(action) {\n        this.actionQueue.push(action);\n        this.tryToRunNextAction();\n    }\n    /**\n     * Continue with the next action (called when the current action is finished)\n     */\n    continue() {\n        this.isActionInProgress = false;\n        this.tryToRunNextAction();\n    }\n    /**\n     * Try to run the next action in the queue; we skip if there already is some action in progress, or if there is no action left\n     */\n    tryToRunNextAction() {\n        if (this.isActionInProgress || this.actionQueue.length === 0) {\n            return; // Skip (the queue can now go drink a coffee as it has nothing to do anymore)\n        }\n        this.isActionInProgress = true;\n        this.actionStream.next(this.actionQueue.shift()); // Push next action to the stream, and remove the current action from the queue\n    }\n}\nNotifierQueueService.ɵfac = function NotifierQueueService_Factory(t) { return new (t || NotifierQueueService)(); };\nNotifierQueueService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: NotifierQueueService, factory: NotifierQueueService.ɵfac });\nNotifierQueueService.ctorParameters = () => [];\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NotifierQueueService, [{\n        type: Injectable\n    }], function () { return []; }, null); })();\n\n/**\n * Notifier service\n *\n * This service provides access to the public notifier API. Once injected into a component, directive, pipe, service, or any other building\n * block of an applications, it can be used to show new notifications, and hide existing ones. Internally, it transforms API calls into\n * actions, which then get thrown into the action queue - eventually being processed at the right moment.\n */\nclass NotifierService {\n    /**\n     * Constructor\n     *\n     * @param notifierQueueService Notifier queue service\n     * @param config               Notifier configuration, optionally injected as a dependency\n     */\n    constructor(notifierQueueService, config) {\n        this.queueService = notifierQueueService;\n        this.config = config;\n    }\n    /**\n     * Get the notifier configuration\n     *\n     * @returns Notifier configuration\n     */\n    getConfig() {\n        return this.config;\n    }\n    /**\n     * Get the observable for handling actions\n     *\n     * @returns Observable of NotifierAction\n     */\n    get actionStream() {\n        return this.queueService.actionStream.asObservable();\n    }\n    /**\n     * API: Show a new notification\n     *\n     * @param notificationOptions Notification options\n     */\n    show(notificationOptions) {\n        this.queueService.push({\n            payload: notificationOptions,\n            type: 'SHOW',\n        });\n    }\n    /**\n     * API: Hide a specific notification, given its ID\n     *\n     * @param notificationId ID of the notification to hide\n     */\n    hide(notificationId) {\n        this.queueService.push({\n            payload: notificationId,\n            type: 'HIDE',\n        });\n    }\n    /**\n     * API: Hide the newest notification\n     */\n    hideNewest() {\n        this.queueService.push({\n            type: 'HIDE_NEWEST',\n        });\n    }\n    /**\n     * API: Hide the oldest notification\n     */\n    hideOldest() {\n        this.queueService.push({\n            type: 'HIDE_OLDEST',\n        });\n    }\n    /**\n     * API: Hide all notifications at once\n     */\n    hideAll() {\n        this.queueService.push({\n            type: 'HIDE_ALL',\n        });\n    }\n    /**\n     * API: Shortcut for showing a new notification\n     *\n     * @param type             Type of the notification\n     * @param message          Message of the notification\n     * @param [notificationId] Unique ID for the notification (optional)\n     */\n    notify(type, message, notificationId) {\n        const notificationOptions = {\n            message,\n            type,\n        };\n        if (notificationId !== undefined) {\n            notificationOptions.id = notificationId;\n        }\n        this.show(notificationOptions);\n    }\n}\nNotifierService.ɵfac = function NotifierService_Factory(t) { return new (t || NotifierService)(ɵngcc0.ɵɵinject(NotifierQueueService), ɵngcc0.ɵɵinject(NotifierConfigToken)); };\nNotifierService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: NotifierService, factory: NotifierService.ɵfac });\nNotifierService.ctorParameters = () => [\n    { type: NotifierQueueService },\n    { type: NotifierConfig, decorators: [{ type: Inject, args: [NotifierConfigToken,] }] }\n];\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NotifierService, [{\n        type: Injectable\n    }], function () { return [{ type: NotifierQueueService }, { type: NotifierConfig, decorators: [{\n                type: Inject,\n                args: [NotifierConfigToken]\n            }] }]; }, null); })();\n\n/**\n * Notifier container component\n * ----------------------------\n * This component acts as a wrapper for all notification components; consequently, it is responsible for creating a new notification\n * component and removing an existing notification component. Being more precicely, it also handles side effects of those actions, such as\n * shifting or even completely removing other notifications as well. Overall, this components handles actions coming from the queue service\n * by subscribing to its action stream.\n *\n * Technical sidenote:\n * This component has to be used somewhere in an application to work; it will not inject and create itself automatically, primarily in order\n * to not break the Angular AoT compilation. Moreover, this component (and also the notification components) set their change detection\n * strategy onPush, which means that we handle change detection manually in order to get the best performance. (#perfmatters)\n */\nclass NotifierContainerComponent {\n    /**\n     * Constructor\n     *\n     * @param changeDetector       Change detector, used for manually triggering change detection runs\n     * @param notifierQueueService Notifier queue service\n     * @param notifierService      Notifier service\n     */\n    constructor(changeDetector, notifierQueueService, notifierService) {\n        this.changeDetector = changeDetector;\n        this.queueService = notifierQueueService;\n        this.config = notifierService.getConfig();\n        this.notifications = [];\n        // Connects this component up to the action queue, then handle incoming actions\n        this.queueServiceSubscription = this.queueService.actionStream.subscribe((action) => {\n            this.handleAction(action).then(() => {\n                this.queueService.continue();\n            });\n        });\n    }\n    /**\n     * Component destroyment lifecycle hook, cleans up the observable subsciption\n     */\n    ngOnDestroy() {\n        if (this.queueServiceSubscription) {\n            this.queueServiceSubscription.unsubscribe();\n        }\n    }\n    /**\n     * Notification identifier, used as the ngFor trackby function\n     *\n     * @param   index        Index\n     * @param   notification Notifier notification\n     * @returns Notification ID as the unique identnfier\n     */\n    identifyNotification(index, notification) {\n        return notification.id;\n    }\n    /**\n     * Event handler, handles clicks on notification dismiss buttons\n     *\n     * @param notificationId ID of the notification to dismiss\n     */\n    onNotificationDismiss(notificationId) {\n        this.queueService.push({\n            payload: notificationId,\n            type: 'HIDE',\n        });\n    }\n    /**\n     * Event handler, handles notification ready events\n     *\n     * @param notificationComponent Notification component reference\n     */\n    onNotificationReady(notificationComponent) {\n        const currentNotification = this.notifications[this.notifications.length - 1]; // Get the latest notification\n        currentNotification.component = notificationComponent; // Save the new omponent reference\n        this.continueHandleShowAction(currentNotification); // Continue with handling the show action\n    }\n    /**\n     * Handle incoming actions by mapping action types to methods, and then running them\n     *\n     * @param   action Action object\n     * @returns Promise, resolved when done\n     */\n    handleAction(action) {\n        switch (action.type // TODO: Maybe a map (actionType -> class method) is a cleaner solution here?\n        ) {\n            case 'SHOW':\n                return this.handleShowAction(action);\n            case 'HIDE':\n                return this.handleHideAction(action);\n            case 'HIDE_OLDEST':\n                return this.handleHideOldestAction(action);\n            case 'HIDE_NEWEST':\n                return this.handleHideNewestAction(action);\n            case 'HIDE_ALL':\n                return this.handleHideAllAction();\n            default:\n                return new Promise((resolve) => {\n                    resolve(); // Ignore unknown action types\n                });\n        }\n    }\n    /**\n     * Show a new notification\n     *\n     * We simply add the notification to the list, and then wait until its properly initialized / created / rendered.\n     *\n     * @param   action Action object\n     * @returns Promise, resolved when done\n     */\n    handleShowAction(action) {\n        return new Promise((resolve) => {\n            this.tempPromiseResolver = resolve; // Save the promise resolve function so that it can be called later on by another method\n            this.addNotificationToList(new NotifierNotification(action.payload));\n        });\n    }\n    /**\n     * Continue to show a new notification (after the notification components is initialized / created / rendered).\n     *\n     * If this is the first (and thus only) notification, we can simply show it. Otherwhise, if stacking is disabled (or a low value), we\n     * switch out notifications, in particular we hide the existing one, and then show our new one. Yet, if stacking is enabled, we first\n     * shift all older notifications, and then show our new notification. In addition, if there are too many notification on the screen,\n     * we hide the oldest one first. Furthermore, if configured, animation overlapping is applied.\n     *\n     * @param notification New notification to show\n     */\n    continueHandleShowAction(notification) {\n        // First (which means only one) notification in the list?\n        const numberOfNotifications = this.notifications.length;\n        if (numberOfNotifications === 1) {\n            notification.component.show().then(this.tempPromiseResolver); // Done\n        }\n        else {\n            const implicitStackingLimit = 2;\n            // Stacking enabled? (stacking value below 2 means stacking is disabled)\n            if (this.config.behaviour.stacking === false || this.config.behaviour.stacking < implicitStackingLimit) {\n                this.notifications[0].component.hide().then(() => {\n                    this.removeNotificationFromList(this.notifications[0]);\n                    notification.component.show().then(this.tempPromiseResolver); // Done\n                });\n            }\n            else {\n                const stepPromises = [];\n                // Are there now too many notifications?\n                if (numberOfNotifications > this.config.behaviour.stacking) {\n                    const oldNotifications = this.notifications.slice(1, numberOfNotifications - 1);\n                    // Are animations enabled?\n                    if (this.config.animations.enabled) {\n                        // Is animation overlap enabled?\n                        if (this.config.animations.overlap !== false && this.config.animations.overlap > 0) {\n                            stepPromises.push(this.notifications[0].component.hide());\n                            setTimeout(() => {\n                                stepPromises.push(this.shiftNotifications(oldNotifications, notification.component.getHeight(), true));\n                            }, this.config.animations.hide.speed - this.config.animations.overlap);\n                            setTimeout(() => {\n                                stepPromises.push(notification.component.show());\n                            }, this.config.animations.hide.speed + this.config.animations.shift.speed - this.config.animations.overlap);\n                        }\n                        else {\n                            stepPromises.push(new Promise((resolve) => {\n                                this.notifications[0].component.hide().then(() => {\n                                    this.shiftNotifications(oldNotifications, notification.component.getHeight(), true).then(() => {\n                                        notification.component.show().then(resolve);\n                                    });\n                                });\n                            }));\n                        }\n                    }\n                    else {\n                        stepPromises.push(this.notifications[0].component.hide());\n                        stepPromises.push(this.shiftNotifications(oldNotifications, notification.component.getHeight(), true));\n                        stepPromises.push(notification.component.show());\n                    }\n                }\n                else {\n                    const oldNotifications = this.notifications.slice(0, numberOfNotifications - 1);\n                    // Are animations enabled?\n                    if (this.config.animations.enabled) {\n                        // Is animation overlap enabled?\n                        if (this.config.animations.overlap !== false && this.config.animations.overlap > 0) {\n                            stepPromises.push(this.shiftNotifications(oldNotifications, notification.component.getHeight(), true));\n                            setTimeout(() => {\n                                stepPromises.push(notification.component.show());\n                            }, this.config.animations.shift.speed - this.config.animations.overlap);\n                        }\n                        else {\n                            stepPromises.push(new Promise((resolve) => {\n                                this.shiftNotifications(oldNotifications, notification.component.getHeight(), true).then(() => {\n                                    notification.component.show().then(resolve);\n                                });\n                            }));\n                        }\n                    }\n                    else {\n                        stepPromises.push(this.shiftNotifications(oldNotifications, notification.component.getHeight(), true));\n                        stepPromises.push(notification.component.show());\n                    }\n                }\n                Promise.all(stepPromises).then(() => {\n                    if (numberOfNotifications > this.config.behaviour.stacking) {\n                        this.removeNotificationFromList(this.notifications[0]);\n                    }\n                    this.tempPromiseResolver();\n                }); // Done\n            }\n        }\n    }\n    /**\n     * Hide an existing notification\n     *\n     * Fist, we skip everything if there are no notifications at all, or the given notification does not exist. Then, we hide the given\n     * notification. If there exist older notifications, we then shift them around to fill the gap. Once both hiding the given notification\n     * and shifting the older notificaitons is done, the given notification gets finally removed (from the DOM).\n     *\n     * @param   action Action object, payload contains the notification ID\n     * @returns Promise, resolved when done\n     */\n    handleHideAction(action) {\n        return new Promise((resolve) => {\n            const stepPromises = [];\n            // Does the notification exist / are there even any notifications? (let's prevent accidential errors)\n            const notification = this.findNotificationById(action.payload);\n            if (notification === undefined) {\n                resolve();\n                return;\n            }\n            // Get older notifications\n            const notificationIndex = this.findNotificationIndexById(action.payload);\n            if (notificationIndex === undefined) {\n                resolve();\n                return;\n            }\n            const oldNotifications = this.notifications.slice(0, notificationIndex);\n            // Do older notifications exist, and thus do we need to shift other notifications as a consequence?\n            if (oldNotifications.length > 0) {\n                // Are animations enabled?\n                if (this.config.animations.enabled && this.config.animations.hide.speed > 0) {\n                    // Is animation overlap enabled?\n                    if (this.config.animations.overlap !== false && this.config.animations.overlap > 0) {\n                        stepPromises.push(notification.component.hide());\n                        setTimeout(() => {\n                            stepPromises.push(this.shiftNotifications(oldNotifications, notification.component.getHeight(), false));\n                        }, this.config.animations.hide.speed - this.config.animations.overlap);\n                    }\n                    else {\n                        notification.component.hide().then(() => {\n                            stepPromises.push(this.shiftNotifications(oldNotifications, notification.component.getHeight(), false));\n                        });\n                    }\n                }\n                else {\n                    stepPromises.push(notification.component.hide());\n                    stepPromises.push(this.shiftNotifications(oldNotifications, notification.component.getHeight(), false));\n                }\n            }\n            else {\n                stepPromises.push(notification.component.hide());\n            }\n            // Wait until both hiding and shifting is done, then remove the notification from the list\n            Promise.all(stepPromises).then(() => {\n                this.removeNotificationFromList(notification);\n                resolve(); // Done\n            });\n        });\n    }\n    /**\n     * Hide the oldest notification (bridge to handleHideAction)\n     *\n     * @param   action Action object\n     * @returns Promise, resolved when done\n     */\n    handleHideOldestAction(action) {\n        // Are there any notifications? (prevent accidential errors)\n        if (this.notifications.length === 0) {\n            return new Promise((resolve) => {\n                resolve();\n            }); // Done\n        }\n        else {\n            action.payload = this.notifications[0].id;\n            return this.handleHideAction(action);\n        }\n    }\n    /**\n     * Hide the newest notification (bridge to handleHideAction)\n     *\n     * @param   action Action object\n     * @returns Promise, resolved when done\n     */\n    handleHideNewestAction(action) {\n        // Are there any notifications? (prevent accidential errors)\n        if (this.notifications.length === 0) {\n            return new Promise((resolve) => {\n                resolve();\n            }); // Done\n        }\n        else {\n            action.payload = this.notifications[this.notifications.length - 1].id;\n            return this.handleHideAction(action);\n        }\n    }\n    /**\n     * Hide all notifications at once\n     *\n     * @returns Promise, resolved when done\n     */\n    handleHideAllAction() {\n        return new Promise((resolve) => {\n            // Are there any notifications? (prevent accidential errors)\n            const numberOfNotifications = this.notifications.length;\n            if (numberOfNotifications === 0) {\n                resolve(); // Done\n                return;\n            }\n            // Are animations enabled?\n            if (this.config.animations.enabled &&\n                this.config.animations.hide.speed > 0 &&\n                this.config.animations.hide.offset !== false &&\n                this.config.animations.hide.offset > 0) {\n                for (let i = numberOfNotifications - 1; i >= 0; i--) {\n                    const animationOffset = this.config.position.vertical.position === 'top' ? numberOfNotifications - 1 : i;\n                    setTimeout(() => {\n                        this.notifications[i].component.hide().then(() => {\n                            // Are we done here, was this the last notification to be hidden?\n                            if ((this.config.position.vertical.position === 'top' && i === 0) ||\n                                (this.config.position.vertical.position === 'bottom' && i === numberOfNotifications - 1)) {\n                                this.removeAllNotificationsFromList();\n                                resolve(); // Done\n                            }\n                        });\n                    }, this.config.animations.hide.offset * animationOffset);\n                }\n            }\n            else {\n                const stepPromises = [];\n                for (let i = numberOfNotifications - 1; i >= 0; i--) {\n                    stepPromises.push(this.notifications[i].component.hide());\n                }\n                Promise.all(stepPromises).then(() => {\n                    this.removeAllNotificationsFromList();\n                    resolve(); // Done\n                });\n            }\n        });\n    }\n    /**\n     * Shift multiple notifications at once\n     *\n     * @param   notifications List containing the notifications to be shifted\n     * @param   distance      Distance to shift (in px)\n     * @param   toMakePlace   Flag, defining in which direciton to shift\n     * @returns Promise, resolved when done\n     */\n    shiftNotifications(notifications, distance, toMakePlace) {\n        return new Promise((resolve) => {\n            // Are there any notifications to shift?\n            if (notifications.length === 0) {\n                resolve();\n                return;\n            }\n            const notificationPromises = [];\n            for (let i = notifications.length - 1; i >= 0; i--) {\n                notificationPromises.push(notifications[i].component.shift(distance, toMakePlace));\n            }\n            Promise.all(notificationPromises).then(resolve); // Done\n        });\n    }\n    /**\n     * Add a new notification to the list of notifications (triggers change detection)\n     *\n     * @param notification Notification to add to the list of notifications\n     */\n    addNotificationToList(notification) {\n        this.notifications.push(notification);\n        this.changeDetector.markForCheck(); // Run change detection because the notification list changed\n    }\n    /**\n     * Remove an existing notification from the list of notifications (triggers change detection)\n     *\n     * @param notification Notification to be removed from the list of notifications\n     */\n    removeNotificationFromList(notification) {\n        this.notifications = this.notifications.filter((item) => item.component !== notification.component);\n        this.changeDetector.markForCheck(); // Run change detection because the notification list changed\n    }\n    /**\n     * Remove all notifications from the list (triggers change detection)\n     */\n    removeAllNotificationsFromList() {\n        this.notifications = [];\n        this.changeDetector.markForCheck(); // Run change detection because the notification list changed\n    }\n    /**\n     * Helper: Find a notification in the notification list by a given notification ID\n     *\n     * @param   notificationId Notification ID, used for finding notification\n     * @returns Notification, undefined if not found\n     */\n    findNotificationById(notificationId) {\n        return this.notifications.find((currentNotification) => currentNotification.id === notificationId);\n    }\n    /**\n     * Helper: Find a notification's index by a given notification ID\n     *\n     * @param   notificationId Notification ID, used for finding a notification's index\n     * @returns Notification index, undefined if not found\n     */\n    findNotificationIndexById(notificationId) {\n        const notificationIndex = this.notifications.findIndex((currentNotification) => currentNotification.id === notificationId);\n        return notificationIndex !== -1 ? notificationIndex : undefined;\n    }\n}\nNotifierContainerComponent.ɵfac = function NotifierContainerComponent_Factory(t) { return new (t || NotifierContainerComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(NotifierQueueService), ɵngcc0.ɵɵdirectiveInject(NotifierService)); };\nNotifierContainerComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: NotifierContainerComponent, selectors: [[\"notifier-container\"]], hostAttrs: [1, \"notifier__container\"], decls: 5, vars: 2, consts: [[1, \"notifier__container-list\"], [\"class\", \"notifier__container-list-item\", 4, \"ngFor\", \"ngForOf\", \"ngForTrackBy\"], [1, \"notifier__container-list-item\"], [3, \"notification\", \"ready\", \"dismiss\"]], template: function NotifierContainerComponent_Template(rf, ctx) { if (rf & 1) {\n        ɵngcc0.ɵɵelementStart(0, \"ul\", 0);\n        ɵngcc0.ɵɵtext(1, \"\\n  \");\n        ɵngcc0.ɵɵtemplate(2, NotifierContainerComponent_li_2_Template, 5, 1, \"li\", 1);\n        ɵngcc0.ɵɵtext(3, \"\\n\");\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵtext(4, \"\\n\");\n    } if (rf & 2) {\n        ɵngcc0.ɵɵadvance(2);\n        ɵngcc0.ɵɵproperty(\"ngForOf\", ctx.notifications)(\"ngForTrackBy\", ctx.identifyNotification);\n    } }, dependencies: function () { return [ɵngcc1.NgForOf, NotifierNotificationComponent]; }, encapsulation: 2, changeDetection: 0 });\nNotifierContainerComponent.ctorParameters = () => [\n    { type: ChangeDetectorRef },\n    { type: NotifierQueueService },\n    { type: NotifierService }\n];\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NotifierContainerComponent, [{\n        type: Component,\n        args: [{\n                changeDetection: ChangeDetectionStrategy.OnPush,\n                host: {\n                    class: 'notifier__container'\n                },\n                selector: 'notifier-container',\n                template: \"<ul class=\\\"notifier__container-list\\\">\\n  <li class=\\\"notifier__container-list-item\\\" *ngFor=\\\"let notification of notifications; trackBy: identifyNotification\\\">\\n    <notifier-notification [notification]=\\\"notification\\\" (ready)=\\\"onNotificationReady($event)\\\" (dismiss)=\\\"onNotificationDismiss($event)\\\">\\n    </notifier-notification>\\n  </li>\\n</ul>\\n\"\n            }]\n    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: NotifierQueueService }, { type: NotifierService }]; }, null); })();\n\nconst ɵ0 = () => {\n    return {\n        from: {\n            opacity: '1',\n        },\n        to: {\n            opacity: '0',\n        },\n    };\n}, ɵ1 = () => {\n    return {\n        from: {\n            opacity: '0',\n        },\n        to: {\n            opacity: '1',\n        },\n    };\n};\n/**\n * Fade animation preset\n */\nconst fade = {\n    hide: ɵ0,\n    show: ɵ1,\n};\n\nconst ɵ0$1 = (notification) => {\n    // Prepare variables\n    const config = notification.component.getConfig();\n    const shift = notification.component.getShift();\n    let from;\n    let to;\n    // Configure variables, depending on configuration and component\n    if (config.position.horizontal.position === 'left') {\n        from = {\n            transform: `translate3d( 0, ${shift}px, 0 )`,\n        };\n        to = {\n            transform: `translate3d( calc( -100% - ${config.position.horizontal.distance}px - 10px ), ${shift}px, 0 )`,\n        };\n    }\n    else if (config.position.horizontal.position === 'right') {\n        from = {\n            transform: `translate3d( 0, ${shift}px, 0 )`,\n        };\n        to = {\n            transform: `translate3d( calc( 100% + ${config.position.horizontal.distance}px + 10px ), ${shift}px, 0 )`,\n        };\n    }\n    else {\n        let horizontalPosition;\n        if (config.position.vertical.position === 'top') {\n            horizontalPosition = `calc( -100% - ${config.position.horizontal.distance}px - 10px )`;\n        }\n        else {\n            horizontalPosition = `calc( 100% + ${config.position.horizontal.distance}px + 10px )`;\n        }\n        from = {\n            transform: `translate3d( -50%, ${shift}px, 0 )`,\n        };\n        to = {\n            transform: `translate3d( -50%, ${horizontalPosition}, 0 )`,\n        };\n    }\n    // Done\n    return {\n        from,\n        to,\n    };\n}, ɵ1$1 = (notification) => {\n    // Prepare variables\n    const config = notification.component.getConfig();\n    let from;\n    let to;\n    // Configure variables, depending on configuration and component\n    if (config.position.horizontal.position === 'left') {\n        from = {\n            transform: `translate3d( calc( -100% - ${config.position.horizontal.distance}px - 10px ), 0, 0 )`,\n        };\n        to = {\n            transform: 'translate3d( 0, 0, 0 )',\n        };\n    }\n    else if (config.position.horizontal.position === 'right') {\n        from = {\n            transform: `translate3d( calc( 100% + ${config.position.horizontal.distance}px + 10px ), 0, 0 )`,\n        };\n        to = {\n            transform: 'translate3d( 0, 0, 0 )',\n        };\n    }\n    else {\n        let horizontalPosition;\n        if (config.position.vertical.position === 'top') {\n            horizontalPosition = `calc( -100% - ${config.position.horizontal.distance}px - 10px )`;\n        }\n        else {\n            horizontalPosition = `calc( 100% + ${config.position.horizontal.distance}px + 10px )`;\n        }\n        from = {\n            transform: `translate3d( -50%, ${horizontalPosition}, 0 )`,\n        };\n        to = {\n            transform: 'translate3d( -50%, 0, 0 )',\n        };\n    }\n    // Done\n    return {\n        from,\n        to,\n    };\n};\n/**\n * Slide animation preset\n */\nconst slide = {\n    hide: ɵ0$1,\n    show: ɵ1$1,\n};\n\n/**\n * Notifier animation service\n */\nclass NotifierAnimationService {\n    /**\n     * Constructor\n     */\n    constructor() {\n        this.animationPresets = {\n            fade,\n            slide,\n        };\n    }\n    /**\n     * Get animation data\n     *\n     * This method generates all data the Web Animations API needs to animate our notification. The result depends on both the animation\n     * direction (either in or out) as well as the notifications (and its attributes) itself.\n     *\n     * @param   direction    Animation direction, either in or out\n     * @param   notification Notification the animation data should be generated for\n     * @returns Animation information\n     */\n    getAnimationData(direction, notification) {\n        // Get all necessary animation data\n        let keyframes;\n        let duration;\n        let easing;\n        if (direction === 'show') {\n            keyframes = this.animationPresets[notification.component.getConfig().animations.show.preset].show(notification);\n            duration = notification.component.getConfig().animations.show.speed;\n            easing = notification.component.getConfig().animations.show.easing;\n        }\n        else {\n            keyframes = this.animationPresets[notification.component.getConfig().animations.hide.preset].hide(notification);\n            duration = notification.component.getConfig().animations.hide.speed;\n            easing = notification.component.getConfig().animations.hide.easing;\n        }\n        // Build and return animation data\n        return {\n            keyframes: [keyframes.from, keyframes.to],\n            options: {\n                duration,\n                easing,\n                fill: 'forwards',\n            },\n        };\n    }\n}\nNotifierAnimationService.ɵfac = function NotifierAnimationService_Factory(t) { return new (t || NotifierAnimationService)(); };\nNotifierAnimationService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: NotifierAnimationService, factory: NotifierAnimationService.ɵfac });\nNotifierAnimationService.ctorParameters = () => [];\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NotifierAnimationService, [{\n        type: Injectable\n    }], function () { return []; }, null); })();\n\n/**\n * Notifier timer service\n *\n * This service acts as a timer, needed due to the still rather limited setTimeout JavaScript API. The timer service can start and stop a\n * timer. Furthermore, it can also pause the timer at any time, and resume later on. The timer API workd promise-based.\n */\nclass NotifierTimerService {\n    /**\n     * Constructor\n     */\n    constructor() {\n        this.now = 0;\n        this.remaining = 0;\n    }\n    /**\n     * Start (or resume) the timer\n     *\n     * @param   duration Timer duration, in ms\n     * @returns          Promise, resolved once the timer finishes\n     */\n    start(duration) {\n        return new Promise((resolve) => {\n            // For the first run ...\n            this.remaining = duration;\n            // Setup, then start the timer\n            this.finishPromiseResolver = resolve;\n            this.continue();\n        });\n    }\n    /**\n     * Pause the timer\n     */\n    pause() {\n        clearTimeout(this.timerId);\n        this.remaining -= new Date().getTime() - this.now;\n    }\n    /**\n     * Continue the timer\n     */\n    continue() {\n        this.now = new Date().getTime();\n        this.timerId = window.setTimeout(() => {\n            this.finish();\n        }, this.remaining);\n    }\n    /**\n     * Stop the timer\n     */\n    stop() {\n        clearTimeout(this.timerId);\n        this.remaining = 0;\n    }\n    /**\n     * Finish up the timeout by resolving the timer promise\n     */\n    finish() {\n        this.finishPromiseResolver();\n    }\n}\nNotifierTimerService.ɵfac = function NotifierTimerService_Factory(t) { return new (t || NotifierTimerService)(); };\nNotifierTimerService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: NotifierTimerService, factory: NotifierTimerService.ɵfac });\nNotifierTimerService.ctorParameters = () => [];\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NotifierTimerService, [{\n        type: Injectable\n    }], function () { return []; }, null); })();\n\n/**\n * Notifier notification component\n * -------------------------------\n * This component is responsible for actually displaying the notification on screen. In addition, it's able to show and hide this\n * notification, in particular to animate this notification in and out, as well as shift (move) this notification vertically around.\n * Furthermore, the notification component handles all interactions the user has with this notification / component, such as clicks and\n * mouse movements.\n */\nclass NotifierNotificationComponent {\n    /**\n     * Constructor\n     *\n     * @param elementRef               Reference to the component's element\n     * @param renderer                 Angular renderer\n     * @param notifierService          Notifier service\n     * @param notifierTimerService     Notifier timer service\n     * @param notifierAnimationService Notifier animation service\n     */\n    constructor(elementRef, renderer, notifierService, notifierTimerService, notifierAnimationService) {\n        this.config = notifierService.getConfig();\n        this.ready = new EventEmitter();\n        this.dismiss = new EventEmitter();\n        this.timerService = notifierTimerService;\n        this.animationService = notifierAnimationService;\n        this.renderer = renderer;\n        this.element = elementRef.nativeElement;\n        this.elementShift = 0;\n    }\n    /**\n     * Component after view init lifecycle hook, setts up the component and then emits the ready event\n     */\n    ngAfterViewInit() {\n        this.setup();\n        this.elementHeight = this.element.offsetHeight;\n        this.elementWidth = this.element.offsetWidth;\n        this.ready.emit(this);\n    }\n    /**\n     * Get the notifier config\n     *\n     * @returns Notifier configuration\n     */\n    getConfig() {\n        return this.config;\n    }\n    /**\n     * Get notification element height (in px)\n     *\n     * @returns Notification element height (in px)\n     */\n    getHeight() {\n        return this.elementHeight;\n    }\n    /**\n     * Get notification element width (in px)\n     *\n     * @returns Notification element height (in px)\n     */\n    getWidth() {\n        return this.elementWidth;\n    }\n    /**\n     * Get notification shift offset (in px)\n     *\n     * @returns Notification element shift offset (in px)\n     */\n    getShift() {\n        return this.elementShift;\n    }\n    /**\n     * Show (animate in) this notification\n     *\n     * @returns Promise, resolved when done\n     */\n    show() {\n        return new Promise((resolve) => {\n            // Are animations enabled?\n            if (this.config.animations.enabled && this.config.animations.show.speed > 0) {\n                // Get animation data\n                const animationData = this.animationService.getAnimationData('show', this.notification);\n                // Set initial styles (styles before animation), prevents quick flicker when animation starts\n                const animatedProperties = Object.keys(animationData.keyframes[0]);\n                for (let i = animatedProperties.length - 1; i >= 0; i--) {\n                    this.renderer.setStyle(this.element, animatedProperties[i], animationData.keyframes[0][animatedProperties[i]]);\n                }\n                // Animate notification in\n                this.renderer.setStyle(this.element, 'visibility', 'visible');\n                const animation = this.element.animate(animationData.keyframes, animationData.options);\n                animation.onfinish = () => {\n                    this.startAutoHideTimer();\n                    resolve(); // Done\n                };\n            }\n            else {\n                // Show notification\n                this.renderer.setStyle(this.element, 'visibility', 'visible');\n                this.startAutoHideTimer();\n                resolve(); // Done\n            }\n        });\n    }\n    /**\n     * Hide (animate out) this notification\n     *\n     * @returns Promise, resolved when done\n     */\n    hide() {\n        return new Promise((resolve) => {\n            this.stopAutoHideTimer();\n            // Are animations enabled?\n            if (this.config.animations.enabled && this.config.animations.hide.speed > 0) {\n                const animationData = this.animationService.getAnimationData('hide', this.notification);\n                const animation = this.element.animate(animationData.keyframes, animationData.options);\n                animation.onfinish = () => {\n                    resolve(); // Done\n                };\n            }\n            else {\n                resolve(); // Done\n            }\n        });\n    }\n    /**\n     * Shift (move) this notification\n     *\n     * @param   distance         Distance to shift (in px)\n     * @param   shiftToMakePlace Flag, defining in which direction to shift\n     * @returns Promise, resolved when done\n     */\n    shift(distance, shiftToMakePlace) {\n        return new Promise((resolve) => {\n            // Calculate new position (position after the shift)\n            let newElementShift;\n            if ((this.config.position.vertical.position === 'top' && shiftToMakePlace) ||\n                (this.config.position.vertical.position === 'bottom' && !shiftToMakePlace)) {\n                newElementShift = this.elementShift + distance + this.config.position.vertical.gap;\n            }\n            else {\n                newElementShift = this.elementShift - distance - this.config.position.vertical.gap;\n            }\n            const horizontalPosition = this.config.position.horizontal.position === 'middle' ? '-50%' : '0';\n            // Are animations enabled?\n            if (this.config.animations.enabled && this.config.animations.shift.speed > 0) {\n                const animationData = {\n                    // TODO: Extract into animation service\n                    keyframes: [\n                        {\n                            transform: `translate3d( ${horizontalPosition}, ${this.elementShift}px, 0 )`,\n                        },\n                        {\n                            transform: `translate3d( ${horizontalPosition}, ${newElementShift}px, 0 )`,\n                        },\n                    ],\n                    options: {\n                        duration: this.config.animations.shift.speed,\n                        easing: this.config.animations.shift.easing,\n                        fill: 'forwards',\n                    },\n                };\n                this.elementShift = newElementShift;\n                const animation = this.element.animate(animationData.keyframes, animationData.options);\n                animation.onfinish = () => {\n                    resolve(); // Done\n                };\n            }\n            else {\n                this.renderer.setStyle(this.element, 'transform', `translate3d( ${horizontalPosition}, ${newElementShift}px, 0 )`);\n                this.elementShift = newElementShift;\n                resolve(); // Done\n            }\n        });\n    }\n    /**\n     * Handle click on dismiss button\n     */\n    onClickDismiss() {\n        this.dismiss.emit(this.notification.id);\n    }\n    /**\n     * Handle mouseover over notification area\n     */\n    onNotificationMouseover() {\n        if (this.config.behaviour.onMouseover === 'pauseAutoHide') {\n            this.pauseAutoHideTimer();\n        }\n        else if (this.config.behaviour.onMouseover === 'resetAutoHide') {\n            this.stopAutoHideTimer();\n        }\n    }\n    /**\n     * Handle mouseout from notification area\n     */\n    onNotificationMouseout() {\n        if (this.config.behaviour.onMouseover === 'pauseAutoHide') {\n            this.continueAutoHideTimer();\n        }\n        else if (this.config.behaviour.onMouseover === 'resetAutoHide') {\n            this.startAutoHideTimer();\n        }\n    }\n    /**\n     * Handle click on notification area\n     */\n    onNotificationClick() {\n        if (this.config.behaviour.onClick === 'hide') {\n            this.onClickDismiss();\n        }\n    }\n    /**\n     * Start the auto hide timer (if enabled)\n     */\n    startAutoHideTimer() {\n        if (this.config.behaviour.autoHide !== false && this.config.behaviour.autoHide > 0) {\n            this.timerService.start(this.config.behaviour.autoHide).then(() => {\n                this.onClickDismiss();\n            });\n        }\n    }\n    /**\n     * Pause the auto hide timer (if enabled)\n     */\n    pauseAutoHideTimer() {\n        if (this.config.behaviour.autoHide !== false && this.config.behaviour.autoHide > 0) {\n            this.timerService.pause();\n        }\n    }\n    /**\n     * Continue the auto hide timer (if enabled)\n     */\n    continueAutoHideTimer() {\n        if (this.config.behaviour.autoHide !== false && this.config.behaviour.autoHide > 0) {\n            this.timerService.continue();\n        }\n    }\n    /**\n     * Stop the auto hide timer (if enabled)\n     */\n    stopAutoHideTimer() {\n        if (this.config.behaviour.autoHide !== false && this.config.behaviour.autoHide > 0) {\n            this.timerService.stop();\n        }\n    }\n    /**\n     * Initial notification setup\n     */\n    setup() {\n        // Set start position (initially the exact same for every new notification)\n        if (this.config.position.horizontal.position === 'left') {\n            this.renderer.setStyle(this.element, 'left', `${this.config.position.horizontal.distance}px`);\n        }\n        else if (this.config.position.horizontal.position === 'right') {\n            this.renderer.setStyle(this.element, 'right', `${this.config.position.horizontal.distance}px`);\n        }\n        else {\n            this.renderer.setStyle(this.element, 'left', '50%');\n            // Let's get the GPU handle some work as well (#perfmatters)\n            this.renderer.setStyle(this.element, 'transform', 'translate3d( -50%, 0, 0 )');\n        }\n        if (this.config.position.vertical.position === 'top') {\n            this.renderer.setStyle(this.element, 'top', `${this.config.position.vertical.distance}px`);\n        }\n        else {\n            this.renderer.setStyle(this.element, 'bottom', `${this.config.position.vertical.distance}px`);\n        }\n        // Add classes (responsible for visual design)\n        this.renderer.addClass(this.element, `notifier__notification--${this.notification.type}`);\n        this.renderer.addClass(this.element, `notifier__notification--${this.config.theme}`);\n    }\n}\nNotifierNotificationComponent.ɵfac = function NotifierNotificationComponent_Factory(t) { return new (t || NotifierNotificationComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(NotifierService), ɵngcc0.ɵɵdirectiveInject(NotifierTimerService), ɵngcc0.ɵɵdirectiveInject(NotifierAnimationService)); };\nNotifierNotificationComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: NotifierNotificationComponent, selectors: [[\"notifier-notification\"]], hostAttrs: [1, \"notifier__notification\"], hostBindings: function NotifierNotificationComponent_HostBindings(rf, ctx) { if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"click\", function NotifierNotificationComponent_click_HostBindingHandler() { return ctx.onNotificationClick(); })(\"mouseout\", function NotifierNotificationComponent_mouseout_HostBindingHandler() { return ctx.onNotificationMouseout(); })(\"mouseover\", function NotifierNotificationComponent_mouseover_HostBindingHandler() { return ctx.onNotificationMouseover(); });\n    } }, inputs: { notification: \"notification\" }, outputs: { ready: \"ready\", dismiss: \"dismiss\" }, features: [ɵngcc0.ɵɵProvidersFeature([\n            // We provide the timer to the component's local injector, so that every notification components gets its own\n            // instance of the timer service, thus running their timers independently from each other\n            NotifierTimerService,\n        ])], decls: 5, vars: 2, consts: [[3, \"ngTemplateOutlet\", \"ngTemplateOutletContext\", 4, \"ngIf\", \"ngIfElse\"], [\"predefinedNotification\", \"\"], [3, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"], [1, \"notifier__notification-message\"], [\"class\", \"notifier__notification-button\", \"type\", \"button\", \"title\", \"dismiss\", 3, \"click\", 4, \"ngIf\"], [\"type\", \"button\", \"title\", \"dismiss\", 1, \"notifier__notification-button\", 3, \"click\"], [\"viewBox\", \"0 0 24 24\", \"width\", \"20\", \"height\", \"20\", 1, \"notifier__notification-button-icon\"], [\"d\", \"M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z\"]], template: function NotifierNotificationComponent_Template(rf, ctx) { if (rf & 1) {\n        ɵngcc0.ɵɵtemplate(0, NotifierNotificationComponent_ng_container_0_Template, 2, 4, \"ng-container\", 0);\n        ɵngcc0.ɵɵtext(1, \"\\n\\n\");\n        ɵngcc0.ɵɵtemplate(2, NotifierNotificationComponent_ng_template_2_Template, 6, 2, \"ng-template\", null, 1, ɵngcc0.ɵɵtemplateRefExtractor);\n        ɵngcc0.ɵɵtext(4, \"\\n\");\n    } if (rf & 2) {\n        const _r1 = ɵngcc0.ɵɵreference(3);\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.notification.template)(\"ngIfElse\", _r1);\n    } }, dependencies: [ɵngcc1.NgIf, ɵngcc1.NgTemplateOutlet], encapsulation: 2, changeDetection: 0 });\nNotifierNotificationComponent.ctorParameters = () => [\n    { type: ElementRef },\n    { type: Renderer2 },\n    { type: NotifierService },\n    { type: NotifierTimerService },\n    { type: NotifierAnimationService }\n];\nNotifierNotificationComponent.propDecorators = {\n    notification: [{ type: Input }],\n    ready: [{ type: Output }],\n    dismiss: [{ type: Output }]\n};\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NotifierNotificationComponent, [{\n        type: Component,\n        args: [{\n                changeDetection: ChangeDetectionStrategy.OnPush,\n                host: {\n                    '(click)': 'onNotificationClick()',\n                    '(mouseout)': 'onNotificationMouseout()',\n                    '(mouseover)': 'onNotificationMouseover()',\n                    class: 'notifier__notification'\n                },\n                providers: [\n                    // We provide the timer to the component's local injector, so that every notification components gets its own\n                    // instance of the timer service, thus running their timers independently from each other\n                    NotifierTimerService,\n                ],\n                selector: 'notifier-notification',\n                template: \"<ng-container\\n  *ngIf=\\\"notification.template; else predefinedNotification\\\"\\n  [ngTemplateOutlet]=\\\"notification.template\\\"\\n  [ngTemplateOutletContext]=\\\"{ notification: notification }\\\"\\n>\\n</ng-container>\\n\\n<ng-template #predefinedNotification>\\n  <p class=\\\"notifier__notification-message\\\">{{ notification.message }}</p>\\n  <button\\n    class=\\\"notifier__notification-button\\\"\\n    type=\\\"button\\\"\\n    title=\\\"dismiss\\\"\\n    *ngIf=\\\"config.behaviour.showDismissButton\\\"\\n    (click)=\\\"onClickDismiss()\\\"\\n  >\\n    <svg class=\\\"notifier__notification-button-icon\\\" viewBox=\\\"0 0 24 24\\\" width=\\\"20\\\" height=\\\"20\\\">\\n      <path d=\\\"M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z\\\" />\\n    </svg>\\n  </button>\\n</ng-template>\\n\"\n            }]\n    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: NotifierService }, { type: NotifierTimerService }, { type: NotifierAnimationService }]; }, { ready: [{\n            type: Output\n        }], dismiss: [{\n            type: Output\n        }], notification: [{\n            type: Input\n        }] }); })();\n\n/**\n * Factory for a notifier configuration with custom options\n *\n * Sidenote:\n * Required as Angular AoT compilation cannot handle dynamic functions; see <https://github.com/angular/angular/issues/11262>.\n *\n * @param   options - Custom notifier options\n * @returns - Notifier configuration as result\n */\nfunction notifierCustomConfigFactory(options) {\n    return new NotifierConfig(options);\n}\n/**\n * Factory for a notifier configuration with default options\n *\n * Sidenote:\n * Required as Angular AoT compilation cannot handle dynamic functions; see <https://github.com/angular/angular/issues/11262>.\n *\n * @returns - Notifier configuration as result\n */\nfunction notifierDefaultConfigFactory() {\n    return new NotifierConfig({});\n}\n/**\n * Notifier module\n */\nclass NotifierModule {\n    /**\n     * Setup the notifier module with custom providers, in this case with a custom configuration based on the givne options\n     *\n     * @param   [options={}] - Custom notifier options\n     * @returns - Notifier module with custom providers\n     */\n    static withConfig(options = {}) {\n        return {\n            ngModule: NotifierModule,\n            providers: [\n                // Provide the options itself upfront (as we need to inject them as dependencies -- see below)\n                {\n                    provide: NotifierOptionsToken,\n                    useValue: options,\n                },\n                // Provide a custom notifier configuration, based on the given notifier options\n                {\n                    deps: [NotifierOptionsToken],\n                    provide: NotifierConfigToken,\n                    useFactory: notifierCustomConfigFactory,\n                },\n            ],\n        };\n    }\n}\nNotifierModule.ɵfac = function NotifierModule_Factory(t) { return new (t || NotifierModule)(); };\nNotifierModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: NotifierModule });\nNotifierModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ providers: [\n        NotifierAnimationService,\n        NotifierService,\n        NotifierQueueService,\n        // Provide the default notifier configuration if just the module is imported\n        {\n            provide: NotifierConfigToken,\n            useFactory: notifierDefaultConfigFactory\n        },\n    ], imports: [CommonModule] });\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NotifierModule, [{\n        type: NgModule,\n        args: [{\n                declarations: [NotifierContainerComponent, NotifierNotificationComponent],\n                exports: [NotifierContainerComponent],\n                imports: [CommonModule],\n                providers: [\n                    NotifierAnimationService,\n                    NotifierService,\n                    NotifierQueueService,\n                    // Provide the default notifier configuration if just the module is imported\n                    {\n                        provide: NotifierConfigToken,\n                        useFactory: notifierDefaultConfigFactory\n                    },\n                ]\n            }]\n    }], null, null); })();\n(function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NotifierModule, { declarations: function () { return [NotifierContainerComponent, NotifierNotificationComponent]; }, imports: function () { return [CommonModule]; }, exports: function () { return [NotifierContainerComponent]; } }); })();\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { NotifierConfig, NotifierConfigToken, NotifierContainerComponent, NotifierModule, NotifierNotificationComponent, NotifierOptionsToken, NotifierService, notifierCustomConfigFactory, notifierDefaultConfigFactory, NotifierQueueService as ɵa, NotifierTimerService as ɵb, NotifierAnimationService as ɵc };\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}