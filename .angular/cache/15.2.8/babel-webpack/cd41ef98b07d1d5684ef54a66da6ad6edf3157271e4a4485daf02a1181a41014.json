{"ast":null,"code":"import _defineProperty from \"/home/ceo/mmmm/createyourevent/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport { Observable } from 'rxjs';\nimport * as i0 from \"@angular/core\";\n/**\n * An utility service for data.\n */\nexport class DataUtils {\n  /**\n   * Method to find the byte size of the string provides\n   */\n  byteSize(base64String) {\n    return this.formatAsBytes(this.size(base64String));\n  }\n  /**\n   * Method to open file\n   */\n  openFile(data, contentType) {\n    contentType = contentType ?? '';\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    if (window.navigator.msSaveOrOpenBlob) {\n      // To support IE\n      const byteCharacters = atob(data);\n      const byteNumbers = new Array(byteCharacters.length);\n      for (let i = 0; i < byteCharacters.length; i++) {\n        byteNumbers[i] = byteCharacters.charCodeAt(i);\n      }\n      const byteArray = new Uint8Array(byteNumbers);\n      const blob = new Blob([byteArray], {\n        type: contentType\n      });\n      window.navigator.msSaveOrOpenBlob(blob);\n    } else {\n      // Other browsers\n      const fileURL = `data:${contentType};base64,${data}`;\n      const win = window.open();\n      win?.document.write('<iframe src=\"' + fileURL + '\" frameborder=\"0\" style=\"border:0; top:0; left:0; bottom:0; right:0; width:100%; height:100%;\" allowfullscreen></iframe>');\n    }\n  }\n  /**\n   * Sets the base 64 data & file type of the 1st file on the event (event.target.files[0]) in the passed entity object\n   * and returns an observable.\n   *\n   * @param event the object containing the file (at event.target.files[0])\n   * @param editForm the form group where the input field is located\n   * @param field the field name to set the file's 'base 64 data' on\n   * @param isImage boolean representing if the file represented by the event is an image\n   * @returns an observable that loads file to form field and completes if sussessful\n   *      or returns error as FileLoadError on failure\n   */\n  loadFileToForm(event, editForm, field, isImage) {\n    return new Observable(observer => {\n      const eventTarget = event.target;\n      if (eventTarget?.files?.[0]) {\n        const file = eventTarget.files[0];\n        if (isImage && !file.type.startsWith('image/')) {\n          const error = {\n            message: `File was expected to be an image but was found to be '${file.type}'`,\n            key: 'not.image',\n            params: {\n              fileType: file.type\n            }\n          };\n          observer.error(error);\n        } else {\n          const fieldContentType = field + 'ContentType';\n          this.toBase64(file, base64Data => {\n            editForm.patchValue({\n              [field]: base64Data,\n              [fieldContentType]: file.type\n            });\n            observer.next();\n            observer.complete();\n          });\n        }\n      } else {\n        const error = {\n          message: 'Could not extract file',\n          key: 'could.not.extract',\n          params: {\n            event\n          }\n        };\n        observer.error(error);\n      }\n    });\n  }\n  /**\n   * Method to convert the file to base64\n   */\n  toBase64(file, callback) {\n    const fileReader = new FileReader();\n    fileReader.onload = e => {\n      if (typeof e.target?.result === 'string') {\n        const base64Data = e.target.result.substr(e.target.result.indexOf('base64,') + 'base64,'.length);\n        callback(base64Data);\n      }\n    };\n    fileReader.readAsDataURL(file);\n  }\n  endsWith(suffix, str) {\n    return str.includes(suffix, str.length - suffix.length);\n  }\n  paddingSize(value) {\n    if (this.endsWith('==', value)) {\n      return 2;\n    }\n    if (this.endsWith('=', value)) {\n      return 1;\n    }\n    return 0;\n  }\n  size(value) {\n    return value.length / 4 * 3 - this.paddingSize(value);\n  }\n  formatAsBytes(size) {\n    return size.toString().replace(/\\B(?=(\\d{3})+(?!\\d))/g, ' ') + ' bytes';\n  }\n}\n_defineProperty(DataUtils, \"\\u0275fac\", function DataUtils_Factory(t) {\n  return new (t || DataUtils)();\n});\n_defineProperty(DataUtils, \"\\u0275prov\", /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: DataUtils,\n  factory: DataUtils.ɵfac,\n  providedIn: 'root'\n}));","map":{"version":3,"mappings":"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","names":["Observable","DataUtils","byteSize","base64String","formatAsBytes","size","openFile","data","contentType","window","navigator","msSaveOrOpenBlob","byteCharacters","atob","byteNumbers","Array","length","i","charCodeAt","byteArray","Uint8Array","blob","Blob","type","fileURL","win","open","document","write","loadFileToForm","event","editForm","field","isImage","observer","eventTarget","target","files","file","startsWith","error","message","key","params","fileType","fieldContentType","toBase64","base64Data","patchValue","next","complete","callback","fileReader","FileReader","onload","e","result","substr","indexOf","readAsDataURL","endsWith","suffix","str","includes","paddingSize","value","toString","replace","factory","providedIn"],"sourceRoot":"","sources":["/home/ceo/mmmm/createyourevent/src/main/webapp/app/core/util/data-util.service.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\nimport { Observable, Observer } from 'rxjs';\nimport { UntypedFormGroup } from '@angular/forms';\n\nexport type FileLoadErrorType = 'not.image' | 'could.not.extract';\n\nexport interface FileLoadError {\n  message: string;\n  key: FileLoadErrorType;\n  params?: any;\n}\n\n/**\n * An utility service for data.\n */\n@Injectable({\n  providedIn: 'root',\n})\nexport class DataUtils {\n  /**\n   * Method to find the byte size of the string provides\n   */\n  byteSize(base64String: string): string {\n    return this.formatAsBytes(this.size(base64String));\n  }\n\n  /**\n   * Method to open file\n   */\n  openFile(data: string, contentType: string | null | undefined): void {\n    contentType = contentType ?? '';\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    if (window.navigator.msSaveOrOpenBlob) {\n      // To support IE\n      const byteCharacters = atob(data);\n      const byteNumbers = new Array(byteCharacters.length);\n      for (let i = 0; i < byteCharacters.length; i++) {\n        byteNumbers[i] = byteCharacters.charCodeAt(i);\n      }\n      const byteArray = new Uint8Array(byteNumbers);\n      const blob = new Blob([byteArray], {\n        type: contentType,\n      });\n      window.navigator.msSaveOrOpenBlob(blob);\n    } else {\n      // Other browsers\n      const fileURL = `data:${contentType};base64,${data}`;\n      const win = window.open();\n      win?.document.write(\n        '<iframe src=\"' +\n          fileURL +\n          '\" frameborder=\"0\" style=\"border:0; top:0; left:0; bottom:0; right:0; width:100%; height:100%;\" allowfullscreen></iframe>'\n      );\n    }\n  }\n\n  /**\n   * Sets the base 64 data & file type of the 1st file on the event (event.target.files[0]) in the passed entity object\n   * and returns an observable.\n   *\n   * @param event the object containing the file (at event.target.files[0])\n   * @param editForm the form group where the input field is located\n   * @param field the field name to set the file's 'base 64 data' on\n   * @param isImage boolean representing if the file represented by the event is an image\n   * @returns an observable that loads file to form field and completes if sussessful\n   *      or returns error as FileLoadError on failure\n   */\n  loadFileToForm(event: Event, editForm: UntypedFormGroup, field: string, isImage: boolean): Observable<void> {\n    return new Observable((observer: Observer<void>) => {\n      const eventTarget: HTMLInputElement | null = event.target as HTMLInputElement | null;\n      if (eventTarget?.files?.[0]) {\n        const file: File = eventTarget.files[0];\n        if (isImage && !file.type.startsWith('image/')) {\n          const error: FileLoadError = {\n            message: `File was expected to be an image but was found to be '${file.type}'`,\n            key: 'not.image',\n            params: { fileType: file.type },\n          };\n          observer.error(error);\n        } else {\n          const fieldContentType: string = field + 'ContentType';\n          this.toBase64(file, (base64Data: string) => {\n            editForm.patchValue({\n              [field]: base64Data,\n              [fieldContentType]: file.type,\n            });\n            observer.next();\n            observer.complete();\n          });\n        }\n      } else {\n        const error: FileLoadError = {\n          message: 'Could not extract file',\n          key: 'could.not.extract',\n          params: { event },\n        };\n        observer.error(error);\n      }\n    });\n  }\n\n  /**\n   * Method to convert the file to base64\n   */\n  private toBase64(file: File, callback: (base64Data: string) => void): void {\n    const fileReader: FileReader = new FileReader();\n    fileReader.onload = (e: ProgressEvent<FileReader>) => {\n      if (typeof e.target?.result === 'string') {\n        const base64Data: string = e.target.result.substr(e.target.result.indexOf('base64,') + 'base64,'.length);\n        callback(base64Data);\n      }\n    };\n    fileReader.readAsDataURL(file);\n  }\n\n  private endsWith(suffix: string, str: string): boolean {\n    return str.includes(suffix, str.length - suffix.length);\n  }\n\n  private paddingSize(value: string): number {\n    if (this.endsWith('==', value)) {\n      return 2;\n    }\n    if (this.endsWith('=', value)) {\n      return 1;\n    }\n    return 0;\n  }\n\n  private size(value: string): number {\n    return (value.length / 4) * 3 - this.paddingSize(value);\n  }\n\n  private formatAsBytes(size: number): string {\n    return size.toString().replace(/\\B(?=(\\d{3})+(?!\\d))/g, ' ') + ' bytes';\n  }\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}