{"ast":null,"code":"import _defineProperty from \"/home/ceo/mmmm/createyourevent/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport { SecurityContext } from '@angular/core';\nimport { translationNotFoundMessage } from 'app/config/translation.config';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/platform-browser\";\nimport * as i2 from \"@ngx-translate/core\";\nexport class AlertService {\n  constructor(sanitizer, ngZone, translateService) {\n    _defineProperty(this, \"sanitizer\", void 0);\n    _defineProperty(this, \"ngZone\", void 0);\n    _defineProperty(this, \"translateService\", void 0);\n    _defineProperty(this, \"timeout\", 5000);\n    _defineProperty(this, \"toast\", false);\n    _defineProperty(this, \"position\", 'top right');\n    // unique id for each alert. Starts from 0.\n    _defineProperty(this, \"alertId\", 0);\n    _defineProperty(this, \"alerts\", []);\n    this.sanitizer = sanitizer;\n    this.ngZone = ngZone;\n    this.translateService = translateService;\n  }\n  clear() {\n    this.alerts = [];\n  }\n  get() {\n    return this.alerts;\n  }\n  /**\n   * Adds alert to alerts array and returns added alert.\n   * @param alert      Alert to add. If `timeout`, `toast` or `position` is missing then applying default value.\n   *                   If `translateKey` is available then it's translation else `message` is used for showing.\n   * @param extAlerts  If missing then adding `alert` to `AlertService` internal array and alerts can be retrieved by `get()`.\n   *                   Else adding `alert` to `extAlerts`.\n   * @returns  Added alert\n   */\n  addAlert(alert, extAlerts) {\n    alert.id = this.alertId++;\n    if (alert.translationKey) {\n      const translatedMessage = this.translateService.instant(alert.translationKey, alert.translationParams);\n      // if translation key exists\n      if (translatedMessage !== `${translationNotFoundMessage}[${alert.translationKey}]`) {\n        alert.message = translatedMessage;\n      } else if (!alert.message) {\n        alert.message = alert.translationKey;\n      }\n    }\n    alert.message = this.sanitizer.sanitize(SecurityContext.HTML, alert.message ?? '') ?? '';\n    alert.timeout = alert.timeout ?? this.timeout;\n    alert.toast = alert.toast ?? this.toast;\n    alert.position = alert.position ?? this.position;\n    alert.close = alertsArray => this.closeAlert(alert.id, alertsArray);\n    (extAlerts ?? this.alerts).push(alert);\n    if (alert.timeout > 0) {\n      // Workaround protractor waiting for setTimeout.\n      // Reference https://www.protractortest.org/#/timeouts\n      this.ngZone.runOutsideAngular(() => {\n        setTimeout(() => {\n          this.ngZone.run(() => {\n            this.closeAlert(alert.id, extAlerts ?? this.alerts);\n          });\n        }, alert.timeout);\n      });\n    }\n    return alert;\n  }\n  closeAlert(alertId, extAlerts) {\n    const alerts = extAlerts ?? this.alerts;\n    const alertIndex = alerts.map(alert => alert.id).indexOf(alertId);\n    // if found alert then remove\n    if (alertIndex >= 0) {\n      alerts.splice(alertIndex, 1);\n    }\n  }\n}\n_defineProperty(AlertService, \"\\u0275fac\", function AlertService_Factory(t) {\n  return new (t || AlertService)(i0.ɵɵinject(i1.DomSanitizer), i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(i2.TranslateService));\n});\n_defineProperty(AlertService, \"\\u0275prov\", /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: AlertService,\n  factory: AlertService.ɵfac,\n  providedIn: 'root'\n}));","map":{"version":3,"mappings":"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","names":["SecurityContext","translationNotFoundMessage","AlertService","constructor","sanitizer","ngZone","translateService","clear","alerts","get","addAlert","alert","extAlerts","id","alertId","translationKey","translatedMessage","instant","translationParams","message","sanitize","HTML","timeout","toast","position","close","alertsArray","closeAlert","push","runOutsideAngular","setTimeout","run","alertIndex","map","indexOf","splice","factory","providedIn"],"sourceRoot":"","sources":["/home/ceo/mmmm/createyourevent/src/main/webapp/app/core/util/alert.service.ts"],"sourcesContent":["import { Injectable, SecurityContext, NgZone } from '@angular/core';\nimport { DomSanitizer } from '@angular/platform-browser';\nimport { TranslateService } from '@ngx-translate/core';\nimport { translationNotFoundMessage } from 'app/config/translation.config';\n\nexport type AlertType = 'success' | 'danger' | 'warning' | 'info';\n\nexport interface Alert {\n  id?: number;\n  type: AlertType;\n  message?: string;\n  translationKey?: string;\n  translationParams?: { [key: string]: unknown };\n  timeout?: number;\n  toast?: boolean;\n  position?: string;\n  close?: (alerts: Alert[]) => void;\n}\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class AlertService {\n  timeout = 5000;\n  toast = false;\n  position = 'top right';\n\n  // unique id for each alert. Starts from 0.\n  private alertId = 0;\n  private alerts: Alert[] = [];\n\n  constructor(private sanitizer: DomSanitizer, private ngZone: NgZone, private translateService: TranslateService) {}\n\n  clear(): void {\n    this.alerts = [];\n  }\n\n  get(): Alert[] {\n    return this.alerts;\n  }\n\n  /**\n   * Adds alert to alerts array and returns added alert.\n   * @param alert      Alert to add. If `timeout`, `toast` or `position` is missing then applying default value.\n   *                   If `translateKey` is available then it's translation else `message` is used for showing.\n   * @param extAlerts  If missing then adding `alert` to `AlertService` internal array and alerts can be retrieved by `get()`.\n   *                   Else adding `alert` to `extAlerts`.\n   * @returns  Added alert\n   */\n  addAlert(alert: Alert, extAlerts?: Alert[]): Alert {\n    alert.id = this.alertId++;\n\n    if (alert.translationKey) {\n      const translatedMessage = this.translateService.instant(alert.translationKey, alert.translationParams);\n      // if translation key exists\n      if (translatedMessage !== `${translationNotFoundMessage}[${alert.translationKey}]`) {\n        alert.message = translatedMessage;\n      } else if (!alert.message) {\n        alert.message = alert.translationKey;\n      }\n    }\n\n    alert.message = this.sanitizer.sanitize(SecurityContext.HTML, alert.message ?? '') ?? '';\n    alert.timeout = alert.timeout ?? this.timeout;\n    alert.toast = alert.toast ?? this.toast;\n    alert.position = alert.position ?? this.position;\n    alert.close = (alertsArray: Alert[]) => this.closeAlert(alert.id!, alertsArray);\n\n    (extAlerts ?? this.alerts).push(alert);\n\n    if (alert.timeout > 0) {\n      // Workaround protractor waiting for setTimeout.\n      // Reference https://www.protractortest.org/#/timeouts\n      this.ngZone.runOutsideAngular(() => {\n        setTimeout(() => {\n          this.ngZone.run(() => {\n            this.closeAlert(alert.id!, extAlerts ?? this.alerts);\n          });\n        }, alert.timeout);\n      });\n    }\n\n    return alert;\n  }\n\n  private closeAlert(alertId: number, extAlerts?: Alert[]): void {\n    const alerts = extAlerts ?? this.alerts;\n    const alertIndex = alerts.map(alert => alert.id).indexOf(alertId);\n    // if found alert then remove\n    if (alertIndex >= 0) {\n      alerts.splice(alertIndex, 1);\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}