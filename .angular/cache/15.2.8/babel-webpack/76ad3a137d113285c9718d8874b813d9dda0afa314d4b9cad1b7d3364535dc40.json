{"ast":null,"code":"import { Observable } from 'rxjs';\nimport * as i0 from \"@angular/core\";\n/**\n * An utility service for data.\n */\nexport let DataUtils = /*#__PURE__*/(() => {\n  class DataUtils {\n    /**\n     * Method to find the byte size of the string provides\n     */\n    byteSize(base64String) {\n      return this.formatAsBytes(this.size(base64String));\n    }\n    /**\n     * Method to open file\n     */\n    openFile(data, contentType) {\n      contentType = contentType ?? '';\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      if (window.navigator.msSaveOrOpenBlob) {\n        // To support IE\n        const byteCharacters = atob(data);\n        const byteNumbers = new Array(byteCharacters.length);\n        for (let i = 0; i < byteCharacters.length; i++) {\n          byteNumbers[i] = byteCharacters.charCodeAt(i);\n        }\n        const byteArray = new Uint8Array(byteNumbers);\n        const blob = new Blob([byteArray], {\n          type: contentType\n        });\n        window.navigator.msSaveOrOpenBlob(blob);\n      } else {\n        // Other browsers\n        const fileURL = `data:${contentType};base64,${data}`;\n        const win = window.open();\n        win?.document.write('<iframe src=\"' + fileURL + '\" frameborder=\"0\" style=\"border:0; top:0; left:0; bottom:0; right:0; width:100%; height:100%;\" allowfullscreen></iframe>');\n      }\n    }\n    /**\n     * Sets the base 64 data & file type of the 1st file on the event (event.target.files[0]) in the passed entity object\n     * and returns an observable.\n     *\n     * @param event the object containing the file (at event.target.files[0])\n     * @param editForm the form group where the input field is located\n     * @param field the field name to set the file's 'base 64 data' on\n     * @param isImage boolean representing if the file represented by the event is an image\n     * @returns an observable that loads file to form field and completes if sussessful\n     *      or returns error as FileLoadError on failure\n     */\n    loadFileToForm(event, editForm, field, isImage) {\n      return new Observable(observer => {\n        const eventTarget = event.target;\n        if (eventTarget?.files?.[0]) {\n          const file = eventTarget.files[0];\n          if (isImage && !file.type.startsWith('image/')) {\n            const error = {\n              message: `File was expected to be an image but was found to be '${file.type}'`,\n              key: 'not.image',\n              params: {\n                fileType: file.type\n              }\n            };\n            observer.error(error);\n          } else {\n            const fieldContentType = field + 'ContentType';\n            this.toBase64(file, base64Data => {\n              editForm.patchValue({\n                [field]: base64Data,\n                [fieldContentType]: file.type\n              });\n              observer.next();\n              observer.complete();\n            });\n          }\n        } else {\n          const error = {\n            message: 'Could not extract file',\n            key: 'could.not.extract',\n            params: {\n              event\n            }\n          };\n          observer.error(error);\n        }\n      });\n    }\n    /**\n     * Method to convert the file to base64\n     */\n    toBase64(file, callback) {\n      const fileReader = new FileReader();\n      fileReader.onload = e => {\n        if (typeof e.target?.result === 'string') {\n          const base64Data = e.target.result.substr(e.target.result.indexOf('base64,') + 'base64,'.length);\n          callback(base64Data);\n        }\n      };\n      fileReader.readAsDataURL(file);\n    }\n    endsWith(suffix, str) {\n      return str.includes(suffix, str.length - suffix.length);\n    }\n    paddingSize(value) {\n      if (this.endsWith('==', value)) {\n        return 2;\n      }\n      if (this.endsWith('=', value)) {\n        return 1;\n      }\n      return 0;\n    }\n    size(value) {\n      return value.length / 4 * 3 - this.paddingSize(value);\n    }\n    formatAsBytes(size) {\n      return size.toString().replace(/\\B(?=(\\d{3})+(?!\\d))/g, ' ') + ' bytes';\n    }\n  }\n  DataUtils.ɵfac = function DataUtils_Factory(t) {\n    return new (t || DataUtils)();\n  };\n  DataUtils.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: DataUtils,\n    factory: DataUtils.ɵfac,\n    providedIn: 'root'\n  });\n  return DataUtils;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}