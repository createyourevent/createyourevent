{"ast":null,"code":"import { isPlatformBrowser } from '@angular/common';\nimport { Directive, Renderer2, ElementRef, Output, Input, EventEmitter, NgZone, Inject, PLATFORM_ID, Optional, NgModule } from '@angular/core';\nimport { Subject, Observable, merge, EMPTY, fromEvent } from 'rxjs';\nimport { map, mergeMap, takeUntil, filter, pairwise, take, share, auditTime, switchMap, startWith, tap } from 'rxjs/operators';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @hidden\n * @type {?}\n */\nimport * as Éµngcc0 from '@angular/core';\nconst IS_TOUCH_DEVICE = (() => {\n  // In case we're in Node.js environment.\n  if (typeof window === 'undefined') {\n    return false;\n  } else {\n    return 'ontouchstart' in window || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0;\n  }\n})();\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} value1\n * @param {?} value2\n * @param {?=} precision\n * @return {?}\n */\nfunction isNumberCloseTo(value1, value2, precision = 3) {\n  /** @type {?} */\n  const diff = Math.abs(value1 - value2);\n  return diff < precision;\n}\n/**\n * @param {?} startingRect\n * @param {?} edges\n * @param {?} clientX\n * @param {?} clientY\n * @return {?}\n */\nfunction getNewBoundingRectangle(startingRect, edges, clientX, clientY) {\n  /** @type {?} */\n  const newBoundingRect = {\n    top: startingRect.top,\n    bottom: startingRect.bottom,\n    left: startingRect.left,\n    right: startingRect.right\n  };\n  if (edges.top) {\n    newBoundingRect.top += clientY;\n  }\n  if (edges.bottom) {\n    newBoundingRect.bottom += clientY;\n  }\n  if (edges.left) {\n    newBoundingRect.left += clientX;\n  }\n  if (edges.right) {\n    newBoundingRect.right += clientX;\n  }\n  newBoundingRect.height = newBoundingRect.bottom - newBoundingRect.top;\n  newBoundingRect.width = newBoundingRect.right - newBoundingRect.left;\n  return newBoundingRect;\n}\n/**\n * @param {?} element\n * @param {?} ghostElementPositioning\n * @return {?}\n */\nfunction getElementRect(element, ghostElementPositioning) {\n  /** @type {?} */\n  let translateX = 0;\n  /** @type {?} */\n  let translateY = 0;\n  /** @type {?} */\n  const style = element.nativeElement.style;\n  /** @type {?} */\n  const transformProperties = ['transform', '-ms-transform', '-moz-transform', '-o-transform'];\n  /** @type {?} */\n  const transform = transformProperties.map(property => style[property]).find(value => !!value);\n  if (transform && transform.includes('translate')) {\n    translateX = transform.replace(/.*translate3?d?\\((-?[0-9]*)px, (-?[0-9]*)px.*/, '$1');\n    translateY = transform.replace(/.*translate3?d?\\((-?[0-9]*)px, (-?[0-9]*)px.*/, '$2');\n  }\n  if (ghostElementPositioning === 'absolute') {\n    return {\n      height: element.nativeElement.offsetHeight,\n      width: element.nativeElement.offsetWidth,\n      top: element.nativeElement.offsetTop - translateY,\n      bottom: element.nativeElement.offsetHeight + element.nativeElement.offsetTop - translateY,\n      left: element.nativeElement.offsetLeft - translateX,\n      right: element.nativeElement.offsetWidth + element.nativeElement.offsetLeft - translateX\n    };\n  } else {\n    /** @type {?} */\n    const boundingRect = element.nativeElement.getBoundingClientRect();\n    return {\n      height: boundingRect.height,\n      width: boundingRect.width,\n      top: boundingRect.top - translateY,\n      bottom: boundingRect.bottom - translateY,\n      left: boundingRect.left - translateX,\n      right: boundingRect.right - translateX,\n      scrollTop: element.nativeElement.scrollTop,\n      scrollLeft: element.nativeElement.scrollLeft\n    };\n  }\n}\n/**\n * @param {?} __0\n * @return {?}\n */\nfunction isWithinBoundingY({\n  clientY,\n  rect\n}) {\n  return clientY >= rect.top && clientY <= rect.bottom;\n}\n/**\n * @param {?} __0\n * @return {?}\n */\nfunction isWithinBoundingX({\n  clientX,\n  rect\n}) {\n  return clientX >= rect.left && clientX <= rect.right;\n}\n/**\n * @param {?} __0\n * @return {?}\n */\nfunction getResizeEdges({\n  clientX,\n  clientY,\n  elm,\n  allowedEdges,\n  cursorPrecision\n}) {\n  /** @type {?} */\n  const elmPosition = elm.nativeElement.getBoundingClientRect();\n  /** @type {?} */\n  const edges = {};\n  if (allowedEdges.left && isNumberCloseTo(clientX, elmPosition.left, cursorPrecision) && isWithinBoundingY({\n    clientY,\n    rect: elmPosition\n  })) {\n    edges.left = true;\n  }\n  if (allowedEdges.right && isNumberCloseTo(clientX, elmPosition.right, cursorPrecision) && isWithinBoundingY({\n    clientY,\n    rect: elmPosition\n  })) {\n    edges.right = true;\n  }\n  if (allowedEdges.top && isNumberCloseTo(clientY, elmPosition.top, cursorPrecision) && isWithinBoundingX({\n    clientX,\n    rect: elmPosition\n  })) {\n    edges.top = true;\n  }\n  if (allowedEdges.bottom && isNumberCloseTo(clientY, elmPosition.bottom, cursorPrecision) && isWithinBoundingX({\n    clientX,\n    rect: elmPosition\n  })) {\n    edges.bottom = true;\n  }\n  return edges;\n}\n/** @type {?} */\nconst DEFAULT_RESIZE_CURSORS = Object.freeze({\n  topLeft: 'nw-resize',\n  topRight: 'ne-resize',\n  bottomLeft: 'sw-resize',\n  bottomRight: 'se-resize',\n  leftOrRight: 'col-resize',\n  topOrBottom: 'row-resize'\n});\n/**\n * @param {?} edges\n * @param {?} cursors\n * @return {?}\n */\nfunction getResizeCursor(edges, cursors) {\n  if (edges.left && edges.top) {\n    return cursors.topLeft;\n  } else if (edges.right && edges.top) {\n    return cursors.topRight;\n  } else if (edges.left && edges.bottom) {\n    return cursors.bottomLeft;\n  } else if (edges.right && edges.bottom) {\n    return cursors.bottomRight;\n  } else if (edges.left || edges.right) {\n    return cursors.leftOrRight;\n  } else if (edges.top || edges.bottom) {\n    return cursors.topOrBottom;\n  } else {\n    return '';\n  }\n}\n/**\n * @param {?} __0\n * @return {?}\n */\nfunction getEdgesDiff({\n  edges,\n  initialRectangle,\n  newRectangle\n}) {\n  /** @type {?} */\n  const edgesDiff = {};\n  Object.keys(edges).forEach(edge => {\n    edgesDiff[edge] = (newRectangle[edge] || 0) - (initialRectangle[edge] || 0);\n  });\n  return edgesDiff;\n}\n/** @type {?} */\nconst RESIZE_ACTIVE_CLASS = 'resize-active';\n/** @type {?} */\nconst RESIZE_LEFT_HOVER_CLASS = 'resize-left-hover';\n/** @type {?} */\nconst RESIZE_RIGHT_HOVER_CLASS = 'resize-right-hover';\n/** @type {?} */\nconst RESIZE_TOP_HOVER_CLASS = 'resize-top-hover';\n/** @type {?} */\nconst RESIZE_BOTTOM_HOVER_CLASS = 'resize-bottom-hover';\n/** @type {?} */\nconst RESIZE_GHOST_ELEMENT_CLASS = 'resize-ghost-element';\n/** @type {?} */\nconst MOUSE_MOVE_THROTTLE_MS = 50;\n/**\n * Place this on an element to make it resizable. For example:\n *\n * ```html\n * <div\n *   mwlResizable\n *   [resizeEdges]=\"{bottom: true, right: true, top: true, left: true}\"\n *   [enableGhostResize]=\"true\">\n * </div>\n * ```\n * Or in case they are sibling elements:\n * ```html\n * <div mwlResizable #resizableElement=\"mwlResizable\"></div>\n * <div mwlResizeHandle [resizableContainer]=\"resizableElement\" [resizeEdges]=\"{bottom: true, right: true}\"></div>\n * ```\n */\nlet ResizableDirective = /*#__PURE__*/(() => {\n  class ResizableDirective {\n    /**\n     * @hidden\n     * @param {?} platformId\n     * @param {?} renderer\n     * @param {?} elm\n     * @param {?} zone\n     */\n    constructor(platformId, renderer, elm, zone) {\n      this.platformId = platformId;\n      this.renderer = renderer;\n      this.elm = elm;\n      this.zone = zone;\n      /**\n       * The edges that an element can be resized from. Pass an object like `{top: true, bottom: false}`. By default no edges can be resized.\n       * @deprecated use a resize handle instead that positions itself to the side of the element you would like to resize\n       */\n      this.resizeEdges = {};\n      /**\n       * Set to `true` to enable a temporary resizing effect of the element in between the `resizeStart` and `resizeEnd` events.\n       */\n      this.enableGhostResize = false;\n      /**\n       * A snap grid that resize events will be locked to.\n       *\n       * e.g. to only allow the element to be resized every 10px set it to `{left: 10, right: 10}`\n       */\n      this.resizeSnapGrid = {};\n      /**\n       * The mouse cursors that will be set on the resize edges\n       */\n      this.resizeCursors = DEFAULT_RESIZE_CURSORS;\n      /**\n       * Mouse over thickness to active cursor.\n       * @deprecated invalid when you migrate to use resize handles instead of setting resizeEdges on the element\n       */\n      this.resizeCursorPrecision = 3;\n      /**\n       * Define the positioning of the ghost element (can be fixed or absolute)\n       */\n      this.ghostElementPositioning = 'fixed';\n      /**\n       * Allow elements to be resized to negative dimensions\n       */\n      this.allowNegativeResizes = false;\n      /**\n       * The mouse move throttle in milliseconds, default: 50 ms\n       */\n      this.mouseMoveThrottleMS = MOUSE_MOVE_THROTTLE_MS;\n      /**\n       * Called when the mouse is pressed and a resize event is about to begin. `$event` is a `ResizeEvent` object.\n       */\n      this.resizeStart = new EventEmitter();\n      /**\n       * Called as the mouse is dragged after a resize event has begun. `$event` is a `ResizeEvent` object.\n       */\n      this.resizing = new EventEmitter();\n      /**\n       * Called after the mouse is released after a resize event. `$event` is a `ResizeEvent` object.\n       */\n      this.resizeEnd = new EventEmitter();\n      /**\n       * @hidden\n       */\n      this.mouseup = new Subject();\n      /**\n       * @hidden\n       */\n      this.mousedown = new Subject();\n      /**\n       * @hidden\n       */\n      this.mousemove = new Subject();\n      this.destroy$ = new Subject();\n      this.resizeEdges$ = new Subject();\n      this.pointerEventListeners = PointerEventListeners.getInstance(renderer, zone);\n    }\n    /**\n     * @hidden\n     * @return {?}\n     */\n    ngOnInit() {\n      /** @type {?} */\n      const mousedown$ = merge(this.pointerEventListeners.pointerDown, this.mousedown);\n      /** @type {?} */\n      const mousemove$ = merge(this.pointerEventListeners.pointerMove, this.mousemove).pipe(tap(({\n        event\n      }) => {\n        if (currentResize) {\n          try {\n            event.preventDefault();\n          } catch (e) {\n            // just adding try-catch not to see errors in console if there is a passive listener for same event somewhere\n            // browser does nothing except of writing errors to console\n          }\n        }\n      }), share());\n      /** @type {?} */\n      const mouseup$ = merge(this.pointerEventListeners.pointerUp, this.mouseup);\n      /** @type {?} */\n      let currentResize;\n      /** @type {?} */\n      const removeGhostElement = () => {\n        if (currentResize && currentResize.clonedNode) {\n          this.elm.nativeElement.parentElement.removeChild(currentResize.clonedNode);\n          this.renderer.setStyle(this.elm.nativeElement, 'visibility', 'inherit');\n        }\n      };\n      /** @type {?} */\n      const getResizeCursors = () => {\n        return Object.assign({}, DEFAULT_RESIZE_CURSORS, this.resizeCursors);\n      };\n      this.resizeEdges$.pipe(startWith(this.resizeEdges), map(() => {\n        return this.resizeEdges && Object.keys(this.resizeEdges).some(edge => !!this.resizeEdges[edge]);\n      }), switchMap(legacyResizeEdgesEnabled => legacyResizeEdgesEnabled ? mousemove$ : EMPTY), auditTime(this.mouseMoveThrottleMS), takeUntil(this.destroy$)).subscribe(({\n        clientX,\n        clientY\n      }) => {\n        /** @type {?} */\n        const resizeEdges = getResizeEdges({\n          clientX,\n          clientY,\n          elm: this.elm,\n          allowedEdges: this.resizeEdges,\n          cursorPrecision: this.resizeCursorPrecision\n        });\n        /** @type {?} */\n        const resizeCursors = getResizeCursors();\n        if (!currentResize) {\n          /** @type {?} */\n          const cursor = getResizeCursor(resizeEdges, resizeCursors);\n          this.renderer.setStyle(this.elm.nativeElement, 'cursor', cursor);\n        }\n        this.setElementClass(this.elm, RESIZE_LEFT_HOVER_CLASS, resizeEdges.left === true);\n        this.setElementClass(this.elm, RESIZE_RIGHT_HOVER_CLASS, resizeEdges.right === true);\n        this.setElementClass(this.elm, RESIZE_TOP_HOVER_CLASS, resizeEdges.top === true);\n        this.setElementClass(this.elm, RESIZE_BOTTOM_HOVER_CLASS, resizeEdges.bottom === true);\n      });\n      /** @type {?} */\n      const mousedrag = mousedown$.pipe(mergeMap(startCoords => {\n        /**\n         * @param {?} moveCoords\n         * @return {?}\n         */\n        function getDiff(moveCoords) {\n          return {\n            clientX: moveCoords.clientX - startCoords.clientX,\n            clientY: moveCoords.clientY - startCoords.clientY\n          };\n        }\n        /** @type {?} */\n        const getSnapGrid = () => {\n          /** @type {?} */\n          const snapGrid = {\n            x: 1,\n            y: 1\n          };\n          if (currentResize) {\n            if (this.resizeSnapGrid.left && currentResize.edges.left) {\n              snapGrid.x = +this.resizeSnapGrid.left;\n            } else if (this.resizeSnapGrid.right && currentResize.edges.right) {\n              snapGrid.x = +this.resizeSnapGrid.right;\n            }\n            if (this.resizeSnapGrid.top && currentResize.edges.top) {\n              snapGrid.y = +this.resizeSnapGrid.top;\n            } else if (this.resizeSnapGrid.bottom && currentResize.edges.bottom) {\n              snapGrid.y = +this.resizeSnapGrid.bottom;\n            }\n          }\n          return snapGrid;\n        };\n        /**\n         * @param {?} coords\n         * @param {?} snapGrid\n         * @return {?}\n         */\n        function getGrid(coords, snapGrid) {\n          return {\n            x: Math.ceil(coords.clientX / snapGrid.x),\n            y: Math.ceil(coords.clientY / snapGrid.y)\n          };\n        }\n        return (/** @type {?} */merge(mousemove$.pipe(take(1)).pipe(map(coords => [, coords])), mousemove$.pipe(pairwise())).pipe(map(([previousCoords, newCoords]) => {\n            return [previousCoords ? getDiff(previousCoords) : previousCoords, getDiff(newCoords)];\n          })).pipe(filter(([previousCoords, newCoords]) => {\n            if (!previousCoords) {\n              return true;\n            }\n            /** @type {?} */\n            const snapGrid = getSnapGrid();\n            /** @type {?} */\n            const previousGrid = getGrid(previousCoords, snapGrid);\n            /** @type {?} */\n            const newGrid = getGrid(newCoords, snapGrid);\n            return previousGrid.x !== newGrid.x || previousGrid.y !== newGrid.y;\n          })).pipe(map(([, newCoords]) => {\n            /** @type {?} */\n            const snapGrid = getSnapGrid();\n            return {\n              clientX: Math.round(newCoords.clientX / snapGrid.x) * snapGrid.x,\n              clientY: Math.round(newCoords.clientY / snapGrid.y) * snapGrid.y\n            };\n          })).pipe(takeUntil(merge(mouseup$, mousedown$)))\n        );\n      })).pipe(filter(() => !!currentResize));\n      mousedrag.pipe(map(({\n        clientX,\n        clientY\n      }) => {\n        return getNewBoundingRectangle( /** @type {?} */currentResize.startingRect, /** @type {?} */currentResize.edges, clientX, clientY);\n      })).pipe(filter(newBoundingRect => {\n        return this.allowNegativeResizes || !!(newBoundingRect.height && newBoundingRect.width && newBoundingRect.height > 0 && newBoundingRect.width > 0);\n      })).pipe(filter(newBoundingRect => {\n        return this.validateResize ? this.validateResize({\n          rectangle: newBoundingRect,\n          edges: getEdgesDiff({\n            edges: /** @type {?} */currentResize.edges,\n            initialRectangle: /** @type {?} */currentResize.startingRect,\n            newRectangle: newBoundingRect\n          })\n        }) : true;\n      }), takeUntil(this.destroy$)).subscribe(newBoundingRect => {\n        if (currentResize && currentResize.clonedNode) {\n          this.renderer.setStyle(currentResize.clonedNode, 'height', `${newBoundingRect.height}px`);\n          this.renderer.setStyle(currentResize.clonedNode, 'width', `${newBoundingRect.width}px`);\n          this.renderer.setStyle(currentResize.clonedNode, 'top', `${newBoundingRect.top}px`);\n          this.renderer.setStyle(currentResize.clonedNode, 'left', `${newBoundingRect.left}px`);\n        }\n        if (this.resizing.observers.length > 0) {\n          this.zone.run(() => {\n            this.resizing.emit({\n              edges: getEdgesDiff({\n                edges: /** @type {?} */currentResize.edges,\n                initialRectangle: /** @type {?} */currentResize.startingRect,\n                newRectangle: newBoundingRect\n              }),\n              rectangle: newBoundingRect\n            });\n          });\n        }\n        /** @type {?} */currentResize.currentRect = newBoundingRect;\n      });\n      mousedown$.pipe(map(({\n        clientX,\n        clientY,\n        edges\n      }) => {\n        return edges || getResizeEdges({\n          clientX,\n          clientY,\n          elm: this.elm,\n          allowedEdges: this.resizeEdges,\n          cursorPrecision: this.resizeCursorPrecision\n        });\n      })).pipe(filter(edges => {\n        return Object.keys(edges).length > 0;\n      }), takeUntil(this.destroy$)).subscribe(edges => {\n        if (currentResize) {\n          removeGhostElement();\n        }\n        /** @type {?} */\n        const startingRect = getElementRect(this.elm, this.ghostElementPositioning);\n        currentResize = {\n          edges,\n          startingRect,\n          currentRect: startingRect\n        };\n        /** @type {?} */\n        const resizeCursors = getResizeCursors();\n        /** @type {?} */\n        const cursor = getResizeCursor(currentResize.edges, resizeCursors);\n        this.renderer.setStyle(document.body, 'cursor', cursor);\n        this.setElementClass(this.elm, RESIZE_ACTIVE_CLASS, true);\n        if (this.enableGhostResize) {\n          currentResize.clonedNode = this.elm.nativeElement.cloneNode(true);\n          this.elm.nativeElement.parentElement.appendChild(currentResize.clonedNode);\n          this.renderer.setStyle(this.elm.nativeElement, 'visibility', 'hidden');\n          this.renderer.setStyle(currentResize.clonedNode, 'position', this.ghostElementPositioning);\n          this.renderer.setStyle(currentResize.clonedNode, 'left', `${currentResize.startingRect.left}px`);\n          this.renderer.setStyle(currentResize.clonedNode, 'top', `${currentResize.startingRect.top}px`);\n          this.renderer.setStyle(currentResize.clonedNode, 'height', `${currentResize.startingRect.height}px`);\n          this.renderer.setStyle(currentResize.clonedNode, 'width', `${currentResize.startingRect.width}px`);\n          this.renderer.setStyle(currentResize.clonedNode, 'cursor', getResizeCursor(currentResize.edges, resizeCursors));\n          this.renderer.addClass(currentResize.clonedNode, RESIZE_GHOST_ELEMENT_CLASS);\n          /** @type {?} */currentResize.clonedNode.scrollTop = /** @type {?} */currentResize.startingRect.scrollTop;\n          /** @type {?} */currentResize.clonedNode.scrollLeft = /** @type {?} */currentResize.startingRect.scrollLeft;\n        }\n        if (this.resizeStart.observers.length > 0) {\n          this.zone.run(() => {\n            this.resizeStart.emit({\n              edges: getEdgesDiff({\n                edges,\n                initialRectangle: startingRect,\n                newRectangle: startingRect\n              }),\n              rectangle: getNewBoundingRectangle(startingRect, {}, 0, 0)\n            });\n          });\n        }\n      });\n      mouseup$.pipe(takeUntil(this.destroy$)).subscribe(() => {\n        if (currentResize) {\n          this.renderer.removeClass(this.elm.nativeElement, RESIZE_ACTIVE_CLASS);\n          this.renderer.setStyle(document.body, 'cursor', '');\n          this.renderer.setStyle(this.elm.nativeElement, 'cursor', '');\n          if (this.resizeEnd.observers.length > 0) {\n            this.zone.run(() => {\n              this.resizeEnd.emit({\n                edges: getEdgesDiff({\n                  edges: /** @type {?} */currentResize.edges,\n                  initialRectangle: /** @type {?} */currentResize.startingRect,\n                  newRectangle: /** @type {?} */currentResize.currentRect\n                }),\n                rectangle: /** @type {?} */currentResize.currentRect\n              });\n            });\n          }\n          removeGhostElement();\n          currentResize = null;\n        }\n      });\n    }\n    /**\n     * @hidden\n     * @param {?} changes\n     * @return {?}\n     */\n    ngOnChanges(changes) {\n      if (changes.resizeEdges) {\n        this.resizeEdges$.next(this.resizeEdges);\n      }\n    }\n    /**\n     * @hidden\n     * @return {?}\n     */\n    ngOnDestroy() {\n      // browser check for angular universal, because it doesn't know what document is\n      if (isPlatformBrowser(this.platformId)) {\n        this.renderer.setStyle(document.body, 'cursor', '');\n      }\n      this.mousedown.complete();\n      this.mouseup.complete();\n      this.mousemove.complete();\n      this.resizeEdges$.complete();\n      this.destroy$.next();\n    }\n    /**\n     * @private\n     * @param {?} elm\n     * @param {?} name\n     * @param {?} add\n     * @return {?}\n     */\n    setElementClass(elm, name, add) {\n      if (add) {\n        this.renderer.addClass(elm.nativeElement, name);\n      } else {\n        this.renderer.removeClass(elm.nativeElement, name);\n      }\n    }\n  }\n  ResizableDirective.Éµfac = function ResizableDirective_Factory(t) {\n    return new (t || ResizableDirective)(Éµngcc0.ÉµÉµdirectiveInject(PLATFORM_ID), Éµngcc0.ÉµÉµdirectiveInject(Éµngcc0.Renderer2), Éµngcc0.ÉµÉµdirectiveInject(Éµngcc0.ElementRef), Éµngcc0.ÉµÉµdirectiveInject(Éµngcc0.NgZone));\n  };\n  ResizableDirective.Éµdir = /*@__PURE__*/Éµngcc0.ÉµÉµdefineDirective({\n    type: ResizableDirective,\n    selectors: [[\"\", \"mwlResizable\", \"\"]],\n    inputs: {\n      resizeEdges: \"resizeEdges\",\n      enableGhostResize: \"enableGhostResize\",\n      resizeSnapGrid: \"resizeSnapGrid\",\n      resizeCursors: \"resizeCursors\",\n      resizeCursorPrecision: \"resizeCursorPrecision\",\n      ghostElementPositioning: \"ghostElementPositioning\",\n      allowNegativeResizes: \"allowNegativeResizes\",\n      mouseMoveThrottleMS: \"mouseMoveThrottleMS\",\n      validateResize: \"validateResize\"\n    },\n    outputs: {\n      resizeStart: \"resizeStart\",\n      resizing: \"resizing\",\n      resizeEnd: \"resizeEnd\"\n    },\n    exportAs: [\"mwlResizable\"],\n    features: [Éµngcc0.ÉµÉµNgOnChangesFeature]\n  });\n  /** @nocollapse */\n  return ResizableDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nclass PointerEventListeners {\n  // tslint:disable-line\n  /**\n   * @param {?} renderer\n   * @param {?} zone\n   * @return {?}\n   */\n  static getInstance(renderer, zone) {\n    if (!PointerEventListeners.instance) {\n      PointerEventListeners.instance = new PointerEventListeners(renderer, zone);\n    }\n    return PointerEventListeners.instance;\n  }\n  /**\n   * @param {?} renderer\n   * @param {?} zone\n   */\n  constructor(renderer, zone) {\n    this.pointerDown = new Observable(observer => {\n      /** @type {?} */\n      let unsubscribeMouseDown;\n      /** @type {?} */\n      let unsubscribeTouchStart;\n      zone.runOutsideAngular(() => {\n        unsubscribeMouseDown = renderer.listen('document', 'mousedown', event => {\n          observer.next({\n            clientX: event.clientX,\n            clientY: event.clientY,\n            event\n          });\n        });\n        if (IS_TOUCH_DEVICE) {\n          unsubscribeTouchStart = renderer.listen('document', 'touchstart', event => {\n            observer.next({\n              clientX: event.touches[0].clientX,\n              clientY: event.touches[0].clientY,\n              event\n            });\n          });\n        }\n      });\n      return () => {\n        unsubscribeMouseDown();\n        if (IS_TOUCH_DEVICE) {\n          /** @type {?} */unsubscribeTouchStart();\n        }\n      };\n    }).pipe(share());\n    this.pointerMove = new Observable(observer => {\n      /** @type {?} */\n      let unsubscribeMouseMove;\n      /** @type {?} */\n      let unsubscribeTouchMove;\n      zone.runOutsideAngular(() => {\n        unsubscribeMouseMove = renderer.listen('document', 'mousemove', event => {\n          observer.next({\n            clientX: event.clientX,\n            clientY: event.clientY,\n            event\n          });\n        });\n        if (IS_TOUCH_DEVICE) {\n          unsubscribeTouchMove = renderer.listen('document', 'touchmove', event => {\n            observer.next({\n              clientX: event.targetTouches[0].clientX,\n              clientY: event.targetTouches[0].clientY,\n              event\n            });\n          });\n        }\n      });\n      return () => {\n        unsubscribeMouseMove();\n        if (IS_TOUCH_DEVICE) {\n          /** @type {?} */unsubscribeTouchMove();\n        }\n      };\n    }).pipe(share());\n    this.pointerUp = new Observable(observer => {\n      /** @type {?} */\n      let unsubscribeMouseUp;\n      /** @type {?} */\n      let unsubscribeTouchEnd;\n      /** @type {?} */\n      let unsubscribeTouchCancel;\n      zone.runOutsideAngular(() => {\n        unsubscribeMouseUp = renderer.listen('document', 'mouseup', event => {\n          observer.next({\n            clientX: event.clientX,\n            clientY: event.clientY,\n            event\n          });\n        });\n        if (IS_TOUCH_DEVICE) {\n          unsubscribeTouchEnd = renderer.listen('document', 'touchend', event => {\n            observer.next({\n              clientX: event.changedTouches[0].clientX,\n              clientY: event.changedTouches[0].clientY,\n              event\n            });\n          });\n          unsubscribeTouchCancel = renderer.listen('document', 'touchcancel', event => {\n            observer.next({\n              clientX: event.changedTouches[0].clientX,\n              clientY: event.changedTouches[0].clientY,\n              event\n            });\n          });\n        }\n      });\n      return () => {\n        unsubscribeMouseUp();\n        if (IS_TOUCH_DEVICE) {\n          /** @type {?} */unsubscribeTouchEnd();\n          /** @type {?} */unsubscribeTouchCancel();\n        }\n      };\n    }).pipe(share());\n  }\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * An element placed inside a `mwlResizable` directive to be used as a drag and resize handle\n *\n * For example\n *\n * ```html\n * <div mwlResizable>\n *   <div mwlResizeHandle [resizeEdges]=\"{bottom: true, right: true}\"></div>\n * </div>\n * ```\n * Or in case they are sibling elements:\n * ```html\n * <div mwlResizable #resizableElement=\"mwlResizable\"></div>\n * <div mwlResizeHandle [resizableContainer]=\"resizableElement\" [resizeEdges]=\"{bottom: true, right: true}\"></div>\n * ```\n */\nlet ResizeHandleDirective = /*#__PURE__*/(() => {\n  class ResizeHandleDirective {\n    /**\n     * @param {?} renderer\n     * @param {?} element\n     * @param {?} zone\n     * @param {?} resizableDirective\n     */\n    constructor(renderer, element, zone, resizableDirective) {\n      this.renderer = renderer;\n      this.element = element;\n      this.zone = zone;\n      this.resizableDirective = resizableDirective;\n      /**\n       * The `Edges` object that contains the edges of the parent element that dragging the handle will trigger a resize on\n       */\n      this.resizeEdges = {};\n      this.eventListeners = {};\n      this.destroy$ = new Subject();\n    }\n    /**\n     * @return {?}\n     */\n    ngOnInit() {\n      this.zone.runOutsideAngular(() => {\n        this.listenOnTheHost('mousedown').subscribe(event => {\n          this.onMousedown(event, event.clientX, event.clientY);\n        });\n        this.listenOnTheHost('mouseup').subscribe(event => {\n          this.onMouseup(event.clientX, event.clientY);\n        });\n        if (IS_TOUCH_DEVICE) {\n          this.listenOnTheHost('touchstart').subscribe(event => {\n            this.onMousedown(event, event.touches[0].clientX, event.touches[0].clientY);\n          });\n          merge(this.listenOnTheHost('touchend'), this.listenOnTheHost('touchcancel')).subscribe(event => {\n            this.onMouseup(event.changedTouches[0].clientX, event.changedTouches[0].clientY);\n          });\n        }\n      });\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n      this.destroy$.next();\n      this.unsubscribeEventListeners();\n    }\n    /**\n     * @hidden\n     * @param {?} event\n     * @param {?} clientX\n     * @param {?} clientY\n     * @return {?}\n     */\n    onMousedown(event, clientX, clientY) {\n      event.preventDefault();\n      if (!this.eventListeners.touchmove) {\n        this.eventListeners.touchmove = this.renderer.listen(this.element.nativeElement, 'touchmove', touchMoveEvent => {\n          this.onMousemove(touchMoveEvent, touchMoveEvent.targetTouches[0].clientX, touchMoveEvent.targetTouches[0].clientY);\n        });\n      }\n      if (!this.eventListeners.mousemove) {\n        this.eventListeners.mousemove = this.renderer.listen(this.element.nativeElement, 'mousemove', mouseMoveEvent => {\n          this.onMousemove(mouseMoveEvent, mouseMoveEvent.clientX, mouseMoveEvent.clientY);\n        });\n      }\n      this.resizable.mousedown.next({\n        clientX,\n        clientY,\n        edges: this.resizeEdges\n      });\n    }\n    /**\n     * @hidden\n     * @param {?} clientX\n     * @param {?} clientY\n     * @return {?}\n     */\n    onMouseup(clientX, clientY) {\n      this.unsubscribeEventListeners();\n      this.resizable.mouseup.next({\n        clientX,\n        clientY,\n        edges: this.resizeEdges\n      });\n    }\n    // directive might be passed from DI or as an input\n    /**\n     * @private\n     * @return {?}\n     */\n    get resizable() {\n      return this.resizableDirective || this.resizableContainer;\n    }\n    /**\n     * @private\n     * @param {?} event\n     * @param {?} clientX\n     * @param {?} clientY\n     * @return {?}\n     */\n    onMousemove(event, clientX, clientY) {\n      this.resizable.mousemove.next({\n        clientX,\n        clientY,\n        edges: this.resizeEdges,\n        event\n      });\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n    unsubscribeEventListeners() {\n      Object.keys(this.eventListeners).forEach(type => {\n        /** @type {?} */this.eventListeners[type]();\n        delete this.eventListeners[type];\n      });\n    }\n    /**\n     * @private\n     * @template T\n     * @param {?} eventName\n     * @return {?}\n     */\n    listenOnTheHost(eventName) {\n      return fromEvent(this.element.nativeElement, eventName).pipe(takeUntil(this.destroy$));\n    }\n  }\n  ResizeHandleDirective.Éµfac = function ResizeHandleDirective_Factory(t) {\n    return new (t || ResizeHandleDirective)(Éµngcc0.ÉµÉµdirectiveInject(Éµngcc0.Renderer2), Éµngcc0.ÉµÉµdirectiveInject(Éµngcc0.ElementRef), Éµngcc0.ÉµÉµdirectiveInject(Éµngcc0.NgZone), Éµngcc0.ÉµÉµdirectiveInject(ResizableDirective, 8));\n  };\n  ResizeHandleDirective.Éµdir = /*@__PURE__*/Éµngcc0.ÉµÉµdefineDirective({\n    type: ResizeHandleDirective,\n    selectors: [[\"\", \"mwlResizeHandle\", \"\"]],\n    inputs: {\n      resizeEdges: \"resizeEdges\",\n      resizableContainer: \"resizableContainer\"\n    }\n  });\n  /** @nocollapse */\n  return ResizeHandleDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nlet ResizableModule = /*#__PURE__*/(() => {\n  class ResizableModule {}\n  ResizableModule.Éµfac = function ResizableModule_Factory(t) {\n    return new (t || ResizableModule)();\n  };\n  ResizableModule.Éµmod = /*@__PURE__*/Éµngcc0.ÉµÉµdefineNgModule({\n    type: ResizableModule\n  });\n  ResizableModule.Éµinj = /*@__PURE__*/Éµngcc0.ÉµÉµdefineInjector({});\n  return ResizableModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && Éµngcc0.ÉµÉµsetNgModuleScope(ResizableModule, {\n    declarations: [ResizableDirective, ResizeHandleDirective],\n    exports: [ResizableDirective, ResizeHandleDirective]\n  });\n})();\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\nexport { ResizableDirective, ResizeHandleDirective, ResizableModule };\n\n//# sourceMappingURL=angular-resizable-element.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}